# -*- coding: utf-8 -*-
"""
Bot.BSG ‚Äî Telegram Bot (SINGLE FILE, FULL PROJECT)
–í–µ—Ä—Å–∏—è 18.0.0 | –†–µ–≤–∏–∑–∏—è sr-bot-2025-10-05-finance2
—á
–ó–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏:
  pip install aiogram==2.25.1 openpyxl pillow

–ì–õ–ê–í–ù–û–ï, –ß–¢–û –°–î–ï–õ–ê–ù–û/–û–ë–ù–û–í–õ–ï–ù–û:
- –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è: –§–ò–û + —Ç–µ–ª–µ—Ñ–æ–Ω (–∫–Ω–æ–ø–∫–∞ ¬´üì± –û—Ç–ø—Ä–∞–≤–∏—Ç—å –Ω–æ–º–µ—Ä¬ª). –ù–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ –ø—Ä–∏—Å–≤–∞–∏–≤–∞–µ—Ç—Å—è —É–Ω–∏–∫–∞–ª—å–Ω—ã–π –∫–æ–¥ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: BSU-XXXX.
- –Ø–∫–æ—Ä—å-–º–µ–Ω—é: –æ–¥–Ω–æ –ø–æ—Å—Ç–æ—è–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ, –Ω–µ –¥—É–±–ª–∏—Ä—É–µ—Ç—Å—è, –Ω–µ –∑–∞–∫—Ä—ã–≤–∞–µ—Ç –º–µ–Ω—é. –û–±–Ω–æ–≤–ª—è–µ—Ç—Å—è –ø—Ä–∏ —Å–º–µ–Ω–µ –∞–∫—Ç–∏–≤–Ω–æ–≥–æ –ø—Ä–æ–µ–∫—Ç–∞.
- –ü—Ä–æ–µ–∫—Ç—ã (–∞–¥–º–∏–Ω): —Å–æ–∑–¥–∞—Ç—å (–Ω–∞–∑–≤–∞–Ω–∏–µ, –ª–æ–∫–∞—Ü–∏—è, –æ–ø–∏—Å–∞–Ω–∏–µ, –¥–∞—Ç—ã, PDF), –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞—Ç—å, –∑–∞–≤–µ—Ä—à–∏—Ç—å. –†–∞—Å—Å—ã–ª–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º —Å –∫–Ω–æ–ø–∫–æ–π ¬´–ó–∞–∫—Ä—ã—Ç—å¬ª.
- –î–æ–∫—É–º–µ–Ω—Ç—ã: –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ –≤–∏–¥—è—Ç PDF –∞–∫—Ç–∏–≤–Ω–æ–≥–æ –ø—Ä–æ–µ–∫—Ç–∞.
- –ß–µ–∫–∏ (–±–µ–∑ OCR): –§–æ—Ç–æ ‚Üí –°—É–º–º–∞ ‚Üí –û–ø–∏—Å–∞–Ω–∏–µ (–æ–ø—Ü.) ‚Üí –°—Ç–∞—Ç—É—Å –æ–ø–ª–∞—Ç—ã (–û–ø–ª–∞—á–µ–Ω/–ù–µ –æ–ø–ª–∞—á–µ–Ω/–ü–æ–∑–∂–µ) ‚Üí –ü—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä ‚Üí –°–æ—Ö—Ä–∞–Ω–∏—Ç—å/–û—Ç–º–µ–Ω–∏—Ç—å.
  –°–æ—Ö—Ä–∞–Ω—è–µ—Ç—Å—è: –¥–∞—Ç–∞, –≤—Ä–µ–º—è, —Å—É–º–º–∞, —Ñ–∞–π–ª, –æ–ø–∏—Å–∞–Ω–∏–µ, paid, receipt_no (RID-XXXX).
- –ü–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ —Ñ–∞–π–ª–æ–≤ —á–µ–∫–æ–≤: {SafeUserName}_BSU{BSU}_RID{RID-XXXX}_{YYYY-mm-dd_HH-MM-SS}_amt-xx.xx.jpg (–Ω–∏–∫–æ–≥–¥–∞ –Ω–µ –ø–æ–≤—Ç–æ—Ä—è–µ—Ç—Å—è –∑–∞ —Å—á—ë—Ç —Å—á—ë—Ç—á–∏–∫–∞ –∏ –≤—Ä–µ–º–µ–Ω–∏).
- ¬´–ú–æ–∏ —á–µ–∫–∏¬ª: –∫–∞–∂–¥–æ–µ —Ñ–æ—Ç–æ + –¥–∞—Ç–∞, —Å—É–º–º–∞, –æ–ø–∏—Å–∞–Ω–∏–µ, —Å—Ç–∞—Ç—É—Å, –ù–û–ú–ï–† –ß–ï–ö–ê (RID-XXXX). –ú–æ–∂–Ω–æ –ø—Ä–æ—Å—Ç–∞–≤–∏—Ç—å –æ–ø–ª–∞—á–µ–Ω–æ/–Ω–µ –æ–ø–ª–∞—á–µ–Ω–æ, –µ—Å–ª–∏ –Ω–µ —É–∫–∞–∑–∞–Ω–æ.
- –§–∏–Ω–∞–Ω—Å—ã (–Ω–æ–≤—ã–µ): —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ –ø—Ä–æ–µ–∫—Ç—É (–≤—Å–µ–≥–æ/–æ–ø–ª–∞—á–µ–Ω–æ/–Ω–µ –æ–ø–ª–∞—á–µ–Ω–æ), —Å–ø–∏—Å–æ–∫ –Ω–µ–æ–ø–ª–∞—á–µ–Ω–Ω—ã—Ö, ¬´üì® –ó–∞–ø—Ä–æ—Å–∏—Ç—å –≤—ã–ø–ª–∞—Ç—É¬ª.
- –í—ã–ø–ª–∞—Ç—ã/–∑–∞–ø—Ä–æ—Å—ã ‚Äî –§–ê–ô–õ–û–í–û–ï –•–†–ê–ù–ï–ù–ò–ï:
    data/finances/req_<timestamp>_<uid>.json  (pending/approved/confirmed + –≤—Å—è –¥–µ—Ç–∞–ª–∏–∑–∞—Ü–∏—è).
  –ò—Å—Ç–æ—Ä–∏—è –∏ –∑–∞–ø—Ä–æ—Å—ã –≥—Ä—É–∑—è—Ç—Å—è —Å –¥–∏—Å–∫–∞, –ø–µ—Ä–µ–∂–∏–≤–∞—é—Ç –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫.
- –ü–æ—Ç–æ–∫ –≤—ã–ø–ª–∞—Ç:
  –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å ‚Üí ¬´üì® –ó–∞–ø—Ä–æ—Å–∏—Ç—å –≤—ã–ø–ª–∞—Ç—É¬ª ‚Üí —Å–æ–∑–¥–∞—ë—Ç—Å—è —Ñ–∞–π–ª-–∑–∞–ø—Ä–æ—Å ‚Üí –ê–¥–º–∏–Ω –≤–∏–¥–∏—Ç –≤ ¬´üíµ –§–∏–Ω–∞–Ω—Å—ã/–ó–∞–ø—Ä–æ—Å—ã¬ª
  –ê–¥–º–∏–Ω: ¬´–ü–æ—Å–º–æ—Ç—Ä–µ—Ç—å —á–µ–∫–∏¬ª, ¬´‚úÖ –í—ã–ø–ª–∞—Ç–∏—Ç—å¬ª, ¬´‚ùå –ó–∞–∫—Ä—ã—Ç—å¬ª.
  –ü—Ä–∏ ¬´‚úÖ –í—ã–ø–ª–∞—Ç–∏—Ç—å¬ª –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é –ø—Ä–∏—Ö–æ–¥—è—Ç –æ—Ç–¥–µ–ª—å–Ω—ã–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è ¬´üíµ –í—ã–ø–ª–∞—Ç–∞ –∑–∞ —á–µ–∫ ...¬ª, —É –ö–ê–ñ–î–û–ì–û —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –µ—Å—Ç—å ¬´‚úÖ –î–µ–Ω—å–≥–∏ –ø–æ–ª—É—á–µ–Ω—ã¬ª/¬´‚ùå –ó–∞–∫—Ä—ã—Ç—å¬ª.
  –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–∞–µ—Ç –ø–æ–ª—É—á–µ–Ω–∏–µ ‚Äî —Å—Ç–∞—Ç—É—Å –∑–∞–ø—Ä–æ—Å–∞ ‚Üí confirmed, —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç—Å—è –≤ —Ñ–∞–π–ª–µ –∑–∞–ø—Ä–æ—Å–∞ –∏ –≤ –ø—Ä–æ—Ñ–∏–ª–µ; –∞–¥–º–∏–Ω—É –ø—Ä–∏—Ö–æ–¥–∏—Ç ¬´–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –ø–æ–¥—Ç–≤–µ—Ä–¥–∏–ª –ø–æ–ª—É—á–µ–Ω–∏–µ ...¬ª.
  –í ¬´–§–∏–Ω–∞–Ω—Å—ã¬ª –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¥–æ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –≤–∏—Å–∏—Ç –º–µ—Ç–∫–∞: ¬´‚ö†Ô∏è –ï—Å—Ç—å –æ–¥–æ–±—Ä–µ–Ω–Ω—ã–µ –≤—ã–ø–ª–∞—Ç—ã, –ø–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ –ø–æ–ª—É—á–µ–Ω–∏–µ –¥–µ–Ω–µ–≥¬ª.
- Excel Ledger (—É–ª—É—á—à–µ–Ω–æ ¬´–∫—Ä–∞—Å–∏–≤–æ¬ª):
  ‚Ä¢ –ì–ª–∞–≤–Ω–∞—è –∫–Ω–∏–≥–∞: data/projects/<P>/ledger.xlsx
  ‚Ä¢ –õ–∏—Å—Ç "Ledger": —Å—Ç–æ–ª–±—Ü—ã ‚Üí –î–∞—Ç–∞, –í—Ä–µ–º—è, –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å, BSU, –ù–æ–º–µ—Ä —á–µ–∫–∞, –°—É–º–º–∞, –§–∞–π–ª, –û–ø–∏—Å–∞–Ω–∏–µ, –û–ø–ª–∞—á–µ–Ω(1/0/None)
  ‚Ä¢ –û—Ç–¥–µ–ª—å–Ω—ã–µ –õ–ò–°–¢–´ –ø–æ –∫–∞–∂–¥–æ–º—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é (–ø–æ –∏–º–µ–Ω–∏ + BSU) —Å —Ç–∞–∫–∏–º–∏ –∂–µ —Å—Ç–æ–ª–±—Ü–∞–º–∏.
  ‚Ä¢ –í Excel –∑–∞–ø–∏—Å—ã–≤–∞–µ—Ç—Å—è –ò–ú–Ø –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, –∞ –Ω–µ ID.
- SOS: –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ ‚Üí –∑–∞–ø—Ä–æ—Å –≥–µ–æ–ª–æ–∫–∞—Ü–∏–∏ ‚Üí —Ä–∞—Å—Å—ã–ª–∫–∞ –≤—Å–µ–º –ö–†–û–ú–ï –æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—è; —É –æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—è ¬´üÜò SOS –≤–∫–ª—é—á—ë–Ω. –°–∏–≥–Ω–∞–ª –ø—Ä–∏–Ω—è—Ç.¬ª (–Ω–µ —É–¥–∞–ª—è–µ—Ç—Å—è, –ø–æ–∫–∞ –Ω–µ –Ω–∞–∂–º—ë—Ç ¬´–ó–∞–∫—Ä—ã—Ç—å¬ª).
- –ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å:
  ‚Ä¢ ¬´üë• –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏¬ª (–∫–∞—Ä—Ç–æ—á–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Å –ø–æ–ª–Ω–æ–π –∏–Ω—Ñ–æ–π –∏ —É–ª—É—á—à–µ–Ω–Ω—ã–º –æ—Ñ–æ—Ä–º–ª–µ–Ω–∏–µ–º)
  ‚Ä¢ ¬´üìÇ –ü—Ä–æ–µ–∫—Ç—ã¬ª
  ‚Ä¢ ¬´üíµ –§–∏–Ω–∞–Ω—Å—ã¬ª: ¬´–ó–∞–ø—Ä–æ—Å—ã¬ª –∏ ¬´–ò—Å—Ç–æ—Ä–∏—è¬ª (–≤—Å—ë —Å —Ñ–∞–π–ª–æ–≤)
- –û—á–∏—Å—Ç–∫–∞ —á–∞—Ç–∞: —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –Ω–µ –æ—á–∏—â–∞–µ—Ç—Å—è –¥–æ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è ¬´–ü—Ä–æ—Ñ–∏–ª—å —Å–æ—Ö—Ä–∞–Ω—ë–Ω¬ª, –¥–∞–ª–µ–µ –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è –æ—á–∏—â–∞—é—Ç—Å—è. –Ø–∫–æ—Ä—å-–º–µ–Ω—é –Ω–µ —É–¥–∞–ª—è–µ—Ç—Å—è, —Ç–æ–ª—å–∫–æ –∑–∞–º–µ–Ω—è–µ—Ç—Å—è.

–¢–æ–∫–µ–Ω: –≤—Å—Ç—Ä–æ–µ–Ω –ø–æ –ø—Ä–æ—Å—å–±–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.
"""

import os, sys, json, random, re, base64, hashlib, secrets, asyncio
import unicodedata
from html import escape as html_escape
from datetime import datetime, timezone, timedelta
from typing import Dict, Optional, List, Tuple, Any, Set, Union

from openpyxl import Workbook, load_workbook
from openpyxl.utils import get_column_letter
from PIL import Image, ExifTags, ImageOps
from aiogram import Bot, Dispatcher, types
from aiogram.utils import executor
from aiogram.utils.exceptions import MessageNotModified, MessageCantBeEdited
from aiogram.types import (
    InlineKeyboardMarkup, InlineKeyboardButton,
    InputFile, ContentType, ReplyKeyboardRemove,
    KeyboardButton, ReplyKeyboardMarkup
)
from aiogram.contrib.fsm_storage.memory import MemoryStorage
from aiogram.dispatcher import FSMContext
from aiogram.dispatcher.filters.state import State, StatesGroup
import requests

try:
    from zoneinfo import ZoneInfo
except Exception:
    ZoneInfo = None


# ========================== CONFIG ==========================
TOKEN = "7005343266:AAG0bnY-wTc3kScKiIskSd0fO6MstesSbCk"
ADMIN_CODE = "3004"

BOT_NAME = "Bot.BSG"
BOT_VERSION = "18.0.0"
BOT_REVISION = "sr-bot-2025-10-05-finance2"

BASE_PATH = "data/projects"
USERS_PATH = "data/users"
BOT_FILE = "data/bot.json"
FIN_PATH = "data/finances"  # –∑–∞–ø—Ä–æ—Å—ã/–∏—Å—Ç–æ—Ä–∏—è –≤—ã–ø–ª–∞—Ç (—Ñ–∞–π–ª–æ–≤–æ)

ALLOWED_IMAGE_EXTENSIONS = {".jpg", ".jpeg", ".png", ".webp", ".bmp", ".heic", ".heif", ".tif", ".tiff"}

ALERTS_API_BASE_URL = "https://api.alerts.in.ua/v1"
ALERTS_API_ACTIVE_ENDPOINT = "/alerts/active.json"
ALERTS_API_HISTORY_TEMPLATE = "/regions/{uid}/alerts/{period}.json"
ALERTS_API_URL = f"{ALERTS_API_BASE_URL}{ALERTS_API_ACTIVE_ENDPOINT}"
ALERTS_DEFAULT_HISTORY_PERIOD = "week_ago"
ALERTS_API_TOKEN = "62f89091e56951ef257f763e445c09c1fd9dacd1ab2203"
ALERTS_API_TIMEOUT = 15
ALERTS_POLL_INTERVAL = 5  # seconds
ALERTS_HISTORY_CACHE_TTL = 300  # seconds
ALERTS_STANDDOWN_DISPLAY_WINDOW = 90 * 60  # seconds
ALERTS_DIRNAME = "alerts"
ALERTS_STATE_FILENAME = "state.json"
ALERTS_HISTORY_DIRNAME = "history"
ALERTS_LEGACY_HISTORY_FILENAME = "history.json"
ALERTS_USERS_FILENAME = "subscriptions.json"
ALERTS_TIMELINE_KEY = "timeline"

UKRAINE_REGIONS = [
    "–í–∏–Ω–Ω–∏—Ü–∫–∞—è –æ–±–ª–∞—Å—Ç—å",
    "–í–æ–ª—ã–Ω—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å",
    "–î–Ω–µ–ø—Ä–æ–ø–µ—Ç—Ä–æ–≤—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å",
    "–î–æ–Ω–µ—Ü–∫–∞—è –æ–±–ª–∞—Å—Ç—å",
    "–ñ–∏—Ç–æ–º–∏—Ä—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å",
    "–ó–∞–∫–∞—Ä–ø–∞—Ç—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å",
    "–ó–∞–ø–æ—Ä–æ–∂—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å",
    "–ò–≤–∞–Ω–æ-–§—Ä–∞–Ω–∫–æ–≤—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å",
    "–ö–∏–µ–≤—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å",
    "–ö–∏—Ä–æ–≤–æ–≥—Ä–∞–¥—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å",
    "–õ—É–≥–∞–Ω—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å",
    "–õ—å–≤–æ–≤—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å",
    "–ù–∏–∫–æ–ª–∞–µ–≤—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å",
    "–û–¥–µ—Å—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å",
    "–ü–æ–ª—Ç–∞–≤—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å",
    "–†–æ–≤–µ–Ω—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å",
    "–°—É–º—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å",
    "–¢–µ—Ä–Ω–æ–ø–æ–ª—å—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å",
    "–•–∞—Ä—å–∫–æ–≤—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å",
    "–•–µ—Ä—Å–æ–Ω—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å",
    "–•–º–µ–ª—å–Ω–∏—Ü–∫–∞—è –æ–±–ª–∞—Å—Ç—å",
    "–ß–µ—Ä–∫–∞—Å—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å",
    "–ß–µ—Ä–Ω–∏–≥–æ–≤—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å",
    "–ß–µ—Ä–Ω–æ–≤–∏—Ü–∫–∞—è –æ–±–ª–∞—Å—Ç—å",
]
UKRAINE_REGIONS_SET: Set[str] = set(UKRAINE_REGIONS)

LANG_ORDER = [
    ("uk", "üá∫üá¶ –£–∫—Ä–∞—ó–Ω—Å—å–∫–∞"),
    ("en", "üá¨üáß English"),
    ("de", "üá©üá™ Deutsch"),
    ("pl", "üáµüá± Polski"),
    ("ru", "üá∑üá∫ –†—É—Å—Å–∫–∏–π"),
]
LANG_LABELS = {code: label for code, label in LANG_ORDER}

DEFAULT_LANG = "uk"

TEXTS: Dict[str, Dict[str, str]] = {
    "ANCHOR_NO_PROJECT": {
        "uk": "üèó <b>{bot}</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nüîç –ê–∫—Ç–∏–≤–Ω–∏–π –ø—Ä–æ—î–∫—Ç —â–µ –Ω–µ –æ–±—Ä–∞–Ω–æ.\n–ü–æ–ø—Ä–æ—Å—ñ—Ç—å –∞–¥–º—ñ–Ω—ñ—Å—Ç—Ä–∞—Ç–æ—Ä–∞ –∞–∫—Ç–∏–≤—É–≤–∞—Ç–∏ –æ–±'—î–∫—Ç, —â–æ–± –≤—ñ–¥–∫—Ä–∏—Ç–∏ —Ä–æ–±–æ—á—ñ —Ä–æ–∑–¥—ñ–ª–∏.\n\nüìã <b>–ú–µ–Ω—é –¥—ñ–π</b>\n–°–∫–æ—Ä–∏—Å—Ç–∞–π—Ç–µ—Å—è –∫–Ω–æ–ø–∫–∞–º–∏ –Ω–∏–∂—á–µ, —â–æ–± –ø–µ—Ä–µ–≥–ª—è–Ω—É—Ç–∏ –¥–æ—Å—Ç—É–ø–Ω—ñ –º–æ–∂–ª–∏–≤–æ—Å—Ç—ñ.",
        "en": "üèó <b>{bot}</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nüîç No active project has been selected yet.\nAsk an administrator to activate a project to unlock the working sections.\n\nüìã <b>Actions</b>\nUse the buttons below to explore the available features.",
        "de": "üèó <b>{bot}</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nüîç Es ist derzeit kein aktives Projekt ausgew√§hlt.\nBitten Sie einen Administrator, ein Projekt zu aktivieren, um die Arbeitsbereiche zu √∂ffnen.\n\nüìã <b>Aktionen</b>\nVerwenden Sie die Schaltfl√§chen unten, um die verf√ºgbaren Funktionen zu erkunden.",
        "pl": "üèó <b>{bot}</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nüîç Aktywny projekt nie zosta≈Ç jeszcze wybrany.\nPopro≈õ administratora o aktywacjƒô obiektu, aby odblokowaƒá sekcje robocze.\n\nüìã <b>Menu dzia≈Ça≈Ñ</b>\nSkorzystaj z przycisk√≥w poni≈ºej, aby zobaczyƒá dostƒôpne funkcje.",
        "ru": "üèó <b>{bot}</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nüîç –ê–∫—Ç–∏–≤–Ω—ã–π –æ–±—ä–µ–∫—Ç –ø–æ–∫–∞ –Ω–µ –≤—ã–±—Ä–∞–Ω.\n–ü–æ–ø—Ä–æ—Å–∏—Ç–µ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞ –≤–∫–ª—é—á–∏—Ç—å –ø—Ä–æ–µ–∫—Ç, —á—Ç–æ–±—ã –æ—Ç–∫—Ä—ã—Ç—å —Ä–∞–±–æ—á–∏–µ —Ä–∞–∑–¥–µ–ª—ã.\n\nüìã <b>–ú–µ–Ω—é –¥–µ–π—Å—Ç–≤–∏–π</b>\n–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫–∏ –Ω–∏–∂–µ, —á—Ç–æ–±—ã –∏–∑—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø–Ω—ã–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏.",
    },
    "ANCHOR_PROJECT": {
        "uk": "üèó <b>{bot}</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nüìÇ <b>{name}</b>\nüÜî –ö–æ–¥ –ø—Ä–æ—î–∫—Ç—É: {code}\nüåç –û–±–ª–∞—Å—Ç—å: {region}\nüìç –õ–æ–∫–∞—Ü—ñ—è: {location}\nüñº –§–æ—Ç–æ–∞—Ä—Ö—ñ–≤: <b>{photos}</b> —à—Ç.\nüóì –ü–µ—Ä—ñ–æ–¥ —Ä–æ–±—ñ—Ç: {start} ‚Üí {end}\n{bsg_section}\n{alerts_section}\n\nüìã <b>–ú–µ–Ω—é –¥—ñ–π</b>\n–û–±–µ—Ä—ñ—Ç—å –ø–æ—Ç—Ä—ñ–±–Ω–∏–π —Ä–æ–∑–¥—ñ–ª –Ω–∏–∂—á–µ, —â–æ–± –¥–æ–¥–∞—Ç–∏ —á–µ–∫, –ø–µ—Ä–µ–≥–ª—è–Ω—É—Ç–∏ –¥–æ–∫—É–º–µ–Ω—Ç–∏ –∞–±–æ –ø–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ —Ñ—ñ–Ω–∞–Ω—Å–∏.",
        "en": "üèó <b>{bot}</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nüìÇ <b>{name}</b>\nüÜî Project code: {code}\nüåç Oblast: {region}\nüìç Location: {location}\nüñº Photo archive: <b>{photos}</b> items\nüóì Work period: {start} ‚Üí {end}\n{bsg_section}\n{alerts_section}\n\nüìã <b>Actions</b>\nChoose the section below to add receipts, open documents, or review finance details.",
        "de": "üèó <b>{bot}</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nüìÇ <b>{name}</b>\nüÜî Projektcode: {code}\nüåç Oblast: {region}\nüìç Standort: {location}\nüñº Fotoarchiv: <b>{photos}</b> Elemente\nüóì Arbeitszeitraum: {start} ‚Üí {end}\n{bsg_section}\n{alerts_section}\n\nüìã <b>Aktionen</b>\nW√§hlen Sie unten einen Bereich, um Belege hinzuzuf√ºgen, Dokumente zu √∂ffnen oder Finanzdaten einzusehen.",
        "pl": "üèó <b>{bot}</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nüìÇ <b>{name}</b>\nüÜî Kod projektu: {code}\nüåç Obw√≥d: {region}\nüìç Lokalizacja: {location}\nüñº Archiwum zdjƒôƒá: <b>{photos}</b> szt.\nüóì Okres prac: {start} ‚Üí {end}\n{bsg_section}\n{alerts_section}\n\nüìã <b>Menu dzia≈Ça≈Ñ</b>\nWybierz sekcjƒô poni≈ºej, aby dodaƒá paragon, otworzyƒá dokumenty lub sprawdziƒá finanse.",
        "ru": "üèó <b>{bot}</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nüìÇ <b>{name}</b>\nüÜî –ö–æ–¥ –ø—Ä–æ–µ–∫—Ç–∞: {code}\nüåç –û–±–ª–∞—Å—Ç—å: {region}\nüìç –õ–æ–∫–∞—Ü–∏—è: {location}\nüñº –§–æ—Ç–æ–∞—Ä—Ö–∏–≤: <b>{photos}</b> —à—Ç.\nüóì –ü–µ—Ä–∏–æ–¥ —Ä–∞–±–æ—Ç: {start} ‚Üí {end}\n{bsg_section}\n{alerts_section}\n\nüìã <b>–ú–µ–Ω—é –¥–µ–π—Å—Ç–≤–∏–π</b>\n–í—ã–±–µ—Ä–∏—Ç–µ –Ω—É–∂–Ω—ã–π —Ä–∞–∑–¥–µ–ª –Ω–∏–∂–µ, —á—Ç–æ–±—ã –¥–æ–±–∞–≤–∏—Ç—å —á–µ–∫, –æ—Ç–∫—Ä—ã—Ç—å –¥–æ–∫—É–º–µ–Ω—Ç—ã –∏–ª–∏ –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —Ñ–∏–Ω–∞–Ω—Å—ã.",
    },
    "ANCHOR_PROJECT_BSG_SUMMARY": {
        "uk": "üè¢ –ü–æ—Å–∏–ª–∫–∏ BSG: —É—Å—å–æ–≥–æ ‚Äî <b>{total}</b> ‚Ä¢ –∑–∞–±—Ä–∞—Ç–∏ ‚Äî <b>{pending}</b> ‚Ä¢ –æ—Ç—Ä–∏–º–∞–Ω–æ ‚Äî <b>{delivered}</b>",
        "en": "üè¢ BSG parcels: total ‚Äî <b>{total}</b> ‚Ä¢ to collect ‚Äî <b>{pending}</b> ‚Ä¢ received ‚Äî <b>{delivered}</b>",
        "de": "üè¢ BSG-Sendungen: gesamt ‚Äî <b>{total}</b> ‚Ä¢ abzuholen ‚Äî <b>{pending}</b> ‚Ä¢ erhalten ‚Äî <b>{delivered}</b>",
        "pl": "üè¢ Przesy≈Çki BSG: ≈ÇƒÖcznie ‚Äî <b>{total}</b> ‚Ä¢ do odebrania ‚Äî <b>{pending}</b> ‚Ä¢ odebrano ‚Äî <b>{delivered}</b>",
        "ru": "üè¢ –ü–æ—Å—ã–ª–∫–∏ BSG: –≤—Å–µ–≥–æ ‚Äî <b>{total}</b> ‚Ä¢ –∑–∞–±—Ä–∞—Ç—å ‚Äî <b>{pending}</b> ‚Ä¢ –ø–æ–ª—É—á–µ–Ω–æ ‚Äî <b>{delivered}</b>",
    },
    "ANCHOR_ALERT_SUMMARY": {
        "uk": "üá∫üá¶ –ê–∫—Ç–∏–≤–Ω—ñ —Ç—Ä–∏–≤–æ–≥–∏: <b>{count}</b> –æ–±–ª–∞—Å—Ç–µ–π",
        "en": "üá∫üá¶ Active alerts: <b>{count}</b> oblasts",
        "de": "üá∫üá¶ Aktive Alarme: <b>{count}</b> Oblasten",
        "pl": "üá∫üá¶ Aktywne alarmy: <b>{count}</b> obwod√≥w",
        "ru": "üá∫üá¶ –ê–∫—Ç–∏–≤–Ω—ã–µ —Ç—Ä–µ–≤–æ–≥–∏: <b>{count}</b> –æ–±–ª–∞—Å—Ç–µ–π",
    },
    "ANCHOR_ALERT_ACTIVE": {
        "uk": "üö® –¢—Ä–∏–≤–æ–≥–∞ —É <b>{region}</b> ‚Ä¢ {type} ‚Ä¢ –≤—ñ–¥ {start} ‚Ä¢ {severity}",
        "en": "üö® Alert for <b>{region}</b> oblast ‚Ä¢ {type} ‚Ä¢ since {start} ‚Ä¢ {severity}",
        "de": "üö® Alarm f√ºr Oblast <b>{region}</b> ‚Ä¢ {type} ‚Ä¢ seit {start} ‚Ä¢ {severity}",
        "pl": "üö® Alarm w obwodzie <b>{region}</b> ‚Ä¢ {type} ‚Ä¢ od {start} ‚Ä¢ {severity}",
        "ru": "üö® –¢—Ä–µ–≤–æ–≥–∞ –≤ <b>{region}</b> ‚Ä¢ {type} ‚Ä¢ —Å {start} ‚Ä¢ {severity}",
    },
    "ANCHOR_ALERT_RECENT": {
        "uk": "üü° –û—Å—Ç–∞–Ω–Ω—è —Ç—Ä–∏–≤–æ–≥–∞ —É <b>{region}</b> ‚Ä¢ {type} ‚Ä¢ {start} ‚Üí {end}",
        "en": "üü° Last alert for <b>{region}</b> oblast ‚Ä¢ {type} ‚Ä¢ {start} ‚Üí {end}",
        "de": "üü° Letzter Alarm f√ºr Oblast <b>{region}</b> ‚Ä¢ {type} ‚Ä¢ {start} ‚Üí {end}",
        "pl": "üü° Ostatni alarm w obwodzie <b>{region}</b> ‚Ä¢ {type} ‚Ä¢ {start} ‚Üí {end}",
        "ru": "üü° –ü–æ—Å–ª–µ–¥–Ω—è—è —Ç—Ä–µ–≤–æ–≥–∞ –≤ <b>{region}</b> ‚Ä¢ {type} ‚Ä¢ {start} ‚Üí {end}",
    },
    "ANCHOR_ALERT_CALM": {
        "uk": "üü¢ –í –æ–±–ª–∞—Å—Ç—ñ <b>{region}</b> –≤—ñ–¥–±—ñ–π —Ç—Ä–∏–≤–æ–≥–∏.",
        "en": "üü¢ <b>{region}</b> oblast ‚Äî alert cleared.",
        "de": "üü¢ In der Oblast <b>{region}</b> wurde der Alarm aufgehoben.",
        "pl": "üü¢ W obwodzie <b>{region}</b> alarm odwo≈Çano.",
        "ru": "üü¢ –í –æ–±–ª–∞—Å—Ç–∏ <b>{region}</b> –æ—Ç–±–æ–π —Ç—Ä–µ–≤–æ–≥–∏.",
    },
    "ANCHOR_ALERT_CAUSE": {
        "uk": "üéØ –ü—Ä–∏—á–∏–Ω–∞: {cause}",
        "en": "üéØ Cause: {cause}",
        "de": "üéØ Ursache: {cause}",
        "pl": "üéØ Przyczyna: {cause}",
        "ru": "üéØ –ü—Ä–∏—á–∏–Ω–∞: {cause}",
    },
    "ANCHOR_ALERT_DETAILS": {
        "uk": "üîé –î–µ—Ç–∞–ª—ñ: {details}",
        "en": "üîé Details: {details}",
        "de": "üîé Details: {details}",
        "pl": "üîé Szczeg√≥≈Çy: {details}",
        "ru": "üîé –î–µ—Ç–∞–ª–∏: {details}",
    },
    "ANCHOR_ALERT_LOCATION": {
        "uk": "üìç –õ–æ–∫–∞—Ü—ñ—è: {location}",
        "en": "üìç Location: {location}",
        "de": "üìç Ort: {location}",
        "pl": "üìç Lokalizacja: {location}",
        "ru": "üìç –õ–æ–∫–∞—Ü–∏—è: {location}",
    },
    "ANCHOR_ALERT_COORDS": {
        "uk": "üß≠ –ö–æ–æ—Ä–¥–∏–Ω–∞—Ç–∏: {coords}",
        "en": "üß≠ Coordinates: {coords}",
        "de": "üß≠ Koordinaten: {coords}",
        "pl": "üß≠ Wsp√≥≈Çrzƒôdne: {coords}",
        "ru": "üß≠ –ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã: {coords}",
    },
    "BTN_CHECKS": {
        "uk": "üßæ –ß–µ–∫–∏",
        "en": "üßæ Receipts",
        "de": "üßæ Belege",
        "pl": "üßæ Paragony",
        "ru": "üßæ –ß–µ–∫–∏",
    },
    "BTN_DOCUMENTS": {
        "uk": "üìë –î–æ–∫—É–º–µ–Ω—Ç–∏",
        "en": "üìë Documents",
        "de": "üìë Dokumente",
        "pl": "üìë Dokumenty",
        "ru": "üìë –î–æ–∫—É–º–µ–Ω—Ç—ã",
    },
    "BTN_FINANCE": {
        "uk": "üíµ –§—ñ–Ω–∞–Ω—Å–∏",
        "en": "üíµ Finance",
        "de": "üíµ Finanzen",
        "pl": "üíµ Finanse",
        "ru": "üíµ –§–∏–Ω–∞–Ω—Å—ã",
    },
    "BTN_ALERTS": {
        "uk": "üö® –¢—Ä–∏–≤–æ–≥–∏",
        "en": "üö® Alerts",
        "de": "üö® Alarme",
        "pl": "üö® Alarmy",
        "ru": "üö® –¢—Ä–µ–≤–æ–≥–∏",
    },
    "BTN_SOS": {
        "uk": "üÜò SOS",
        "en": "üÜò SOS",
        "de": "üÜò SOS",
        "pl": "üÜò SOS",
        "ru": "üÜò SOS",
    },
    "BTN_ADMIN": {
        "uk": "üßë‚Äçüíº –ê–¥–º—ñ–Ω-–ø–∞–Ω–µ–ª—å",
        "en": "üßë‚Äçüíº Admin panel",
        "de": "üßë‚Äçüíº Adminbereich",
        "pl": "üßë‚Äçüíº Panel administratora",
        "ru": "üßë‚Äçüíº –ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å",
    },
    "BTN_ABOUT": {
        "uk": "‚ÑπÔ∏è –ü—Ä–æ –±–æ—Ç–∞",
        "en": "‚ÑπÔ∏è About",
        "de": "‚ÑπÔ∏è √úber den Bot",
        "pl": "‚ÑπÔ∏è O bocie",
        "ru": "‚ÑπÔ∏è –û –±–æ—Ç–µ",
    },
    "ALERTS_MENU_INTRO": {
        "uk": "üö® <b>–ü–æ–≤—ñ—Ç—Ä—è–Ω—ñ —Ç—Ä–∏–≤–æ–≥–∏</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n–ü–µ—Ä–µ–≥–ª—è–¥–∞–π—Ç–µ –∞–∫—Ç–∏–≤–Ω—ñ —Å–∏–≥–Ω–∞–ª–∏, —ñ—Å—Ç–æ—Ä—ñ—é —Ç–∞ –∫–µ—Ä—É–π—Ç–µ –æ–±–ª–∞—Å—Ç—è–º–∏ —Å–ø–æ–≤—ñ—â–µ–Ω—å.\n–í–∏–±–µ—Ä—ñ—Ç—å –¥—ñ—é –Ω–∏–∂—á–µ.",
        "en": "üö® <b>Air alerts</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nReview active warnings, browse history, and manage the regions you follow.\nChoose an option below.",
        "de": "üö® <b>Luftalarme</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nSehen Sie aktive Warnungen, den Verlauf und verwalten Sie Ihre Regionen.\nW√§hlen Sie eine Aktion unten.",
        "pl": "üö® <b>Alarmy powietrzne</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nPrzeglƒÖdaj aktywne ostrze≈ºenia, historiƒô i zarzƒÖdzaj regionami powiadomie≈Ñ.\nWybierz dzia≈Çanie poni≈ºej.",
        "ru": "üö® <b>–í–æ–∑–¥—É—à–Ω—ã–µ —Ç—Ä–µ–≤–æ–≥–∏</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n–ü—Ä–æ—Å–º–∞—Ç—Ä–∏–≤–∞–π—Ç–µ –∞–∫—Ç–∏–≤–Ω—ã–µ —Å–∏–≥–Ω–∞–ª—ã, –∏—Å—Ç–æ—Ä–∏—é –∏ —É–ø—Ä–∞–≤–ª—è–π—Ç–µ —Ä–µ–≥–∏–æ–Ω–∞–º–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π.\n–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ –Ω–∏–∂–µ.",
    },
    "ALERTS_BTN_ACTIVE": {
        "uk": "üö® –ê–∫—Ç–∏–≤–Ω—ñ —Å–∏–≥–Ω–∞–ª–∏",
        "en": "üö® Live alerts",
        "de": "üö® Live-Alarme",
        "pl": "üö® Aktywne sygna≈Çy",
        "ru": "üö® –ê–∫—Ç–∏–≤–Ω—ã–µ —Å–∏–≥–Ω–∞–ª—ã",
    },
    "ALERTS_BTN_OVERVIEW": {
        "uk": "üó∫Ô∏è –ö–∞—Ä—Ç–∞ –æ–±–ª–∞—Å—Ç–µ–π",
        "en": "üó∫Ô∏è Oblast map",
        "de": "üó∫Ô∏è Oblast-Karte",
        "pl": "üó∫Ô∏è Mapa obwod√≥w",
        "ru": "üó∫Ô∏è –ö–∞—Ä—Ç–∞ –æ–±–ª–∞—Å—Ç–µ–π",
    },
    "ALERTS_BTN_HISTORY": {
        "uk": "üïì –ñ—É—Ä–Ω–∞–ª —Ç—Ä–∏–≤–æ–≥",
        "en": "üïì Alert log",
        "de": "üïì Alarmprotokoll",
        "pl": "üïì Dziennik alarm√≥w",
        "ru": "üïì –ñ—É—Ä–Ω–∞–ª —Ç—Ä–µ–≤–æ–≥",
    },
    "ALERTS_BTN_SUBSCRIPTIONS": {
        "uk": "üéõÔ∏è –ú–æ—ó –æ–±–ª–∞—Å—Ç—ñ",
        "en": "üéõÔ∏è My oblasts",
        "de": "üéõÔ∏è Meine Oblaste",
        "pl": "üéõÔ∏è Moje obwody",
        "ru": "üéõÔ∏è –ú–æ–∏ –æ–±–ª–∞—Å—Ç–∏",
    },
    "ALERTS_ACTIVE_HEADER": {
        "uk": "üö®–ê–∫—Ç–∏–≤–Ω—ñ —Å–∏–≥–Ω–∞–ª–∏({count})",
        "en": "üö®Active alerts({count})",
        "de": "üö®Aktive Alarme({count})",
        "pl": "üö®Aktywne alarmy({count})",
        "ru": "üö®–ê–∫—Ç–∏–≤–Ω—ã–µ —Å–∏–≥–Ω–∞–ª—ã({count})",
    },
    "ALERTS_ACTIVE_DIVIDER": {
        "uk": "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ",
        "en": "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ",
        "de": "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ",
        "pl": "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ",
        "ru": "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ",
    },
    "ALERTS_ACTIVE_SUMMARY_TOTAL": {
        "uk": "üìç –ê–∫—Ç–∏–≤–Ω—ñ —Ç—Ä–∏–≤–æ–≥–∏: {count}",
        "en": "üìç Active alerts: {count}",
        "de": "üìç Aktive Alarme: {count}",
        "pl": "üìç Aktywne alarmy: {count}",
        "ru": "üìç –ê–∫—Ç–∏–≤–Ω—ã–µ —Ç—Ä–µ–≤–æ–≥–∏: {count}",
    },
    "ALERTS_ACTIVE_SUMMARY_USER": {
        "uk": "üë§ –í–∞—à—ñ –≤–∏–±—Ä–∞–Ω—ñ –æ–±–ª–∞—Å—Ç—ñ ‚Äî –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ñ –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è —Å–ø–æ–≤—ñ—â–µ–Ω—å",
        "en": "üë§ Your selected oblasts ‚Äî personal alert preferences",
        "de": "üë§ Ihre ausgew√§hlten Oblaste ‚Äì pers√∂nliche Alarm-Einstellungen",
        "pl": "üë§ Twoje wybrane obwody ‚Äî osobiste ustawienia alert√≥w",
        "ru": "üë§ –í–∞—à–∏ –≤—ã–±—Ä–∞–Ω–Ω—ã–µ –æ–±–ª–∞—Å—Ç–∏ ‚Äî –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –æ–ø–æ–≤–µ—â–µ–Ω–∏–π",
    },
    "ALERTS_ACTIVE_SUMMARY_PROJECT": {
        "uk": "üèó –ü—Ä–∏–≤‚Äô—è–∑–∞–Ω–æ –¥–æ –æ–±‚Äô—î–∫—Ç–∞ ‚Äî –æ–±–ª–∞—Å—Ç—ñ, –≤–∏–∑–Ω–∞—á–µ–Ω—ñ –∞–¥–º—ñ–Ω—ñ—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º",
        "en": "üèó Project scope ‚Äî oblasts defined by the administrator",
        "de": "üèó Projektbezug ‚Äì Oblaste, die vom Administrator festgelegt wurden",
        "pl": "üèó PowiƒÖzano z obiektem ‚Äî obwody okre≈õlone przez administratora",
        "ru": "üèó –ü—Ä–∏–≤—è–∑–∞–Ω–æ –∫ –æ–±—ä–µ–∫—Ç—É ‚Äî –æ–±–ª–∞—Å—Ç–∏, –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω—ã–µ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º",
    },
    "ALERTS_HISTORY_HEADER": {
        "uk": "üìú <b>–Ü—Å—Ç–æ—Ä—ñ—è —Ç—Ä–∏–≤–æ–≥</b> ({count})",
        "en": "üìú <b>Alert history</b> ({count})",
        "de": "üìú <b>Alarmverlauf</b> ({count})",
        "pl": "üìú <b>Historia alarm√≥w</b> ({count})",
        "ru": "üìú <b>–ò—Å—Ç–æ—Ä–∏—è —Ç—Ä–µ–≤–æ–≥</b> ({count})",
    },
    "ALERTS_OVERVIEW_HEADER": {
        "uk": "üó∫Ô∏è –°—Ç–∞—Ç—É—Å –æ–±–ª–∞—Å—Ç–µ–π –£–∫—Ä–∞—ó–Ω–∏\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n–ü–µ—Ä–µ–≤—ñ—Ä—Ç–µ, –¥–µ –∑–∞—Ä–∞–∑ –ª—É–Ω–∞—î —Ç—Ä–∏–≤–æ–≥–∞.",
        "en": "üó∫Ô∏è Status of Ukraine's oblasts\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nSee where alerts are sounding right now.",
        "de": "üó∫Ô∏è Status der Oblaste der Ukraine\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nPr√ºfen Sie, wo gerade Alarm ausgel√∂st wird.",
        "pl": "üó∫Ô∏è Status obwod√≥w Ukrainy\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nSprawd≈∫, gdzie trwa alarm.",
        "ru": "üó∫Ô∏è –°—Ç–∞—Ç—É—Å –æ–±–ª–∞—Å—Ç–µ–π –£–∫—Ä–∞–∏–Ω—ã\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n–ü—Ä–æ–≤–µ—Ä—è–π—Ç–µ, –≥–¥–µ —Å–µ–π—á–∞—Å –∑–≤—É—á–∏—Ç —Ç—Ä–µ–≤–æ–≥–∞.",
    },
    "ALERTS_OVERVIEW_UPDATED": {
        "uk": "üîÑ –û–Ω–æ–≤–ª–µ–Ω–æ: {time}",
        "en": "üîÑ Updated: {time}",
        "de": "üîÑ Aktualisiert: {time}",
        "pl": "üîÑ Zaktualizowano: {time}",
        "ru": "üîÑ –û–±–Ω–æ–≤–ª–µ–Ω–æ: {time}",
    },
    "ALERTS_OVERVIEW_GUIDE": {
        "uk": "‚ÑπÔ∏è –Ü–Ω—Å—Ç—Ä—É–∫—Ü—ñ—è:\nüü¢ –ß–∞—Å –ø–æ–∫–∞–∑—É—î –≤—ñ–¥–±—ñ–π —Ç—Ä–∏–≤–æ–≥–∏.\nüî¥ –ß–∞—Å –ø–æ–∫–∞–∑—É—î –ø–æ—á–∞—Ç–æ–∫ —Ç—Ä–∏–≤–æ–≥–∏.",
        "en": "‚ÑπÔ∏è Guide:\nüü¢ Time marks when the alert ended.\nüî¥ Time marks when the alert began.",
        "de": "‚ÑπÔ∏è Hinweis:\nüü¢ Die Uhrzeit zeigt das Ende des Alarms.\nüî¥ Die Uhrzeit zeigt den Beginn des Alarms.",
        "pl": "‚ÑπÔ∏è Instrukcja:\nüü¢ Czas oznacza odwo≈Çanie alarmu.\nüî¥ Czas oznacza poczƒÖtek alarmu.",
        "ru": "‚ÑπÔ∏è –ò–Ω—Å—Ç—Ä—É–∫—Ü–∏—è:\nüü¢ –í—Ä–µ–º—è = –æ—Ç–±–æ–π —Ç—Ä–µ–≤–æ–≥–∏\nüî¥ –í—Ä–µ–º—è = –Ω–∞—á–∞–ª–æ —Ç—Ä–µ–≤–æ–≥–∏",
    },
    "ALERTS_OVERVIEW_ACTIVE": {
        "uk": "üî¥ {region} ‚Äî —Ç—Ä–∏–≤–æ–≥–∞ –∑ {start}",
        "en": "üî¥ {region} ‚Äî alert since {start}",
        "de": "üî¥ {region} ‚Äî Alarm seit {start}",
        "pl": "üî¥ {region} ‚Äî alarm od {start}",
        "ru": "üî¥ {region} ‚Äî —Ç—Ä–µ–≤–æ–≥–∞ —Å {start}",
    },
    "ALERTS_OVERVIEW_ACTIVE_UNKNOWN": {
        "uk": "üî¥ {region} ‚Äî —Ç—Ä–∏–≤–æ–≥–∞ (—á–∞—Å —É—Ç–æ—á–Ω—é—î—Ç—å—Å—è)",
        "en": "üî¥ {region} ‚Äî alert (start time pending)",
        "de": "üî¥ {region} ‚Äî Alarm (Startzeit wird ermittelt)",
        "pl": "üî¥ {region} ‚Äî alarm (czas ustalany)",
        "ru": "üî¥ {region} ‚Äî —Ç—Ä–µ–≤–æ–≥–∞ (–≤—Ä–µ–º—è —É—Ç–æ—á–Ω—è–µ—Ç—Å—è)",
    },
    "ALERTS_OVERVIEW_CALM": {
        "uk": "üü¢ {region} ‚Äî –≤—ñ–¥–±—ñ–π —Ç—Ä–∏–≤–æ–≥–∏",
        "en": "üü¢ {region} ‚Äî alert cleared",
        "de": "üü¢ {region} ‚Äî Alarm aufgehoben",
        "pl": "üü¢ {region} ‚Äî alarm odwo≈Ç–∞–Ω–æ",
        "ru": "üü¢ {region} ‚Äî –æ—Ç–±–æ–π —Ç—Ä–µ–≤–æ–≥–∏",
    },
    "ALERTS_NO_ACTIVE": {
        "uk": "‚úÖ –ó–∞—Ä–∞–∑ –Ω–µ–º–∞—î –∞–∫—Ç–∏–≤–Ω–∏—Ö —Ç—Ä–∏–≤–æ–≥ –¥–ª—è –≤–∏–±—Ä–∞–Ω–∏—Ö –æ–±–ª–∞—Å—Ç–µ–π.",
        "en": "‚úÖ There are no active alerts for your selected regions right now.",
        "de": "‚úÖ F√ºr die ausgew√§hlten Regionen gibt es derzeit keine aktiven Alarme.",
        "pl": "‚úÖ Brak aktywnych alarm√≥w dla wybranych region√≥w.",
        "ru": "‚úÖ –î–ª—è –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö —Ä–µ–≥–∏–æ–Ω–æ–≤ —Å–µ–π—á–∞—Å –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö —Ç—Ä–µ–≤–æ–≥.",
    },
    "ALERTS_NO_HISTORY": {
        "uk": "‚ÑπÔ∏è –ü–æ–∫–∏ —â–æ –Ω–µ–º–∞—î –∑–±–µ—Ä–µ–∂–µ–Ω–æ—ó —ñ—Å—Ç–æ—Ä—ñ—ó –¥–ª—è —Ü–∏—Ö –æ–±–ª–∞—Å—Ç–µ–π.",
        "en": "‚ÑπÔ∏è There is no saved history for these regions yet.",
        "de": "‚ÑπÔ∏è F√ºr diese Regionen gibt es noch keine gespeicherte Historie.",
        "pl": "‚ÑπÔ∏è Brak zapisanej historii dla tych region√≥w.",
        "ru": "‚ÑπÔ∏è –ü–æ–∫–∞ –Ω–µ—Ç —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω–æ–π –∏—Å—Ç–æ—Ä–∏–∏ –¥–ª—è —ç—Ç–∏—Ö —Ä–µ–≥–∏–æ–Ω–æ–≤.",
    },
    "ALERTS_NO_REGIONS": {
        "uk": "‚ö†Ô∏è –°–ø–µ—Ä—à—É –æ–±–µ—Ä—ñ—Ç—å —Ö–æ—á–∞ –± –æ–¥–Ω—É –æ–±–ª–∞—Å—Ç—å –¥–ª—è —Å–ø–æ–≤—ñ—â–µ–Ω—å.",
        "en": "‚ö†Ô∏è Please select at least one region to receive alerts.",
        "de": "‚ö†Ô∏è W√§hlen Sie zun√§chst mindestens eine Region f√ºr Benachrichtigungen aus.",
        "pl": "‚ö†Ô∏è Wybierz co najmniej jeden region, aby otrzymywaƒá alerty.",
        "ru": "‚ö†Ô∏è –°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏—Ç–µ —Ö–æ—Ç—è –±—ã –æ–¥–∏–Ω —Ä–µ–≥–∏–æ–Ω –¥–ª—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π.",
    },
    "ALERTS_SUBS_HEADER": {
        "uk": "üß≠ –û–±–ª–∞—Å—Ç—ñ —Å–ø–æ–≤—ñ—â–µ–Ω—å",
        "en": "üß≠ Alert oblasts",
        "de": "üß≠ Alarmbezirke",
        "pl": "üß≠ Obwody powiadomie≈Ñ",
        "ru": "üß≠ –û–±–ª–∞—Å—Ç–∏ —Ç—Ä–µ–≤–æ–≥",
    },
    "ALERTS_SUBS_DIVIDER": {
        "uk": "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ",
        "en": "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ",
        "de": "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ",
        "pl": "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ",
        "ru": "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ",
    },
    "ALERTS_SUBS_NOTE_HAS_PROJECT": {
        "uk": "–û—Å–Ω–æ–≤–Ω–∞ –æ–±–ª–∞—Å—Ç—å –ø—Ä–æ—î–∫—Ç—É: {region}.  \n–Ü–Ω—à—ñ –æ–±–ª–∞—Å—Ç—ñ –º–æ–∂–Ω–∞ –æ–±—Ä–∞—Ç–∏ –≤—Ä—É—á–Ω—É.  ",
        "en": "Project oblast: {region}.  \nYou can add other oblasts manually.  ",
        "de": "Projektbezirk: {region}.  \nWeitere Bezirke lassen sich manuell w√§hlen.  ",
        "pl": "Obw√≥d projektu: {region}.  \nPozosta≈Çe obwody mo≈ºesz wybraƒá rƒôcznie.  ",
        "ru": "–û–±–ª–∞—Å—Ç—å –ø—Ä–æ–µ–∫—Ç–∞: {region}.  \n–î—Ä—É–≥–∏–µ –æ–±–ª–∞—Å—Ç–∏ –º–æ–∂–Ω–æ –≤—ã–±—Ä–∞—Ç—å –≤—Ä—É—á–Ω—É—é.  ",
    },
    "ALERTS_SUBS_NOTE_NO_PROJECT": {
        "uk": "–ù–∞—Ä–∞–∑—ñ –∞–∫—Ç–∏–≤–Ω–∏–π –ø—Ä–æ—î–∫—Ç –Ω–µ –≤–∏–±—Ä–∞–Ω–æ.  \n–û–±–ª–∞—Å—Ç—ñ –º–æ–∂–Ω–∞ –æ–±—Ä–∞—Ç–∏ –≤—Ä—É—á–Ω—É.  ",
        "en": "No active project is selected.  \nChoose oblasts manually.  ",
        "de": "Derzeit ist kein Projekt aktiv.  \nBezirke lassen sich manuell w√§hlen.  ",
        "pl": "≈ªaden projekt nie jest aktywny.  \nObwody mo≈ºesz wybraƒá rƒôcznie.  ",
        "ru": "–ê–∫—Ç–∏–≤–Ω—ã–π –ø—Ä–æ–µ–∫—Ç –ø–æ–∫–∞ –Ω–µ –≤—ã–±—Ä–∞–Ω.  \n–û–±–ª–∞—Å—Ç–∏ –º–æ–∂–Ω–æ –≤—ã–±—Ä–∞—Ç—å –≤—Ä—É—á–Ω—É—é.  ",
    },
    "ALERTS_SUBS_LIST_TITLE": {
        "uk": "üìç –ê–∫—Ç–∏–≤–Ω—ñ –æ–±–ª–∞—Å—Ç—ñ:",
        "en": "üìç Active oblasts:",
        "de": "üìç Aktive Bezirke:",
        "pl": "üìç Aktywne obwody:",
        "ru": "üìç –ê–∫—Ç–∏–≤–Ω—ã–µ –æ–±–ª–∞—Å—Ç–∏:",
    },
    "ALERTS_SUBS_LIST_EMPTY": {
        "uk": "‚Äî",
        "en": "‚Äî",
        "de": "‚Äî",
        "pl": "‚Äî",
        "ru": "‚Äî",
    },
    "ALERTS_SUBS_MANAGE": {
        "uk": "‚ûï‚ûñ –ö–µ—Ä—É–≤–∞–Ω–Ω—è —Å–ø–∏—Å–∫–æ–º —á–µ—Ä–µ–∑ –∫–Ω–æ–ø–∫–∏",
        "en": "‚ûï‚ûñ Manage the list with the buttons",
        "de": "‚ûï‚ûñ Liste √ºber die Schaltfl√§chen verwalten",
        "pl": "‚ûï‚ûñ ZarzƒÖdzaj listƒÖ przy u≈ºyciu przycisk√≥w",
        "ru": "‚ûï‚ûñ –£–ø—Ä–∞–≤–ª—è–π—Ç–µ —Å–ø–∏—Å–∫–æ–º —Å –ø–æ–º–æ—â—å—é –∫–Ω–æ–ø–æ–∫",
    },
    "ALERTS_SUBS_SELECTED": {
        "uk": "–ê–∫—Ç–∏–≤–Ω—ñ –æ–±–ª–∞—Å—Ç—ñ: {items}",
        "en": "Selected oblasts: {items}",
        "de": "Aktive Bezirke: {items}",
        "pl": "Aktywne obwody: {items}",
        "ru": "–í—ã–±—Ä–∞–Ω–Ω—ã–µ –æ–±–ª–∞—Å—Ç–∏: {items}",
    },
    "ALERTS_SUBS_ADDED": {
        "uk": "‚úÖ –î–æ–¥–∞–Ω–æ –æ–±–ª–∞—Å—Ç—å: {region}",
        "en": "‚úÖ Region added: {region}",
        "de": "‚úÖ Region hinzugef√ºgt: {region}",
        "pl": "‚úÖ Dodano region: {region}",
        "ru": "‚úÖ –î–æ–±–∞–≤–ª–µ–Ω —Ä–µ–≥–∏–æ–Ω: {region}",
    },
    "ALERTS_SUBS_REMOVED": {
        "uk": "‚ûñ –í–∏–¥–∞–ª–µ–Ω–æ –æ–±–ª–∞—Å—Ç—å: {region}",
        "en": "‚ûñ Region removed: {region}",
        "de": "‚ûñ Region entfernt: {region}",
        "pl": "‚ûñ Usuniƒôto region: {region}",
        "ru": "‚ûñ –†–µ–≥–∏–æ–Ω —É–¥–∞–ª—ë–Ω: {region}",
    },
    "ALERTS_SUBS_LOCKED": {
        "uk": "‚ÑπÔ∏è –¶—é –æ–±–ª–∞—Å—Ç—å –Ω–µ–º–æ–∂–ª–∏–≤–æ –≤–∏–º–∫–Ω—É—Ç–∏.",
        "en": "‚ÑπÔ∏è This region cannot be disabled.",
        "de": "‚ÑπÔ∏è Diese Region kann nicht deaktiviert werden.",
        "pl": "‚ÑπÔ∏è Tego regionu nie mo≈ºna wy≈ÇƒÖczyƒá.",
        "ru": "‚ÑπÔ∏è –≠—Ç–æ—Ç —Ä–µ–≥–∏–æ–Ω –Ω–µ–ª—å–∑—è –æ—Ç–∫–ª—é—á–∏—Ç—å.",
    },
    "ALERTS_SUBS_PAGE": {
        "uk": "üìÑ –°—Ç–æ—Ä—ñ–Ω–∫–∞ {current}/{total}",
        "en": "üìÑ Page {current}/{total}",
        "de": "üìÑ Seite {current}/{total}",
        "pl": "üìÑ Strona {current}/{total}",
        "ru": "üìÑ –°—Ç—Ä–∞–Ω–∏—Ü–∞ {current}/{total}",
    },
    "ALERTS_BACK_TO_MENU": {
        "uk": "‚¨ÖÔ∏è –ú–µ–Ω—é —Ç—Ä–∏–≤–æ–≥",
        "en": "‚¨ÖÔ∏è Alerts menu",
        "de": "‚¨ÖÔ∏è Alarm-Men√º",
        "pl": "‚¨ÖÔ∏è Menu alarm√≥w",
        "ru": "‚¨ÖÔ∏è –ú–µ–Ω—é —Ç—Ä–µ–≤–æ–≥",
    },
    "ALERTS_CLOSE_CARD": {
        "uk": "‚úñÔ∏è –ó–∞–∫—Ä–∏—Ç–∏",
        "en": "‚úñÔ∏è Close",
        "de": "‚úñÔ∏è Schlie√üen",
        "pl": "‚úñÔ∏è ZamknƒÖƒá",
        "ru": "‚úñÔ∏è –ó–∞–∫—Ä—ã—Ç—å",
    },
    "ALERTS_PUSH_OPEN": {
        "uk": "üîé –í—ñ–¥–∫—Ä–∏—Ç–∏ –¥–µ—Ç–∞–ª—å–Ω–æ",
        "en": "üîé Open details",
        "de": "üîé Details anzeigen",
        "pl": "üîé Otw√≥rz szczeg√≥≈Çy",
        "ru": "üîé –û—Ç–∫—Ä—ã—Ç—å –¥–µ—Ç–∞–ª—å–Ω–æ",
    },
    "ALERTS_PUSH_COLLAPSE": {
        "uk": "‚¨ÜÔ∏è –ó–≥–æ—Ä–Ω—É—Ç–∏",
        "en": "‚¨ÜÔ∏è Collapse",
        "de": "‚¨ÜÔ∏è Einklappen",
        "pl": "‚¨ÜÔ∏è Zwi≈Ñ",
        "ru": "‚¨ÜÔ∏è –°–≤–µ—Ä–Ω—É—Ç—å",
    },
    "ALERTS_PUSH_DELETE": {
        "uk": "üóë –í–∏–¥–∞–ª–∏—Ç–∏ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è",
        "en": "üóë Delete message",
        "de": "üóë Nachricht l√∂schen",
        "pl": "üóë Usu≈Ñ wiadomo≈õƒá",
        "ru": "üóë –£–¥–∞–ª–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ",
    },
    "ALERTS_PUSH_HEADER_ALERT": {
        "uk": "üö® –¢–†–ò–í–û–ì–ê | {region}",
        "en": "üö® ALERT | {region}",
        "de": "üö® ALARM | {region}",
        "pl": "üö® ALARM | {region}",
        "ru": "üö® –¢–†–ï–í–û–ì–ê | {region}",
    },
    "ALERTS_PUSH_HEADER_STANDDOWN": {
        "uk": "üü¢ –í–Ü–î–ë–Ü–ô | {region}",
        "en": "üü¢ CLEAR | {region}",
        "de": "üü¢ ENTWARNUNG | {region}",
        "pl": "üü¢ ODWO≈ÅANIE | {region}",
        "ru": "üü¢ –û–¢–ë–û–ô | {region}",
    },
    "ALERTS_PUSH_SUMMARY_RUNNING": {
        "uk": "{icon} {type} ‚Ä¢ üïí {start} ‚Üí {progress}",
        "en": "{icon} {type} ‚Ä¢ üïí {start} ‚Üí {progress}",
        "de": "{icon} {type} ‚Ä¢ üïí {start} ‚Üí {progress}",
        "pl": "{icon} {type} ‚Ä¢ üïí {start} ‚Üí {progress}",
        "ru": "{icon} {type} ‚Ä¢ üïí {start} ‚Üí {progress}",
    },
    "ALERTS_PUSH_SUMMARY_ENDED": {
        "uk": "{icon} {type} ‚Ä¢ üïí {start} ‚Üí ‚úÖ {ended}",
        "en": "{icon} {type} ‚Ä¢ üïí {start} ‚Üí ‚úÖ {ended}",
        "de": "{icon} {type} ‚Ä¢ üïí {start} ‚Üí ‚úÖ {ended}",
        "pl": "{icon} {type} ‚Ä¢ üïí {start} ‚Üí ‚úÖ {ended}",
        "ru": "{icon} {type} ‚Ä¢ üïí {start} ‚Üí ‚úÖ {ended}",
    },
    "ALERTS_PUSH_SUMMARY_LEAD_ALERT": {
        "uk": "üö® –ö–æ—Ä–æ—Ç–∫–µ —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è –ø—Ä–æ —Ç—Ä–∏–≤–æ–≥—É",
        "en": "üö® Quick alert notification",
        "de": "üö® Kurze Alarmbenachrichtigung",
        "pl": "üö® Kr√≥tkie powiadomienie o alarmie",
        "ru": "üö® –ö–æ—Ä–æ—Ç–∫–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ —Ç—Ä–µ–≤–æ–≥–µ",
    },
    "ALERTS_PUSH_SUMMARY_LEAD_STANDDOWN": {
        "uk": "",
        "en": "",
        "de": "",
        "pl": "",
        "ru": "",
    },
    "ALERTS_DURATION_RUNNING": {
        "uk": "—Ç—Ä–∏–≤–∞—î {duration}",
        "en": "ongoing for {duration}",
        "de": "l√§uft seit {duration}",
        "pl": "trwa {duration}",
        "ru": "–∏–¥—ë—Ç {duration}",
    },
    "ALERTS_DURATION_COMPLETED": {
        "uk": "—Ç—Ä–∏–≤–∞–ª–∞ {duration}",
        "en": "lasted {duration}",
        "de": "dauerte {duration}",
        "pl": "trwa≈Ça {duration}",
        "ru": "–¥–ª–∏–ª–∞—Å—å {duration}",
    },
    "ALERTS_DURATION_LESS_MINUTE": {
        "uk": "–º–µ–Ω—à–µ —Ö–≤–∏–ª–∏–Ω–∏",
        "en": "less than a minute",
        "de": "unter einer Minute",
        "pl": "mniej ni≈º minutƒô",
        "ru": "–º–µ–Ω–µ–µ –º–∏–Ω—É—Ç—ã",
    },
    "ALERTS_PUSH_DETAIL_TITLE_ALERT": {
        "uk": "üö® –¢–†–ò–í–û–ì–ê ‚Äî {region}",
        "en": "üö® ALERT ‚Äî {region}",
        "de": "üö® ALARM ‚Äî {region}",
        "pl": "üö® ALARM ‚Äî {region}",
        "ru": "üö® –¢–†–ï–í–û–ì–ê ‚Äî {region}",
    },
    "ALERTS_PUSH_DETAIL_TITLE_STANDDOWN": {
        "uk": "üü¢ –í–Ü–î–ë–Ü–ô –¢–†–ò–í–û–ì–ò ‚Äî {region}",
        "en": "üü¢ ALERT CLEARED ‚Äî {region}",
        "de": "üü¢ ENTWARNUNG ‚Äî {region}",
        "pl": "üü¢ ALARM ODWO≈ÅANY ‚Äî {region}",
        "ru": "üü¢ –û–¢–ë–û–ô –¢–†–ï–í–û–ì–ò ‚Äî {region}",
    },
    "ALERTS_PUSH_DETAIL_TYPE": {
        "uk": "{icon} –¢–∏–ø –∑–∞–≥—Ä–æ–∑–∏: {value}",
        "en": "{icon} Threat type: {value}",
        "de": "{icon} Bedrohungsart: {value}",
        "pl": "{icon} Rodzaj zagro≈ºenia: {value}",
        "ru": "{icon} –¢–∏–ø —É–≥—Ä–æ–∑—ã: {value}",
    },
    "ALERTS_PUSH_DETAIL_START": {
        "uk": "üïí –ü–æ—á–∞—Ç–æ–∫: {date} ‚Ä¢ {time}",
        "en": "üïí Start: {date} ‚Ä¢ {time}",
        "de": "üïí Beginn: {date} ‚Ä¢ {time}",
        "pl": "üïí PoczƒÖtek: {date} ‚Ä¢ {time}",
        "ru": "üïí –ù–∞—á–∞–ª–æ: {date} ‚Ä¢ {time}",
    },
    "ALERTS_PUSH_DETAIL_END_STANDDOWN": {
        "uk": "‚úÖ –í—ñ–¥–±—ñ–π: {date} ‚Ä¢ {time}",
        "en": "‚úÖ Cleared: {date} ‚Ä¢ {time}",
        "de": "‚úÖ Entwarnung: {date} ‚Ä¢ {time}",
        "pl": "‚úÖ Odwo≈Çanie: {date} ‚Ä¢ {time}",
        "ru": "‚úÖ –û—Ç–±–æ–π: {date} ‚Ä¢ {time}",
    },
    "ALERTS_PUSH_DETAIL_DURATION": {
        "uk": "‚è± –¢—Ä–∏–≤–∞–ª—ñ—Å—Ç—å: {duration}",
        "en": "‚è± Duration: {duration}",
        "de": "‚è± Dauer: {duration}",
        "pl": "‚è± Czas trwania: {duration}",
        "ru": "‚è± –î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å: {duration}",
    },
    "ALERTS_PUSH_DETAIL_STATS_HEADER": {
        "uk": "üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –Ω–∞ –∑–∞—Ä–∞–∑",
        "en": "üìä Current statistics",
        "de": "üìä Aktuelle Statistik",
        "pl": "üìä Aktualne statystyki",
        "ru": "üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –Ω–∞ —Å–µ–π—á–∞—Å",
    },
    "ALERTS_PUSH_DETAIL_STATS_COUNTRY": {
        "uk": "‚Ä¢ üá∫üá¶ –ü–æ –£–∫—Ä–∞—ó–Ω—ñ: {value}",
        "en": "‚Ä¢ üá∫üá¶ Across Ukraine: {value}",
        "de": "‚Ä¢ üá∫üá¶ In der Ukraine: {value}",
        "pl": "‚Ä¢ üá∫üá¶ W Ukrainie: {value}",
        "ru": "‚Ä¢ üá∫üá¶ –ü–æ –£–∫—Ä–∞–∏–Ω–µ: {value}",
    },
    "ALERTS_PUSH_DETAIL_STATS_REGION_ACTIVE": {
        "uk": "‚Ä¢ üèô –í –æ–±–ª–∞—Å—Ç—ñ: {value}",
        "en": "‚Ä¢ üèô In the oblast: {value}",
        "de": "‚Ä¢ üèô In der Oblast: {value}",
        "pl": "‚Ä¢ üèô W obwodzie: {value}",
        "ru": "‚Ä¢ üèô –í –æ–±–ª–∞—Å—Ç–∏: {value}",
    },
    "ALERTS_PUSH_DETAIL_STATS_REGION_CLEAR": {
        "uk": "‚Ä¢ üèô –í –æ–±–ª–∞—Å—Ç—ñ: –∑–∞–≤–µ—Ä—à–µ–Ω–∞",
        "en": "‚Ä¢ üèô In the oblast: cleared",
        "de": "‚Ä¢ üèô In der Oblast: beendet",
        "pl": "‚Ä¢ üèô W obwodzie: zako≈Ñczona",
        "ru": "‚Ä¢ üèô –í –æ–±–ª–∞—Å—Ç–∏: –∑–∞–≤–µ—Ä—à–µ–Ω–∞",
    },
    "ALERTS_PUSH_DETAIL_RECOMMENDATIONS_HEADER": {
        "uk": "‚ö†Ô∏è –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü—ñ—ó",
        "en": "‚ö†Ô∏è Recommendations",
        "de": "‚ö†Ô∏è Empfehlungen",
        "pl": "‚ö†Ô∏è Zalecenia",
        "ru": "‚ö†Ô∏è –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏",
    },
    "ALERTS_PUSH_DETAIL_STANDDOWN_HEADER": {
        "uk": "‚úÖ –°–∏—Ç—É–∞—Ü—ñ—é —Å—Ç–∞–±—ñ–ª—ñ–∑–æ–≤–∞–Ω–æ",
        "en": "‚úÖ Situation stabilised",
        "de": "‚úÖ Lage stabilisiert",
        "pl": "‚úÖ Sytuacja ustabilizowana",
        "ru": "‚úÖ –°–∏—Ç—É–∞—Ü–∏—è —Å—Ç–∞–±–∏–ª–∏–∑–∏—Ä–æ–≤–∞–ª–∞—Å—å",
    },
    "ALERTS_PUSH_DETAIL_STANDDOWN_NOTE": {
        "uk": "–ë—É–¥—å—Ç–µ —É–≤–∞–∂–Ω—ñ —Ç–∞ —Å—Ç–µ–∂—Ç–µ –∑–∞ –Ω–æ–≤–∏–º–∏ —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è–º–∏",
        "en": "Stay cautious and watch for new notifications",
        "de": "Bleiben Sie aufmerksam und verfolgen Sie neue Meldungen",
        "pl": "BƒÖd≈∫ ostro≈ºny i ≈õled≈∫ nowe powiadomienia",
        "ru": "–ë—É–¥—å—Ç–µ –æ—Å—Ç–æ—Ä–æ–∂–Ω—ã –∏ —Å–ª–µ–¥–∏—Ç–µ –∑–∞ –Ω–æ–≤—ã–º–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è–º–∏",
    },
    "ALERTS_PUSH_DETAIL_FOOTER": {
        "uk": "‚úÖ –ë–µ—Ä–µ–∂—ñ—Ç—å —Å–µ–±–µ!",
        "en": "‚úÖ Stay safe!",
        "de": "‚úÖ Bleiben Sie sicher!",
        "pl": "‚úÖ Dbajcie o siebie!",
        "ru": "‚úÖ –ë–µ—Ä–µ–≥–∏—Ç–µ —Å–µ–±—è!",
    },
    "ALERTS_NAV_PREV": {
        "uk": "‚óÄÔ∏è –ü–æ–ø–µ—Ä–µ–¥–Ω—è",
        "en": "‚óÄÔ∏è Previous",
        "de": "‚óÄÔ∏è Zur√ºck",
        "pl": "‚óÄÔ∏è Poprzednia",
        "ru": "‚óÄÔ∏è –ù–∞–∑–∞–¥",
    },
    "ALERTS_NAV_NEXT": {
        "uk": "‚ñ∂Ô∏è –ù–∞—Å—Ç—É–ø–Ω–∞",
        "en": "‚ñ∂Ô∏è Next",
        "de": "‚ñ∂Ô∏è Weiter",
        "pl": "‚ñ∂Ô∏è Nastƒôpna",
        "ru": "‚ñ∂Ô∏è –î–∞–ª–µ–µ",
    },
    "ALERTS_CARD_INDEX": {
        "uk": "{index} —ñ–∑ {total}",
        "en": "{index} of {total}",
        "de": "{index} von {total}",
        "pl": "{index} z {total}",
        "ru": "{index} –∏–∑ {total}",
    },
    "BTN_SETTINGS": {
        "uk": "‚öôÔ∏è –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è",
        "en": "‚öôÔ∏è Settings",
        "de": "‚öôÔ∏è Einstellungen",
        "pl": "‚öôÔ∏è Ustawienia",
        "ru": "‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏",
    },
    "BTN_NOVA_POSHTA": {
        "uk": "üìÆ –ù–æ–≤–∞ –ø–æ—à—Ç–∞",
        "en": "üìÆ Nova Poshta",
        "de": "üìÆ Nova Poshta",
        "pl": "üìÆ Nova Poshta",
        "ru": "üìÆ –ù–æ–≤–∞—è –ø–æ—á—Ç–∞",
    },
    "BTN_NP_INTERFACE": {
        "uk": "üìã –Ü–Ω—Ç–µ—Ä—Ñ–µ–π—Å",
        "en": "üìã Overview",
        "de": "üìã √úbersicht",
        "pl": "üìã Interfejs",
        "ru": "üìã –ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å",
    },
    "BTN_NP_SEARCH": {
        "uk": "üîç –ü–æ—à—É–∫ –∑–∞ –¢–¢–ù",
        "en": "üîç Search by TTN",
        "de": "üîç Suche per TTN",
        "pl": "üîç Szukaj po TTN",
        "ru": "üîç –ò—Å–∫–∞—Ç—å –ø–æ –¢–¢–ù",
    },
    "BTN_NP_HISTORY": {
        "uk": "üïì –Ü—Å—Ç–æ—Ä—ñ—è –ø–æ—à—É–∫—É",
        "en": "üïì Search history",
        "de": "üïì Suchverlauf",
        "pl": "üïì Historia wyszukiwa≈Ñ",
        "ru": "üïì –ò—Å—Ç–æ—Ä–∏—è –ø–æ–∏—Å–∫–æ–≤",
    },
    "BTN_NP_BOOKMARKS": {
        "uk": "‚≠ê –í—ñ–¥–∑–Ω–∞—á–µ–Ω—ñ",
        "en": "‚≠ê Bookmarked",
        "de": "‚≠ê Markiert",
        "pl": "‚≠ê Oznaczone",
        "ru": "‚≠ê –û—Ç–º–µ—á–µ–Ω–Ω—ã–µ",
    },
    "BTN_NP_ASSIGNED": {
        "uk": "üè¢ –ü–æ—Å–∏–ª–∫–∏ BSG",
        "en": "üè¢ BSG parcels",
        "de": "üè¢ BSG-Sendungen",
        "pl": "üè¢ Przesy≈Ç–∫–∏ BSG",
        "ru": "üè¢ –ü–æ—Å—ã–ª–∫–∏ BSG",
    },
    "BTN_NP_RECEIVED": {
        "uk": "üì• –û—Ç—Ä–∏–º–∞–Ω—ñ –ø–æ—Å–∏–ª–∫–∏ BSG",
        "en": "üì• Received BSG parcels",
        "de": "üì• Erhaltene BSG-Sendungen",
        "pl": "üì• Odebrane przesy≈Çki BSG",
        "ru": "üì• –ü–æ–ª—É—á–µ–Ω–Ω—ã–µ –ø–æ—Å—ã–ª–∫–∏ BSG",
    },
    "BTN_NP_ASSIGN_SEND": {
        "uk": "üì¨ –ó–∞–∫—Ä—ñ–ø–∏—Ç–∏ –¢–¢–ù –∑–∞ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–µ–º",
        "en": "üì¨ Assign TTN to user",
        "de": "üì¨ TTN einem Nutzer zuordnen",
        "pl": "üì¨ Przypisz TTN u≈ºytkownikowi",
        "ru": "üì¨ –ó–∞–∫—Ä–µ–ø–∏—Ç—å –¢–¢–ù –∑–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º",
    },
    "BTN_PROFILE": {
        "uk": "‚ûï –î–æ–ª—É—á–∏—Ç–∏—Å—è",
        "en": "‚ûï Join workspace",
        "de": "‚ûï Beitreten",
        "pl": "‚ûï Do≈ÇƒÖczyƒá",
        "ru": "‚ûï –î–æ–±–∞–≤–∏—Ç—å—Å—è",
    },
    "BTN_PROFILE_EDIT": {
        "uk": "‚úèÔ∏è –†–µ–¥–∞–≥—É–≤–∞—Ç–∏ –ø—Ä–æ—Ñ—ñ–ª—å",
        "en": "‚úèÔ∏è Edit profile",
        "de": "‚úèÔ∏è Profil bearbeiten",
        "pl": "‚úèÔ∏è Edytuj profil",
        "ru": "‚úèÔ∏è –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–æ—Ñ–∏–ª—å",
    },
    "BTN_PROFILE_VIEW_PHOTO": {
        "uk": "üëÅ –ü–µ—Ä–µ–≥–ª—è–Ω—É—Ç–∏ —Ñ–æ—Ç–æ",
        "en": "üëÅ View photo",
        "de": "üëÅ Foto anzeigen",
        "pl": "üëÅ Zobacz zdjƒôcie",
        "ru": "üëÅ –ü—Ä–æ—Å–º–æ—Ç—Ä–µ—Ç—å —Ñ–æ—Ç–æ",
    },
    "BTN_PROFILE_HIDE_PHOTO": {
        "uk": "üìù –ü–æ–≤–µ—Ä–Ω—É—Ç–∏—Å—å –¥–æ —Ç–µ–∫—Å—Ç—É",
        "en": "üìù Back to summary",
        "de": "üìù Zur√ºck zur √úbersicht",
        "pl": "üìù Wr√≥ƒá do podsumowania",
        "ru": "üìù –í–µ—Ä–Ω—É—Ç—å—Å—è –∫ —Ç–µ–∫—Å—Ç—É",
    },
    "BTN_PROFILE_DONE": {
        "uk": "‚úÖ –ì–æ—Ç–æ–≤–æ",
        "en": "‚úÖ Done",
        "de": "‚úÖ Fertig",
        "pl": "‚úÖ Gotowe",
        "ru": "‚úÖ –ì–æ—Ç–æ–≤–æ",
    },
    "BTN_PROFILE_UPDATE_PHOTO": {
        "uk": "üñº –û–Ω–æ–≤–∏—Ç–∏ —Ñ–æ—Ç–æ",
        "en": "üñº Update photo",
        "de": "üñº Foto aktualisieren",
        "pl": "üñº Zaktualizuj zdjƒôcie",
        "ru": "üñº –û–±–Ω–æ–≤–∏—Ç—å —Ñ–æ—Ç–æ",
    },
    "BTN_PROFILE_REMOVE_PHOTO": {
        "uk": "üóë –í–∏–¥–∞–ª–∏—Ç–∏ —Ñ–æ—Ç–æ",
        "en": "üóë Remove photo",
        "de": "üóë Foto l√∂schen",
        "pl": "üóë Usu≈Ñ zdjƒôcie",
        "ru": "üóë –£–¥–∞–ª–∏—Ç—å —Ñ–æ—Ç–æ",
    },
    "BTN_PROFILE_FIELD_LAST": {
        "uk": "1. –ü—Ä—ñ–∑–≤–∏—â–µ",
        "en": "1. Last name",
        "de": "1. Nachname",
        "pl": "1. Nazwisko",
        "ru": "1. –§–∞–º–∏–ª–∏—è",
    },
    "BTN_PROFILE_FIELD_FIRST": {
        "uk": "2. –Ü–º'—è",
        "en": "2. First name",
        "de": "2. Vorname",
        "pl": "2. Imiƒô",
        "ru": "2. –ò–º—è",
    },
    "BTN_PROFILE_FIELD_MIDDLE": {
        "uk": "3. –ü–æ –±–∞—Ç—å–∫–æ–≤—ñ",
        "en": "3. Patronymic",
        "de": "3. Vatersname",
        "pl": "3. Drugie imiƒô",
        "ru": "3. –û—Ç—á–µ—Å—Ç–≤–æ",
    },
    "BTN_PROFILE_FIELD_BIRTHDATE": {
        "uk": "4. –î–∞—Ç–∞ –Ω–∞—Ä–æ–¥–∂–µ–Ω–Ω—è",
        "en": "4. Birth date",
        "de": "4. Geburtsdatum",
        "pl": "4. Data urodzenia",
        "ru": "4. –î–∞—Ç–∞ —Ä–æ–∂–¥–µ–Ω–∏—è",
    },
    "BTN_PROFILE_FIELD_REGION": {
        "uk": "5. –û–±–ª–∞—Å—Ç—å",
        "en": "5. Region",
        "de": "5. Region",
        "pl": "5. Obw√≥d",
        "ru": "5. –û–±–ª–∞—Å—Ç—å",
    },
    "BTN_PROFILE_FIELD_PHONE": {
        "uk": "6. –¢–µ–ª–µ—Ñ–æ–Ω",
        "en": "6. Phone",
        "de": "6. Telefon",
        "pl": "6. Telefon",
        "ru": "6. –¢–µ–ª–µ—Ñ–æ–Ω",
    },
    "BTN_PROFILE_CANCEL": {
        "uk": "‚¨ÖÔ∏è –°–∫–∞—Å—É–≤–∞—Ç–∏",
        "en": "‚¨ÖÔ∏è Cancel",
        "de": "‚¨ÖÔ∏è Abbrechen",
        "pl": "‚¨ÖÔ∏è Anuluj",
        "ru": "‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∏—Ç—å",
    },
    "BTN_BACK_ROOT": {
        "uk": "‚¨ÖÔ∏è –ù–∞ –≥–æ–ª–æ–≤–Ω—É",
        "en": "‚¨ÖÔ∏è Main menu",
        "de": "‚¨ÖÔ∏è Hauptmen√º",
        "pl": "‚¨ÖÔ∏è Menu g≈Ç√≥wne",
        "ru": "‚¨ÖÔ∏è –ù–∞ –≥–ª–∞–≤–Ω—É—é",
    },
    "BTN_PHOTO_TIMELINE": {
        "uk": "üñº –§–æ—Ç–æ—Ö—Ä–æ–Ω–æ–ª–æ–≥—ñ—è",
        "en": "üñº Photo timeline",
        "de": "üñº Fototimeline",
        "pl": "üñº Kronika zdjƒôƒá",
        "ru": "üñº –§–æ—Ç–æ—Ö—Ä–æ–Ω–æ–ª–æ–≥–∏—è",
    },
    "BTN_ADD_RECEIPT": {
        "uk": "üì∑ –î–æ–¥–∞—Ç–∏ —á–µ–∫",
        "en": "üì∑ Add receipt",
        "de": "üì∑ Beleg hinzuf√ºgen",
        "pl": "üì∑ Dodaj paragon",
        "ru": "üì∑ –î–æ–±–∞–≤–∏—Ç—å —á–µ–∫",
    },
    "BTN_MY_STATS": {
        "uk": "üìä –ú–æ—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞",
        "en": "üìä My statistics",
        "de": "üìä Meine Statistik",
        "pl": "üìä Moje statystyki",
        "ru": "üìä –ú–æ—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞",
    },
    "BTN_MY_RECEIPTS": {
        "uk": "üìÅ –ú–æ—ó —á–µ–∫–∏",
        "en": "üìÅ My receipts",
        "de": "üìÅ Meine Belege",
        "pl": "üìÅ Moje paragony",
        "ru": "üìÅ –ú–æ–∏ —á–µ–∫–∏",
    },
    "BTN_RECEIPT_HISTORY": {
        "uk": "üóÇ –Ü—Å—Ç–æ—Ä—ñ—è —á–µ–∫—ñ–≤ —Ç–∞ –≤–∏–ø–ª–∞—Ç",
        "en": "üóÇ Receipt & payout history",
        "de": "üóÇ Beleg- und Auszahlungs¬≠historie",
        "pl": "üóÇ Historia paragon√≥w i wyp≈Çat",
        "ru": "üóÇ –ò—Å—Ç–æ—Ä–∏—è —á–µ–∫–æ–≤ –∏ –≤—ã–ø–ª–∞—Ç",
    },
    "BTN_UPLOAD_PHOTO": {
        "uk": "üì§ –ó–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ —Ñ–æ—Ç–æ",
        "en": "üì§ Upload photos",
        "de": "üì§ Fotos hochladen",
        "pl": "üì§ Wy≈õlij zdjƒôcia",
        "ru": "üì§ –ó–∞–≥—Ä—É–∑–∏—Ç—å —Ñ–æ—Ç–æ",
    },
    "BTN_VIEW_OBJECT_PHOTOS": {
        "uk": "üñº –ü–µ—Ä–µ–≥–ª—è–Ω—É—Ç–∏ —Ñ–æ—Ç–æ –æ–±'—î–∫—Ç–∞",
        "en": "üñº View project photos",
        "de": "üñº Projektfotos ansehen",
        "pl": "üñº Zobacz zdjƒôcia obiektu",
        "ru": "üñº –ü—Ä–æ—Å–º–æ—Ç—Ä–µ—Ç—å —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏ –æ–±—ä–µ–∫—Ç–∞",
    },
    "STATUS_PAID": {
        "uk": "‚úÖ –û–ø–ª–∞—á–µ–Ω–æ",
        "en": "‚úÖ Paid",
        "de": "‚úÖ Bezahlt",
        "pl": "‚úÖ Op≈Çacono",
        "ru": "‚úÖ –û–ø–ª–∞—á–µ–Ω",
    },
    "STATUS_UNPAID": {
        "uk": "‚ùå –ù–µ –æ–ø–ª–∞—á–µ–Ω–æ",
        "en": "‚ùå Unpaid",
        "de": "‚ùå Nicht bezahlt",
        "pl": "‚ùå Nie op≈Çacono",
        "ru": "‚ùå –ù–µ –æ–ø–ª–∞—á–µ–Ω",
    },
    "STATUS_UNKNOWN": {
        "uk": "‚è≥ –ù–µ –≤–∫–∞–∑–∞–Ω–æ",
        "en": "‚è≥ Not specified",
        "de": "‚è≥ Nicht angegeben",
        "pl": "‚è≥ Nie podano",
        "ru": "‚è≥ –ù–µ —É–∫–∞–∑–∞–Ω",
    },
    "START_WELCOME_BACK": {
        "uk": "üëã –†–∞–¥–∏–π –∑–Ω–æ–≤—É –±–∞—á–∏—Ç–∏, {name}!",
        "en": "üëã Welcome back, {name}!",
        "de": "üëã Willkommen zur√ºck, {name}!",
        "pl": "üëã Mi≈Ço Ciƒô zn√≥w widzieƒá, {name}!",
        "ru": "üëã –†–∞–¥ —Å–Ω–æ–≤–∞ –≤–∏–¥–µ—Ç—å, {name}!",
    },
    "START_PROMPT_FULLNAME": {
        "uk": "üë§ –í–≤–µ–¥—ñ—Ç—å –ø—Ä—ñ–∑–≤–∏—â–µ —Ç–∞ —ñ–º'—è (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, –Ü–≤–∞–Ω–µ–Ω–∫–æ –Ü–≤–∞–Ω).",
        "en": "üë§ Please enter your full name (for example, Smith John).",
        "de": "üë§ Bitte geben Sie Ihren vollst√§ndigen Namen ein (z.‚ÄØB. M√ºller Hans).",
        "pl": "üë§ Wpisz swoje imiƒô i nazwisko (np. Kowalski Jan).",
        "ru": "üë§ –í–≤–µ–¥–∏—Ç–µ —Ñ–∞–º–∏–ª–∏—é –∏ –∏–º—è (–Ω–∞–ø—Ä–∏–º–µ—Ä, –ò–≤–∞–Ω–æ–≤ –ò–≤–∞–Ω).",
    },
    "START_FULLNAME_INVALID": {
        "uk": "‚ùó –ë—É–¥—å –ª–∞—Å–∫–∞, –≤–∫–∞–∂—ñ—Ç—å —â–æ–Ω–∞–π–º–µ–Ω—à–µ —ñ–º'—è —Ç–∞ –ø—Ä—ñ–∑–≤–∏—â–µ –ø–æ–≤–Ω—ñ—Å—Ç—é.",
        "en": "‚ùó Please provide at least first and last name.",
        "de": "‚ùó Bitte geben Sie mindestens Vor- und Nachnamen vollst√§ndig an.",
        "pl": "‚ùó Podaj co najmniej imiƒô i nazwisko.",
        "ru": "‚ùó –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏—Ç–µ –∫–∞–∫ –º–∏–Ω–∏–º—É–º –∏–º—è –∏ —Ñ–∞–º–∏–ª–∏—é –ø–æ–ª–Ω–æ—Å—Ç—å—é.",
    },
    "START_REQUEST_PHONE": {
        "uk": "üìû –ù–∞—Ç–∏—Å–Ω—ñ—Ç—å ¬´üì± –ù–∞–¥—ñ—Å–ª–∞—Ç–∏ –Ω–æ–º–µ—Ä¬ª, —â–æ–± –ø–æ–¥—ñ–ª–∏—Ç–∏—Å—è —Ç–µ–ª–µ—Ñ–æ–Ω–æ–º.",
        "en": "üìû Tap ‚Äúüì± Share phone number‚Äù to send your contact.",
        "de": "üìû Tippen Sie auf ‚Äûüì± Telefonnummer senden‚Äú, um Ihre Nummer zu teilen.",
        "pl": "üìû Kliknij ‚Äûüì± Wy≈õlij numer‚Äù, aby przes≈Çaƒá sw√≥j kontakt.",
        "ru": "üìû –ù–∞–∂–º–∏—Ç–µ ¬´üì± –û—Ç–ø—Ä–∞–≤–∏—Ç—å –Ω–æ–º–µ—Ä¬ª, —á—Ç–æ–±—ã –ø–æ–¥–µ–ª–∏—Ç—å—Å—è —Ç–µ–ª–µ—Ñ–æ–Ω–æ–º.",
    },
    "START_PHONE_ERROR": {
        "uk": "‚ùó –ù–µ –≤–¥–∞–ª–æ—Å—è –æ—Ç—Ä–∏–º–∞—Ç–∏ –Ω–æ–º–µ—Ä. –°–ø—Ä–æ–±—É–π—Ç–µ —â–µ —Ä–∞–∑ –∫–Ω–æ–ø–∫–æ—é –Ω–∏–∂—á–µ.",
        "en": "‚ùó Failed to read the number. Please try again using the button below.",
        "de": "‚ùó Telefonnummer konnte nicht erkannt werden. Bitte versuchen Sie es erneut √ºber die Schaltfl√§che unten.",
        "pl": "‚ùó Nie uda≈Ço siƒô pobraƒá numeru. Spr√≥buj ponownie przyciskiem poni≈ºej.",
        "ru": "‚ùó –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –Ω–æ–º–µ—Ä. –ü–æ–≤—Ç–æ—Ä–∏—Ç–µ –ø–æ–ø—ã—Ç–∫—É –∫–Ω–æ–ø–∫–æ–π –Ω–∏–∂–µ.",
    },
    "START_PROFILE_SAVED": {
        "uk": "‚úÖ –ü—Ä–æ—Ñ—ñ–ª—å –∑–±–µ—Ä–µ–∂–µ–Ω–æ. –í–∞—à –∫–æ–¥: <b>{code}</b>\n–õ–∞—Å–∫–∞–≤–æ –ø—Ä–æ—Å–∏–º–æ!",
        "en": "‚úÖ Profile saved. Your code: <b>{code}</b>\nWelcome aboard!",
        "de": "‚úÖ Profil gespeichert. Ihr Code: <b>{code}</b>\nWillkommen an Bord!",
        "pl": "‚úÖ Profil zapisany. Tw√≥j kod: <b>{code}</b>\nWitamy na pok≈Çadzie!",
        "ru": "‚úÖ –ü—Ä–æ—Ñ–∏–ª—å —Å–æ—Ö—Ä–∞–Ω—ë–Ω. –í–∞—à –∫–æ–¥: <b>{code}</b>\n–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å!",
    },
    "ONBOARD_LANGUAGE_CONFIRMED": {
        "uk": "–ú–æ–≤—É –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–æ –Ω–∞ {language}. –ù–∞—Ç–∏—Å–Ω—ñ—Ç—å –∫–Ω–æ–ø–∫—É –Ω–∏–∂—á–µ, —â–æ–± –ø—Ä–æ–¥–æ–≤–∂–∏—Ç–∏ —Ä–µ—î—Å—Ç—Ä–∞—Ü—ñ—é.",
        "en": "Language switched to {language}. Tap the button below to continue your registration.",
        "de": "Sprache auf {language} umgestellt. Tippen Sie auf die Schaltfl√§che unten, um fortzufahren.",
        "pl": "Jƒôzyk zmieniono na {language}. Naci≈õnij przycisk poni≈ºej, aby kontynuowaƒá rejestracjƒô.",
        "ru": "–Ø–∑—ã–∫ –ø–µ—Ä–µ–∫–ª—é—á—ë–Ω –Ω–∞ {language}. –ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ, —á—Ç–æ–±—ã –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—é.",
    },
    "ONBOARD_WELCOME": {
        "uk": "üëã –ü—Ä–∏–≤—ñ—Ç, {name}!\n–õ–∞—Å–∫–∞–≤–æ –ø—Ä–æ—Å–∏–º–æ –¥–æ —Ä–æ–±–æ—á–æ–≥–æ –ø—Ä–æ—Å—Ç–æ—Ä—É <b>{bot}</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n–¢—É—Ç –∑—ñ–±—Ä–∞–Ω—ñ –ø—Ä–æ—î–∫—Ç–∏, —Ñ—ñ–Ω–∞–Ω—Å–∏, –∞—Ä—Ö—ñ–≤–∏ –¥–æ–∫—É–º–µ–Ω—Ç—ñ–≤ —ñ —Ç—Ä–∏–≤–æ–≥–∏.",
        "en": "üëã Hello, {name}!\nWelcome to the <b>{bot}</b> workspace\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nHere you will find projects, finance tools, document archives, and alert summaries.",
        "de": "üëã Hallo, {name}!\nWillkommen im Arbeitsbereich <b>{bot}</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nHier finden Sie Projekte, Finanzwerkzeuge, Dokumentarchive und Alarm√ºbersichten.",
        "pl": "üëã Cze≈õƒá, {name}!\nWitamy w przestrzeni roboczej <b>{bot}</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nTutaj znajdziesz projekty, finanse, archiwum dokument√≥w i podsumowania alarm√≥w.",
        "ru": "üëã –ü—Ä–∏–≤–µ—Ç, {name}!\n–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ —Ä–∞–±–æ—á–µ–µ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ <b>{bot}</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n–ó–¥–µ—Å—å —Å–æ–±—Ä–∞–Ω—ã –ø—Ä–æ–µ–∫—Ç—ã, —Ñ–∏–Ω–∞–Ω—Å—ã, –∞—Ä—Ö–∏–≤ –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤ –∏ —Å–≤–æ–¥–∫–∏ —Ç—Ä–µ–≤–æ–≥.",
    },
    "ONBOARD_BRIEFING": {
        "uk": "üß≠ –Ø–∫ –ø—Ä–æ–π—Ç–∏ —Ä–µ—î—Å—Ç—Ä–∞—Ü—ñ—é\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n1. –ù–∞–ø–∏—à—ñ—Ç—å –ø—Ä—ñ–∑–≤–∏—â–µ.\n2. –í–∫–∞–∂—ñ—Ç—å —ñ–º'—è.\n3. –ó–∞ –ø–æ—Ç—Ä–µ–±–∏ –¥–æ–¥–∞–π—Ç–µ –ø–æ –±–∞—Ç—å–∫–æ–≤—ñ (–º–æ–∂–Ω–∞ –ø—Ä–æ–ø—É—Å—Ç–∏—Ç–∏).\n4. –í–≤–µ–¥—ñ—Ç—å –¥–∞—Ç—É –Ω–∞—Ä–æ–¥–∂–µ–Ω–Ω—è —É —Ñ–æ—Ä–º–∞—Ç—ñ –î–î.–ú–ú.–†–†–†–†.\n5. –û–±–µ—Ä—ñ—Ç—å –æ–±–ª–∞—Å—Ç—å –ø—Ä–æ–∂–∏–≤–∞–Ω–Ω—è –∫–Ω–æ–ø–∫–æ—é.\n6. –ù–∞–¥—ñ—à–ª—ñ—Ç—å –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω—É –∫–Ω–æ–ø–∫–æ—é ¬´üì± –ù–∞–¥—ñ—Å–ª–∞—Ç–∏ –Ω–æ–º–µ—Ä¬ª.\n7. –î–æ–¥–∞–π—Ç–µ –ø–∞—Å–ø–æ—Ä—Ç–Ω–µ —Ñ–æ—Ç–æ –∞–±–æ –ø—Ä–æ–ø—É—Å—Ç—ñ—Ç—å, —è–∫—â–æ –ø–æ–∫–∏ –Ω–µ–º–∞.\n\n–ì–æ—Ç–æ–≤—ñ? –ù–∞—Ç–∏—Å–Ω—ñ—Ç—å –∫–Ω–æ–ø–∫—É, —â–æ–± –ø–æ—á–∞—Ç–∏.",
        "en": "üß≠ How to complete registration\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n1. Enter your last name.\n2. Provide your first name.\n3. Add a patronymic/middle name (optional).\n4. Submit your birth date in DD.MM.YYYY format.\n5. Pick your home region using the button.\n6. Send your phone number via the ‚Äúüì± Share phone number‚Äù button.\n7. Upload a passport-style photo or skip for now.\n\nReady? Tap the button to begin.",
        "de": "üß≠ So schlie√üen Sie die Registrierung ab\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n1. Nachnamen eingeben.\n2. Vornamen angeben.\n3. Vatersnamen/Zweitnamen erg√§nzen (optional).\n4. Geburtsdatum im Format TT.MM.JJJJ eingeben.\n5. Region per Schaltfl√§che ausw√§hlen.\n6. Telefonnummer √ºber ‚Äûüì± Nummer senden‚Äú teilen.\n7. Ein Passfoto hochladen oder vorerst √ºberspringen.\n\nBereit? Tippen Sie auf die Schaltfl√§che zum Start.",
        "pl": "üß≠ Jak uko≈Ñczyƒá rejestracjƒô\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n1. Podaj nazwisko.\n2. Wpisz imiƒô.\n3. Dodaj imiƒô ojca / drugie imiƒô (opcjonalnie).\n4. Wprowad≈∫ datƒô urodzenia w formacie DD.MM.RRRR.\n5. Wybierz region zamieszkania przyciskiem.\n6. Wy≈õlij numer telefonu przyciskiem ‚Äûüì± Wy≈õlij numer‚Äù.\n7. Dodaj zdjƒôcie paszportowe lub pomi≈Ñ na razie.\n\nGotowe? Kliknij przycisk, aby rozpoczƒÖƒá.",
        "ru": "üß≠ –ö–∞–∫ –ø—Ä–æ–π—Ç–∏ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—é\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n1. –£–∫–∞–∂–∏—Ç–µ —Ñ–∞–º–∏–ª–∏—é.\n2. –ù–∞–ø–∏—à–∏—Ç–µ –∏–º—è.\n3. –ü—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏ –¥–æ–±–∞–≤—å—Ç–µ –æ—Ç—á–µ—Å—Ç–≤–æ (–º–æ–∂–Ω–æ –ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å).\n4. –í–≤–µ–¥–∏—Ç–µ –¥–∞—Ç—É —Ä–æ–∂–¥–µ–Ω–∏—è –≤ —Ñ–æ—Ä–º–∞—Ç–µ –î–î.–ú–ú.–ì–ì–ì–ì.\n5. –í—ã–±–µ—Ä–∏—Ç–µ –æ–±–ª–∞—Å—Ç—å –ø—Ä–æ–∂–∏–≤–∞–Ω–∏—è —á–µ—Ä–µ–∑ –∫–Ω–æ–ø–∫—É.\n6. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ –∫–Ω–æ–ø–∫–æ–π ¬´üì± –û—Ç–ø—Ä–∞–≤–∏—Ç—å –Ω–æ–º–µ—Ä¬ª.\n7. –ó–∞–≥—Ä—É–∑–∏—Ç–µ —Ñ–æ—Ç–æ –≤ —Ñ–æ—Ä–º–∞—Ç–µ –ø–∞—Å–ø–æ—Ä—Ç–Ω–æ–≥–æ –∏–ª–∏ –ø—Ä–æ–ø—É—Å—Ç–∏—Ç–µ –ø–æ–∫–∞.\n\n–ì–æ—Ç–æ–≤—ã? –ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É, —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å.",
    },
    "ONBOARD_RETURNING_SHORTCUT": {
        "uk": "–í–∏–≥–ª—è–¥–∞—î, —â–æ –≤–∏ –≤–∂–µ –ø—Ä–æ—Ö–æ–¥–∏–ª–∏ —Ä–µ—î—Å—Ç—Ä–∞—Ü—ñ—é. –ù–∞—Ç–∏—Å–Ω—ñ—Ç—å –∫–Ω–æ–ø–∫—É, —â–æ–± –ø–µ—Ä–µ–π—Ç–∏ –¥–æ –≥–æ–ª–æ–≤–Ω–æ–≥–æ –º–µ–Ω—é –∞–±–æ –ø—Ä–æ–¥–æ–≤–∂–∏—Ç–∏ –æ–Ω–æ–≤–ª–µ–Ω–Ω—è –¥–∞–Ω–∏—Ö.",
        "en": "It seems you have already completed registration. Use the button to open the main menu or continue updating your data.",
        "de": "Sie scheinen bereits registriert zu sein. Nutzen Sie die Schaltfl√§che, um zum Hauptmen√º zu wechseln oder Ihre Daten zu aktualisieren.",
        "pl": "WyglƒÖda na to, ≈ºe rejestracja zosta≈Ça ju≈º zako≈Ñczona. U≈ºyj przycisku, aby przej≈õƒá do menu g≈Ç√≥wnego lub zaktualizowaƒá dane.",
        "ru": "–ü–æ—Ö–æ–∂–µ, –≤—ã —É–∂–µ –ø—Ä–æ—Ö–æ–¥–∏–ª–∏ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—é. –ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É, —á—Ç–æ–±—ã –æ—Ç–∫—Ä—ã—Ç—å –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é –∏–ª–∏ –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö.",
    },
    "REGISTER_INTRO_PROMPT": {
        "uk": "–ü–æ—á–∏–Ω–∞—î–º–æ! –í—ñ–¥–ø–æ–≤—ñ–¥–∞–π—Ç–µ –Ω–∞ –∑–∞–ø–∏—Ç–∞–Ω–Ω—è –Ω–∏–∂—á–µ. –í—Å—ñ –¥–æ–ø–æ–º—ñ–∂–Ω—ñ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –±—É–¥—É—Ç—å –ø—Ä–∏–±—Ä–∞–Ω—ñ –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ.",
        "en": "Let's get started! Answer the questions below ‚Äî helper messages will be cleaned up automatically.",
        "de": "Los geht's! Beantworten Sie die folgenden Fragen ‚Äì Hilfsnachrichten werden automatisch entfernt.",
        "pl": "Zaczynamy! Odpowiedz na poni≈ºsze pytania ‚Äì pomocnicze wiadomo≈õci zostanƒÖ usuniƒôte automatycznie.",
        "ru": "–ù–∞—á–∏–Ω–∞–µ–º! –û—Ç–≤–µ—á–∞–π—Ç–µ –Ω–∞ –≤–æ–ø—Ä–æ—Å—ã –Ω–∏–∂–µ ‚Äî —Å–ª—É–∂–µ–±–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è –±—É–¥—É—Ç —É–¥–∞–ª–µ–Ω—ã –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏.",
    },
    "REGISTER_LAST_NAME_PROMPT": {
        "uk": "1. –í–∫–∞–∂—ñ—Ç—å –≤–∞—à–µ –ø—Ä—ñ–∑–≤–∏—â–µ.",
        "en": "1. Please enter your last name.",
        "de": "1. Geben Sie Ihren Nachnamen ein.",
        "pl": "1. Podaj swoje nazwisko.",
        "ru": "1. –£–∫–∞–∂–∏—Ç–µ –≤–∞—à—É —Ñ–∞–º–∏–ª–∏—é.",
    },
    "REGISTER_LAST_NAME_WARN": {
        "uk": "‚ùó –ü–µ—Ä–µ–≤—ñ—Ä—Ç–µ –ø—Ä—ñ–∑–≤–∏—â–µ: –¥–æ–ø—É—Å–∫–∞—é—Ç—å—Å—è –ª–∏—à–µ –ª—ñ—Ç–µ—Ä–∏, –∞–ø–æ—Å—Ç—Ä–æ—Ñ —Ç–∞ –¥–µ—Ñ—ñ—Å.",
        "en": "‚ùó Please check your last name: only letters, apostrophes, and dashes are allowed.",
        "de": "‚ùó Pr√ºfen Sie den Nachnamen: Es sind nur Buchstaben, Apostroph und Bindestrich erlaubt.",
        "pl": "‚ùó Sprawd≈∫ nazwisko: dozwolone sƒÖ tylko litery, apostrof i my≈õlnik.",
        "ru": "‚ùó –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Ñ–∞–º–∏–ª–∏—é: –¥–æ–ø—É—Å—Ç–∏–º—ã —Ç–æ–ª—å–∫–æ –±—É–∫–≤—ã, –∞–ø–æ—Å—Ç—Ä–æ—Ñ –∏ –¥–µ—Ñ–∏—Å.",
    },
    "REGISTER_FIRST_NAME_PROMPT": {
        "uk": "2. –í–∫–∞–∂—ñ—Ç—å –≤–∞—à–µ —ñ–º'—è.",
        "en": "2. Please enter your first name.",
        "de": "2. Geben Sie Ihren Vornamen ein.",
        "pl": "2. Podaj swoje imiƒô.",
        "ru": "2. –£–∫–∞–∂–∏—Ç–µ –≤–∞—à–µ –∏–º—è.",
    },
    "REGISTER_FIRST_NAME_WARN": {
        "uk": "‚ùó –ü–µ—Ä–µ–≤—ñ—Ä—Ç–µ —ñ–º'—è: –¥–æ–ø—É—Å–∫–∞—é—Ç—å—Å—è –ª–∏—à–µ –ª—ñ—Ç–µ—Ä–∏, –∞–ø–æ—Å—Ç—Ä–æ—Ñ —Ç–∞ –¥–µ—Ñ—ñ—Å.",
        "en": "‚ùó Please check your first name: only letters, apostrophes, and dashes are allowed.",
        "de": "‚ùó Pr√ºfen Sie den Vornamen: Es sind nur Buchstaben, Apostroph und Bindestrich erlaubt.",
        "pl": "‚ùó Sprawd≈∫ imiƒô: dozwolone sƒÖ tylko litery, apostrof i my≈õlnik.",
        "ru": "‚ùó –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –∏–º—è: –¥–æ–ø—É—Å—Ç–∏–º—ã —Ç–æ–ª—å–∫–æ –±—É–∫–≤—ã, –∞–ø–æ—Å—Ç—Ä–æ—Ñ –∏ –¥–µ—Ñ–∏—Å.",
    },
    "REGISTER_MIDDLE_NAME_PROMPT": {
        "uk": "3. –í–∫–∞–∂—ñ—Ç—å –ø–æ –±–∞—Ç—å–∫–æ–≤—ñ (—è–∫—â–æ —î). –Ø–∫—â–æ –Ω–µ–º–∞—î ‚Äî –Ω–∞–ø–∏—à—ñ—Ç—å ¬´–Ω–µ–º–∞—î¬ª.",
        "en": "3. Enter your patronymic or middle name (optional). Type ‚Äúno‚Äù if you wish to skip.",
        "de": "3. Geben Sie Ihren Vatersnamen/Zweitnamen an (optional). Schreiben Sie ‚Äûkein‚Äú, um zu √ºberspringen.",
        "pl": "3. Podaj drugie imiƒô/imiƒô ojca (opcjonalnie). Wpisz ‚Äûbrak‚Äù, aby pominƒÖƒá.",
        "ru": "3. –£–∫–∞–∂–∏—Ç–µ –æ—Ç—á–µ—Å—Ç–≤–æ (–µ—Å–ª–∏ –µ—Å—Ç—å). –ï—Å–ª–∏ –Ω–µ—Ç ‚Äî –Ω–∞–ø–∏—à–∏—Ç–µ ¬´–Ω–µ—Ç¬ª.",
    },
    "REGISTER_MIDDLE_NAME_WARN": {
        "uk": "‚ùó –ü–µ—Ä–µ–≤—ñ—Ä—Ç–µ –ø–æ –±–∞—Ç—å–∫–æ–≤—ñ: –¥–æ–ø—É—Å–∫–∞—é—Ç—å—Å—è –ª–∏—à–µ –ª—ñ—Ç–µ—Ä–∏, –∞–ø–æ—Å—Ç—Ä–æ—Ñ —Ç–∞ –¥–µ—Ñ—ñ—Å.",
        "en": "‚ùó Please check the patronymic: only letters, apostrophes, and dashes are allowed.",
        "de": "‚ùó Pr√ºfen Sie den Zweitnamen: Es sind nur Buchstaben, Apostroph und Bindestrich erlaubt.",
        "pl": "‚ùó Sprawd≈∫ drugie imiƒô: dozwolone sƒÖ tylko litery, apostrof i my≈õlnik.",
        "ru": "‚ùó –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –æ—Ç—á–µ—Å—Ç–≤–æ: –¥–æ–ø—É—Å—Ç–∏–º—ã —Ç–æ–ª—å–∫–æ –±—É–∫–≤—ã, –∞–ø–æ—Å—Ç—Ä–æ—Ñ –∏ –¥–µ—Ñ–∏—Å.",
    },
    "REGISTER_BIRTHDATE_PROMPT": {
        "uk": "4. –í–∫–∞–∂—ñ—Ç—å –¥–∞—Ç—É –Ω–∞—Ä–æ–¥–∂–µ–Ω–Ω—è —É —Ñ–æ—Ä–º–∞—Ç—ñ –î–î.–ú–ú.–†–†–†–†.",
        "en": "4. Please enter your birth date in DD.MM.YYYY format.",
        "de": "4. Geben Sie Ihr Geburtsdatum im Format TT.MM.JJJJ ein.",
        "pl": "4. Wpisz datƒô urodzenia w formacie DD.MM.RRRR.",
        "ru": "4. –£–∫–∞–∂–∏—Ç–µ –¥–∞—Ç—É —Ä–æ–∂–¥–µ–Ω–∏—è –≤ —Ñ–æ—Ä–º–∞—Ç–µ –î–î.–ú–ú.–ì–ì–ì–ì.",
    },
    "REGISTER_BIRTHDATE_WARN": {
        "uk": "‚ùó –ù–µ –≤–¥–∞–ª–æ—Å—è —Ä–æ–∑–ø—ñ–∑–Ω–∞—Ç–∏ –¥–∞—Ç—É. –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ —Ñ–æ—Ä–º–∞—Ç –î–î.–ú–ú.–†–†–†–†.",
        "en": "‚ùó Could not parse the date. Please use DD.MM.YYYY format.",
        "de": "‚ùó Datum konnte nicht erkannt werden. Bitte verwenden Sie das Format TT.MM.JJJJ.",
        "pl": "‚ùó Nie uda≈Ço siƒô rozpoznaƒá daty. U≈ºyj formatu DD.MM.RRRR.",
        "ru": "‚ùó –ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å –¥–∞—Ç—É. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ñ–æ—Ä–º–∞—Ç –î–î.–ú–ú.–ì–ì–ì–ì.",
    },
    "REGISTER_REGION_PROMPT": {
        "uk": "5. –û–±–µ—Ä—ñ—Ç—å –æ–±–ª–∞—Å—Ç—å –ø—Ä–æ–∂–∏–≤–∞–Ω–Ω—è –∫–Ω–æ–ø–∫–æ—é –Ω–∏–∂—á–µ.",
        "en": "5. Pick your home region using the button below.",
        "de": "5. W√§hlen Sie Ihre Region √ºber die Schaltfl√§che unten.",
        "pl": "5. Wybierz region zamieszkania przyciskiem poni≈ºej.",
        "ru": "5. –í—ã–±–µ—Ä–∏—Ç–µ –æ–±–ª–∞—Å—Ç—å –ø—Ä–æ–∂–∏–≤–∞–Ω–∏—è –∫–Ω–æ–ø–∫–æ–π –Ω–∏–∂–µ.",
    },
    "REGISTER_REGION_BUTTON": {
        "uk": "üìç –í–∏–±—Ä–∞—Ç–∏ –æ–±–ª–∞—Å—Ç—å",
        "en": "üìç Choose region",
        "de": "üìç Region w√§hlen",
        "pl": "üìç Wybierz region",
        "ru": "üìç –í—ã–±—Ä–∞—Ç—å –æ–±–ª–∞—Å—Ç—å",
    },
    "REGISTER_REGION_PICK": {
        "uk": "–û–±–µ—Ä—ñ—Ç—å –æ–±–ª–∞—Å—Ç—å –∑—ñ —Å–ø–∏—Å–∫—É:",
        "en": "Select your region from the list:",
        "de": "W√§hlen Sie Ihre Region aus der Liste:",
        "pl": "Wybierz region z listy:",
        "ru": "–í—ã–±–µ—Ä–∏—Ç–µ –æ–±–ª–∞—Å—Ç—å –∏–∑ —Å–ø–∏—Å–∫–∞:",
    },
    "REGISTER_REGION_REMIND": {
        "uk": "–ë—É–¥—å –ª–∞—Å–∫–∞, —Å–∫–æ—Ä–∏—Å—Ç–∞–π—Ç–µ—Å—è –∫–Ω–æ–ø–∫–æ—é ¬´üìç –í–∏–±—Ä–∞—Ç–∏ –æ–±–ª–∞—Å—Ç—å¬ª.",
        "en": "Please use the ‚Äúüìç Choose region‚Äù button.",
        "de": "Bitte verwenden Sie die Schaltfl√§che ‚Äûüìç Region w√§hlen‚Äú.",
        "pl": "U≈ºyj przycisku ‚Äûüìç Wybierz region‚Äù.",
        "ru": "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–æ—Å–ø–æ–ª—å–∑—É–π—Ç–µ—Å—å –∫–Ω–æ–ø–∫–æ–π ¬´üìç –í—ã–±—Ä–∞—Ç—å –æ–±–ª–∞—Å—Ç—å¬ª.",
    },
    "REGISTER_REGION_SELECTED": {
        "uk": "–û–±–ª–∞—Å—Ç—å <b>{region}</b> –∑–±–µ—Ä–µ–∂–µ–Ω–æ. –ù–∞—Ç–∏—Å–Ω—ñ—Ç—å –∫–Ω–æ–ø–∫—É, —â–æ–± –ø—Ä–æ–¥–æ–≤–∂–∏—Ç–∏.",
        "en": "Region <b>{region}</b> saved. Tap the button to continue.",
        "de": "Region <b>{region}</b> gespeichert. Tippen Sie auf die Schaltfl√§che zum Fortfahren.",
        "pl": "Region <b>{region}</b> zapisano. Naci≈õnij przycisk, aby kontynuowaƒá.",
        "ru": "–û–±–ª–∞—Å—Ç—å <b>{region}</b> —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞. –ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É, —á—Ç–æ–±—ã –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å.",
    },
    "REGISTER_PHONE_PROMPT_NEW": {
        "uk": "6. –ù–∞–¥—ñ—à–ª—ñ—Ç—å –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω—É –∫–Ω–æ–ø–∫–æ—é ¬´üì± –ù–∞–¥—ñ—Å–ª–∞—Ç–∏ –Ω–æ–º–µ—Ä¬ª.",
        "en": "6. Send your phone number using the ‚Äúüì± Share phone number‚Äù button.",
        "de": "6. Senden Sie Ihre Telefonnummer √ºber die Schaltfl√§che ‚Äûüì± Nummer senden‚Äú.",
        "pl": "6. Wy≈õlij numer telefonu przyciskiem ‚Äûüì± Wy≈õlij numer‚Äù.",
        "ru": "6. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ –∫–Ω–æ–ø–∫–æ–π ¬´üì± –û—Ç–ø—Ä–∞–≤–∏—Ç—å –Ω–æ–º–µ—Ä¬ª.",
    },
    "REGISTER_PHONE_WARN": {
        "uk": "‚ùó –ù–µ –≤–¥–∞–ª–æ—Å—è –∑—á–∏—Ç–∞—Ç–∏ –∫–æ–Ω—Ç–∞–∫—Ç. –°–ø—Ä–æ–±—É–π—Ç–µ —â–µ —Ä–∞–∑ –∫–Ω–æ–ø–∫–æ—é –Ω–∏–∂—á–µ.",
        "en": "‚ùó Could not read the contact. Please try again with the button below.",
        "de": "‚ùó Kontakt konnte nicht erkannt werden. Bitte erneut √ºber die Schaltfl√§che unten versuchen.",
        "pl": "‚ùó Nie uda≈Ço siƒô pobraƒá kontaktu. Spr√≥buj ponownie przyciskiem poni≈ºej.",
        "ru": "‚ùó –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∫–æ–Ω—Ç–∞–∫—Ç. –ü–æ–≤—Ç–æ—Ä–∏—Ç–µ –ø–æ–ø—ã—Ç–∫—É –∫–Ω–æ–ø–∫–æ–π –Ω–∏–∂–µ.",
    },
    "REGISTER_PHONE_TEXT_WARN": {
        "uk": "üìû –°–∫–æ—Ä–∏—Å—Ç–∞–π—Ç–µ—Å—è –∫–Ω–æ–ø–∫–æ—é ¬´üì± –ù–∞–¥—ñ—Å–ª–∞—Ç–∏ –Ω–æ–º–µ—Ä¬ª, —â–æ–± –ø–æ–¥—ñ–ª–∏—Ç–∏—Å—è —Ç–µ–ª–µ—Ñ–æ–Ω–æ–º.",
        "en": "üìû Please use the ‚Äúüì± Share phone number‚Äù button to send your contact.",
        "de": "üìû Bitte nutzen Sie die Schaltfl√§che ‚Äûüì± Nummer senden‚Äú, um Ihren Kontakt zu teilen.",
        "pl": "üìû Skorzystaj z przycisku ‚Äûüì± Wy≈õlij numer‚Äù, aby przes≈Çaƒá kontakt.",
        "ru": "üìû –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫—É ¬´üì± –û—Ç–ø—Ä–∞–≤–∏—Ç—å –Ω–æ–º–µ—Ä¬ª, —á—Ç–æ–±—ã –ø–æ–¥–µ–ª–∏—Ç—å—Å—è —Ç–µ–ª–µ—Ñ–æ–Ω–æ–º.",
    },
    "REGISTER_PHONE_OK": {
        "uk": "–ö–æ–Ω—Ç–∞–∫—Ç –∑–±–µ—Ä–µ–∂–µ–Ω–æ ‚úÖ",
        "en": "Contact saved ‚úÖ",
        "de": "Kontakt gespeichert ‚úÖ",
        "pl": "Kontakt zapisany ‚úÖ",
        "ru": "–ö–æ–Ω—Ç–∞–∫—Ç —Å–æ—Ö—Ä–∞–Ω—ë–Ω ‚úÖ",
    },
    "REGISTER_PHOTO_PROMPT": {
        "uk": "7. –î–æ–¥–∞–π—Ç–µ –ø–∞—Å–ø–æ—Ä—Ç–Ω–µ —Ñ–æ—Ç–æ.\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n‚Ä¢ —Ñ—Ä–æ–Ω—Ç–∞–ª—å–Ω–∏–π —Ä–∞–∫—É—Ä—Å\n‚Ä¢ –Ω–µ–π—Ç—Ä–∞–ª—å–Ω–∏–π —Ñ–æ–Ω\n‚Ä¢ —Ä—ñ–≤–Ω–µ –æ—Å–≤—ñ—Ç–ª–µ–Ω–Ω—è\n–Ø–∫—â–æ –ø–æ–∫–∏ —â–æ –Ω–µ–º–∞ —Ñ–æ—Ç–æ, –Ω–∞—Ç–∏—Å–Ω—ñ—Ç—å ¬´–ü—Ä–æ–ø—É—Å—Ç–∏—Ç–∏¬ª.",
        "en": "7. Upload a passport-style photo.\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n‚Ä¢ frontal view\n‚Ä¢ neutral background\n‚Ä¢ even lighting\nIf you don't have one yet, tap ‚ÄúSkip‚Äù.",
        "de": "7. Laden Sie ein Passfoto hoch.\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n‚Ä¢ frontale Ansicht\n‚Ä¢ neutraler Hintergrund\n‚Ä¢ gleichm√§√üige Beleuchtung\nFalls Sie noch keines haben, tippen Sie auf ‚Äû√úberspringen‚Äú.",
        "pl": "7. Dodaj zdjƒôcie paszportowe.\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n‚Ä¢ ujƒôcie frontalne\n‚Ä¢ neutralne t≈Ço\n‚Ä¢ r√≥wnomierne o≈õwietlenie\nJe≈õli nie masz zdjƒôcia, wybierz ‚ÄûPomi≈Ñ‚Äù.",
        "ru": "7. –ó–∞–≥—Ä—É–∑–∏—Ç–µ —Ñ–æ—Ç–æ —Ñ–æ—Ä–º–∞—Ç–∞ ¬´–Ω–∞ –¥–æ–∫—É–º–µ–Ω—Ç—ã¬ª.\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n‚Ä¢ —Ñ—Ä–æ–Ω—Ç–∞–ª—å–Ω—ã–π —Ä–∞–∫—É—Ä—Å\n‚Ä¢ –Ω–µ–π—Ç—Ä–∞–ª—å–Ω—ã–π —Ñ–æ–Ω\n‚Ä¢ —Ä–æ–≤–Ω–æ–µ –æ—Å–≤–µ—â–µ–Ω–∏–µ\n–ï—Å–ª–∏ —Ñ–æ—Ç–æ –ø–æ–∫–∞ –Ω–µ—Ç, –Ω–∞–∂–º–∏—Ç–µ ¬´–ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å¬ª.",
    },
    "REGISTER_PHOTO_WARN": {
        "uk": "‚ùó –ù–µ –≤–¥–∞–ª–æ—Å—è –æ–±—Ä–æ–±–∏—Ç–∏ —Ñ–æ—Ç–æ. –°–ø—Ä–æ–±—É–π—Ç–µ —ñ–Ω—à–∏–π —Ñ–∞–π–ª –∞–±–æ –∑—Ä–æ–±—ñ—Ç—å –Ω–æ–≤–µ —Ñ–æ—Ç–æ.",
        "en": "‚ùó Could not process the photo. Please try another file or take a new picture.",
        "de": "‚ùó Foto konnte nicht verarbeitet werden. Bitte versuchen Sie eine andere Datei oder machen Sie ein neues Foto.",
        "pl": "‚ùó Nie uda≈Ço siƒô przetworzyƒá zdjƒôcia. Spr√≥buj innego pliku lub zr√≥b nowe zdjƒôcie.",
        "ru": "‚ùó –ù–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å —Ñ–æ—Ç–æ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –¥—Ä—É–≥–æ–π —Ñ–∞–π–ª –∏–ª–∏ —Å–¥–µ–ª–∞–π—Ç–µ –Ω–æ–≤–æ–µ —Ñ–æ—Ç–æ.",
    },
    "REGISTER_PHOTO_RECEIVED": {
        "uk": "–§–æ—Ç–æ –æ—Ç—Ä–∏–º–∞–Ω–æ ‚úÖ",
        "en": "Photo received ‚úÖ",
        "de": "Foto erhalten ‚úÖ",
        "pl": "Zdjƒôcie otrzymane ‚úÖ",
        "ru": "–§–æ—Ç–æ –ø–æ–ª—É—á–µ–Ω–æ ‚úÖ",
    },
    "REGISTER_PHOTO_SKIP_CONFIRM": {
        "uk": "–§–æ—Ç–æ –º–æ–∂–Ω–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ –ø—ñ–∑–Ω—ñ—à–µ —É —Ä–æ–∑–¥—ñ–ª—ñ –ø—Ä–æ—Ñ—ñ–ª—é.",
        "en": "You can upload a photo later from your profile section.",
        "de": "Sie k√∂nnen das Foto sp√§ter im Profilbereich hochladen.",
        "pl": "Zdjƒôcie mo≈ºesz dodaƒá p√≥≈∫niej w swoim profilu.",
        "ru": "–§–æ—Ç–æ –º–æ–∂–Ω–æ –∑–∞–≥—Ä—É–∑–∏—Ç—å –ø–æ–∑–∂–µ –≤ —Ä–∞–∑–¥–µ–ª–µ –ø—Ä–æ—Ñ–∏–ª—è.",
    },
    "REGISTER_FINISH_CONFIRM": {
        "uk": "–†–µ—î—Å—Ç—Ä–∞—Ü—ñ—é –∑–∞–≤–µ—Ä—à–µ–Ω–æ. –í–∞—à –∞—Ä—Ç–∏–∫—É–ª BSG ‚Äî <b>{code}</b>.",
        "en": "Registration completed. Your BSG article is <b>{code}</b>.",
        "de": "Registrierung abgeschlossen. Ihre BSG-Kennung lautet <b>{code}</b>.",
        "pl": "Rejestracja zako≈Ñczona. Tw√≥j kod BSG to <b>{code}</b>.",
        "ru": "–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞. –í–∞—à –∞—Ä—Ç–∏–∫—É–ª BSG ‚Äî <b>{code}</b>.",
    },
    "PROFILE_HEADER": {
        "uk": "üë§ <b>–ú—ñ–π –ø—Ä–æ—Ñ—ñ–ª—å</b>",
        "en": "üë§ <b>My profile</b>",
        "de": "üë§ <b>Mein Profil</b>",
        "pl": "üë§ <b>M√≥j profil</b>",
        "ru": "üë§ <b>–ú–æ–π –ø—Ä–æ—Ñ–∏–ª—å</b>",
    },
    "PROFILE_EDIT_HINT": {
        "uk": "‚úèÔ∏è –†–µ–∂–∏–º —Ä–µ–¥–∞–≥—É–≤–∞–Ω–Ω—è –∞–∫—Ç–∏–≤–Ω–∏–π. –û–±–µ—Ä—ñ—Ç—å –ø–æ–ª–µ –Ω–∏–∂—á–µ, —â–æ–± –æ–Ω–æ–≤–∏—Ç–∏ –¥–∞–Ω—ñ.",
        "en": "‚úèÔ∏è Edit mode is active. Pick a field below to update your data.",
        "de": "‚úèÔ∏è Bearbeitungsmodus aktiv. W√§hlen Sie unten ein Feld, um die Daten zu aktualisieren.",
        "pl": "‚úèÔ∏è Tryb edycji jest aktywny. Wybierz pole poni≈ºej, aby zaktualizowaƒá dane.",
        "ru": "‚úèÔ∏è –†–µ–∂–∏–º —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –∞–∫—Ç–∏–≤–µ–Ω. –í—ã–±–µ—Ä–∏—Ç–µ –ø–æ–ª–µ –Ω–∏–∂–µ, —á—Ç–æ–±—ã –æ–±–Ω–æ–≤–∏—Ç—å –¥–∞–Ω–Ω—ã–µ.",
    },
    "PROFILE_FIELD_LAST_NAME": {
        "uk": "–ü—Ä—ñ–∑–≤–∏—â–µ",
        "en": "Last name",
        "de": "Nachname",
        "pl": "Nazwisko",
        "ru": "–§–∞–º–∏–ª–∏—è",
    },
    "PROFILE_FIELD_FIRST_NAME": {
        "uk": "–Ü–º'—è",
        "en": "First name",
        "de": "Vorname",
        "pl": "Imiƒô",
        "ru": "–ò–º—è",
    },
    "PROFILE_FIELD_MIDDLE_NAME": {
        "uk": "–ü–æ –±–∞—Ç—å–∫–æ–≤—ñ",
        "en": "Patronymic",
        "de": "Vatersname",
        "pl": "Drugie imiƒô",
        "ru": "–û—Ç—á–µ—Å—Ç–≤–æ",
    },
    "PROFILE_FIELD_BIRTHDATE": {
        "uk": "–î–∞—Ç–∞ –Ω–∞—Ä–æ–¥–∂–µ–Ω–Ω—è",
        "en": "Birth date",
        "de": "Geburtsdatum",
        "pl": "Data urodzenia",
        "ru": "–î–∞—Ç–∞ —Ä–æ–∂–¥–µ–Ω–∏—è",
    },
    "PROFILE_FIELD_REGION": {
        "uk": "–û–±–ª–∞—Å—Ç—å",
        "en": "Region",
        "de": "Region",
        "pl": "Obw√≥d",
        "ru": "–û–±–ª–∞—Å—Ç—å",
    },
    "PROFILE_FIELD_PHONE": {
        "uk": "–¢–µ–ª–µ—Ñ–æ–Ω",
        "en": "Phone",
        "de": "Telefon",
        "pl": "Telefon",
        "ru": "–¢–µ–ª–µ—Ñ–æ–Ω",
    },
    "PROFILE_FIELD_TG_ID": {
        "uk": "Telegram ID",
        "en": "Telegram ID",
        "de": "Telegram-ID",
        "pl": "ID Telegram",
        "ru": "Telegram ID",
    },
    "PROFILE_FIELD_TG_USERNAME": {
        "uk": "Telegram —é–∑–µ—Ä",
        "en": "Telegram username",
        "de": "Telegram-Benutzername",
        "pl": "Nazwa w Telegramie",
        "ru": "–ò–º—è –≤ Telegram",
    },
    "PROFILE_FIELD_BSU": {
        "uk": "BSU –∫–æ–¥",
        "en": "BSU code",
        "de": "BSU-Code",
        "pl": "Kod BSU",
        "ru": "BSU –∫–æ–¥",
    },
    "PROFILE_FIELD_PHOTO": {
        "uk": "–§–æ—Ç–æ –ø—Ä–æ—Ñ—ñ–ª—é",
        "en": "Profile photo",
        "de": "Profilfoto",
        "pl": "Zdjƒôcie profilu",
        "ru": "–§–æ—Ç–æ –ø—Ä–æ—Ñ–∏–ª—è",
    },
    "PROFILE_VALUE_MISSING": {
        "uk": "‚Äî",
        "en": "‚Äî",
        "de": "‚Äî",
        "pl": "‚Äî",
        "ru": "‚Äî",
    },
    "PROFILE_PHOTO_STATUS_OK": {
        "uk": "–∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–æ",
        "en": "uploaded",
        "de": "hochgeladen",
        "pl": "dodano",
        "ru": "–∑–∞–≥—Ä—É–∂–µ–Ω–æ",
    },
    "PROFILE_PHOTO_STATUS_MISSING": {
        "uk": "–≤—ñ–¥—Å—É—Ç–Ω—î",
        "en": "missing",
        "de": "fehlt",
        "pl": "brak",
        "ru": "–æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç",
    },
    "PROFILE_PHOTO_STATUS_SKIPPED": {
        "uk": "–ø–æ–∫–∏ –ø—Ä–æ–ø—É—â–µ–Ω–æ",
        "en": "skipped for now",
        "de": "vorerst √ºbersprungen",
        "pl": "pominiƒôto",
        "ru": "–ø—Ä–æ–ø—É—â–µ–Ω–æ –ø–æ–∫–∞",
    },
    "PROFILE_PROMPT_LAST_NAME": {
        "uk": "1. –í–∫–∞–∂—ñ—Ç—å –Ω–æ–≤–µ –ø—Ä—ñ–∑–≤–∏—â–µ (–ª–∏—à–µ –ª—ñ—Ç–µ—Ä–∏).",
        "en": "1. Enter the new last name (letters only).",
        "de": "1. Geben Sie den neuen Nachnamen ein (nur Buchstaben).",
        "pl": "1. Podaj nowe nazwisko (tylko litery).",
        "ru": "1. –£–∫–∞–∂–∏—Ç–µ –Ω–æ–≤—É—é —Ñ–∞–º–∏–ª–∏—é (—Ç–æ–ª—å–∫–æ –±—É–∫–≤—ã).",
    },
    "PROFILE_PROMPT_FIRST_NAME": {
        "uk": "2. –í–∫–∞–∂—ñ—Ç—å –Ω–æ–≤–µ —ñ–º'—è (–ª–∏—à–µ –ª—ñ—Ç–µ—Ä–∏).",
        "en": "2. Enter the new first name (letters only).",
        "de": "2. Geben Sie den neuen Vornamen ein (nur Buchstaben).",
        "pl": "2. Podaj nowe imiƒô (tylko litery).",
        "ru": "2. –£–∫–∞–∂–∏—Ç–µ –Ω–æ–≤–æ–µ –∏–º—è (—Ç–æ–ª—å–∫–æ –±—É–∫–≤—ã).",
    },
    "PROFILE_PROMPT_MIDDLE_NAME": {
        "uk": "3. –í–≤–µ–¥—ñ—Ç—å –ø–æ –±–∞—Ç—å–∫–æ–≤—ñ –∞–±–æ –Ω–∞–ø–∏—à—ñ—Ç—å ¬´–Ω–µ–º–∞—î¬ª, —â–æ–± –æ—á–∏—Å—Ç–∏—Ç–∏ –ø–æ–ª–µ.",
        "en": "3. Provide a patronymic or type ‚Äúnone‚Äù to clear the field.",
        "de": "3. Geben Sie den Vatersnamen an oder schreiben Sie ‚Äûkein‚Äú, um das Feld zu leeren.",
        "pl": "3. Podaj drugie imiƒô lub wpisz ‚Äûbrak‚Äù, aby wyczy≈õciƒá pole.",
        "ru": "3. –í–≤–µ–¥–∏—Ç–µ –æ—Ç—á–µ—Å—Ç–≤–æ –∏–ª–∏ –Ω–∞–ø–∏—à–∏—Ç–µ ¬´–Ω–µ—Ç¬ª, —á—Ç–æ–±—ã –æ—á–∏—Å—Ç–∏—Ç—å –ø–æ–ª–µ.",
    },
    "PROFILE_PROMPT_BIRTHDATE": {
        "uk": "4. –í–∫–∞–∂—ñ—Ç—å –¥–∞—Ç—É –Ω–∞—Ä–æ–¥–∂–µ–Ω–Ω—è —É —Ñ–æ—Ä–º–∞—Ç—ñ –î–î.–ú–ú.–†–†–†–†.",
        "en": "4. Enter the birth date in DD.MM.YYYY format.",
        "de": "4. Geben Sie das Geburtsdatum im Format TT.MM.JJJJ ein.",
        "pl": "4. Podaj datƒô urodzenia w formacie DD.MM.RRRR.",
        "ru": "4. –£–∫–∞–∂–∏—Ç–µ –¥–∞—Ç—É —Ä–æ–∂–¥–µ–Ω–∏—è –≤ —Ñ–æ—Ä–º–∞—Ç–µ –î–î.–ú–ú.–ì–ì–ì–ì.",
    },
    "PROFILE_PROMPT_REGION": {
        "uk": "5. –û–±–µ—Ä—ñ—Ç—å –æ–±–ª–∞—Å—Ç—å –ø—Ä–æ–∂–∏–≤–∞–Ω–Ω—è –∫–Ω–æ–ø–∫–æ—é –Ω–∏–∂—á–µ.",
        "en": "5. Choose your region using the button below.",
        "de": "5. W√§hlen Sie Ihre Region √ºber die Schaltfl√§che unten.",
        "pl": "5. Wybierz sw√≥j obw√≥d za pomocƒÖ przycisku poni≈ºej.",
        "ru": "5. –í—ã–±–µ—Ä–∏—Ç–µ –æ–±–ª–∞—Å—Ç—å –ø—Ä–æ–∂–∏–≤–∞–Ω–∏—è –∫–Ω–æ–ø–∫–æ–π –Ω–∏–∂–µ.",
    },
    "PROFILE_PROMPT_PHONE": {
        "uk": "6. –ù–∞–¥—ñ—à–ª—ñ—Ç—å –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω—É —á–µ—Ä–µ–∑ –∫–Ω–æ–ø–∫—É ¬´üì± –ù–∞–¥—ñ—Å–ª–∞—Ç–∏ –Ω–æ–º–µ—Ä¬ª.",
        "en": "6. Send your phone number via the ‚Äúüì± Share phone number‚Äù button.",
        "de": "6. Senden Sie Ihre Telefonnummer √ºber die Schaltfl√§che ‚Äûüì± Nummer senden‚Äú.",
        "pl": "6. Wy≈õlij numer telefonu przyciskiem ‚Äûüì± Wy≈õlij numer‚Äù.",
        "ru": "6. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ –∫–Ω–æ–ø–∫–æ–π ¬´üì± –û—Ç–ø—Ä–∞–≤–∏—Ç—å –Ω–æ–º–µ—Ä¬ª.",
    },
    "PROFILE_PROMPT_PHOTO": {
        "uk": "7. –ó–∞–≤–∞–Ω—Ç–∞–∂—Ç–µ –æ–Ω–æ–≤–ª–µ–Ω–µ –ø–∞—Å–ø–æ—Ä—Ç–Ω–µ —Ñ–æ—Ç–æ.\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n‚Ä¢ —Ñ—Ä–æ–Ω—Ç–∞–ª—å–Ω–∏–π —Ä–∞–∫—É—Ä—Å\n‚Ä¢ –Ω–µ–π—Ç—Ä–∞–ª—å–Ω–∏–π —Ñ–æ–Ω\n‚Ä¢ —Ä—ñ–≤–Ω–µ –æ—Å–≤—ñ—Ç–ª–µ–Ω–Ω—è",
        "en": "7. Upload an updated passport-style photo.\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n‚Ä¢ frontal view\n‚Ä¢ neutral background\n‚Ä¢ even lighting",
        "de": "7. Laden Sie ein aktualisiertes Passfoto hoch.\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n‚Ä¢ frontale Ansicht\n‚Ä¢ neutraler Hintergrund\n‚Ä¢ gleichm√§√üige Beleuchtung",
        "pl": "7. Dodaj zaktualizowane zdjƒôcie paszportowe.\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n‚Ä¢ ujƒôcie frontalne\n‚Ä¢ neutralne t≈Ço\n‚Ä¢ r√≥wnomierne o≈õwietlenie",
        "ru": "7. –ó–∞–≥—Ä—É–∑–∏—Ç–µ –æ–±–Ω–æ–≤–ª—ë–Ω–Ω–æ–µ —Ñ–æ—Ç–æ —Ñ–æ—Ä–º–∞—Ç–∞ ¬´–Ω–∞ –¥–æ–∫—É–º–µ–Ω—Ç—ã¬ª.\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n‚Ä¢ —Ñ—Ä–æ–Ω—Ç–∞–ª—å–Ω—ã–π —Ä–∞–∫—É—Ä—Å\n‚Ä¢ –Ω–µ–π—Ç—Ä–∞–ª—å–Ω—ã–π —Ñ–æ–Ω\n‚Ä¢ —Ä–æ–≤–Ω–æ–µ –æ—Å–≤–µ—â–µ–Ω–∏–µ",
    },
    "PROFILE_UPDATE_SUCCESS": {
        "uk": "‚úÖ –î–∞–Ω—ñ –æ–Ω–æ–≤–ª–µ–Ω–æ",
        "en": "‚úÖ Data updated",
        "de": "‚úÖ Daten aktualisiert",
        "pl": "‚úÖ Dane zaktualizowano",
        "ru": "‚úÖ –î–∞–Ω–Ω—ã–µ –æ–±–Ω–æ–≤–ª–µ–Ω—ã",
    },
    "PROFILE_PHOTO_UPDATED": {
        "uk": "üñº –§–æ—Ç–æ –ø—Ä–æ—Ñ—ñ–ª—é –∑–±–µ—Ä–µ–∂–µ–Ω–æ",
        "en": "üñº Profile photo saved",
        "de": "üñº Profilfoto gespeichert",
        "pl": "üñº Zdjƒôcie profilu zapisane",
        "ru": "üñº –§–æ—Ç–æ –ø—Ä–æ—Ñ–∏–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ",
    },
    "PROFILE_PHOTO_REMOVED": {
        "uk": "üóë –§–æ—Ç–æ –ø—Ä–æ—Ñ—ñ–ª—é –≤–∏–¥–∞–ª–µ–Ω–æ",
        "en": "üóë Profile photo removed",
        "de": "üóë Profilfoto gel√∂scht",
        "pl": "üóë Zdjƒôcie profilu usuniƒôto",
        "ru": "üóë –§–æ—Ç–æ –ø—Ä–æ—Ñ–∏–ª—è —É–¥–∞–ª–µ–Ω–æ",
    },
    "PROFILE_PHONE_SAVED": {
        "uk": "üì± –¢–µ–ª–µ—Ñ–æ–Ω –∑–±–µ—Ä–µ–∂–µ–Ω–æ",
        "en": "üì± Phone saved",
        "de": "üì± Telefon gespeichert",
        "pl": "üì± Numer zapisano",
        "ru": "üì± –¢–µ–ª–µ—Ñ–æ–Ω —Å–æ—Ö—Ä–∞–Ω—ë–Ω",
    },
    "PROFILE_CANCELLED": {
        "uk": "‚ùå –†–µ–¥–∞–≥—É–≤–∞–Ω–Ω—è —Å–∫–∞—Å–æ–≤–∞–Ω–æ",
        "en": "‚ùå Edit cancelled",
        "de": "‚ùå Bearbeitung abgebrochen",
        "pl": "‚ùå Edycjƒô anulowano",
        "ru": "‚ùå –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ",
    },
    "PROFILE_NO_PHOTO": {
        "uk": "üì∑ –§–æ—Ç–æ –ø—Ä–æ—Ñ—ñ–ª—é —â–µ –Ω–µ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–æ.",
        "en": "üì∑ A profile photo has not been uploaded yet.",
        "de": "üì∑ Es wurde noch kein Profilfoto hochgeladen.",
        "pl": "üì∑ Zdjƒôcie profilu nie zosta≈Ço jeszcze dodane.",
        "ru": "üì∑ –§–æ—Ç–æ –ø—Ä–æ—Ñ–∏–ª—è –µ—â—ë –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω–æ.",
    },
    "LANGUAGE_PROMPT": {
        "uk": "üåê –û–±–µ—Ä—ñ—Ç—å –º–æ–≤—É —Å–ø—ñ–ª–∫—É–≤–∞–Ω–Ω—è –∑ –±–æ—Ç–æ–º:",
        "en": "üåê Choose the language you prefer to use with the bot:",
        "de": "üåê W√§hlen Sie die Sprache f√ºr die Kommunikation mit dem Bot:",
        "pl": "üåê Wybierz jƒôzyk komunikacji z botem:",
        "ru": "üåê –í—ã–±–µ—Ä–∏—Ç–µ —è–∑—ã–∫ –æ–±—â–µ–Ω–∏—è —Å –±–æ—Ç–æ–º:",
    },
    "LANGUAGE_SELECTED": {
        "uk": "‚úÖ –ú–æ–≤—É –∑–º—ñ–Ω–µ–Ω–æ –Ω–∞: {language}.",
        "en": "‚úÖ Language switched to: {language}.",
        "de": "‚úÖ Sprache ge√§ndert zu: {language}.",
        "pl": "‚úÖ Zmieniono jƒôzyk na: {language}.",
        "ru": "‚úÖ –Ø–∑—ã–∫ –ø–µ—Ä–µ–∫–ª—é—á—ë–Ω –Ω–∞: {language}.",
    },
    "SETTINGS_TITLE": {
        "uk": "‚öôÔ∏è <b>–ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è</b>\n–û–±–µ—Ä—ñ—Ç—å –¥—ñ—é:",
        "en": "‚öôÔ∏è <b>Settings</b>\nChoose an action:",
        "de": "‚öôÔ∏è <b>Einstellungen</b>\nW√§hlen Sie eine Aktion:",
        "pl": "‚öôÔ∏è <b>Ustawienia</b>\nWybierz dzia≈Çanie:",
        "ru": "‚öôÔ∏è <b>–ù–∞—Å—Ç—Ä–æ–π–∫–∏</b>\n–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:",
    },
    "SETTINGS_LANGUAGE": {
        "uk": "üåê –ó–º—ñ–Ω–∏—Ç–∏ –º–æ–≤—É",
        "en": "üåê Change language",
        "de": "üåê Sprache √§ndern",
        "pl": "üåê Zmie≈Ñ jƒôzyk",
        "ru": "üåê –ò–∑–º–µ–Ω–∏—Ç—å —è–∑—ã–∫",
    },
    "INVALID_COMMAND": {
        "uk": "‚ö†Ô∏è –ö–æ–º–∞–Ω–¥–∞ –Ω–µ —Ä–æ–∑–ø—ñ–∑–Ω–∞–Ω–∞. –°–∫–æ—Ä–∏—Å—Ç–∞–π—Ç–µ—Å—è –º–µ–Ω—é –Ω–∏–∂—á–µ.",
        "en": "‚ö†Ô∏è Command not recognized. Please use the menu below.",
        "de": "‚ö†Ô∏è Unbekannter Befehl. Bitte nutzen Sie das Men√º unten.",
        "pl": "‚ö†Ô∏è Nieznane polecenie. Skorzystaj z menu poni≈ºej.",
        "ru": "‚ö†Ô∏è –ö–æ–º–∞–Ω–¥–∞ –Ω–µ —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω–∞. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –º–µ–Ω—é –Ω–∏–∂–µ.",
    },
    "BTN_NEXT": {
        "uk": "‚û°Ô∏è –î–ê–õ–Ü",
        "en": "‚û°Ô∏è NEXT",
        "de": "‚û°Ô∏è WEITER",
        "pl": "‚û°Ô∏è DALEJ",
        "ru": "‚û°Ô∏è –î–ê–õ–ï–ï",
    },
    "BTN_SKIP": {
        "uk": "‚è≠ –ü—Ä–æ–ø—É—Å—Ç–∏—Ç–∏",
        "en": "‚è≠ Skip",
        "de": "‚è≠ √úberspringen",
        "pl": "‚è≠ Pomi≈Ñ",
        "ru": "‚è≠ –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å",
    },
    "INTRO_GREETING_NEW": {
        "uk": "üëã <b>–í—ñ—Ç–∞—é, –∫–æ–ª–µ–≥–æ!</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n–í–∏ —É —Ä–æ–±–æ—á–æ–º—É –ø—Ä–æ—Å—Ç–æ—Ä—ñ Bot.BSG. –¢—É—Ç –∑–±–µ—Ä—ñ–≥–∞—î–º–æ —á–µ–∫–∏, –æ—Ñ–æ—Ä–º–ª—é—î–º–æ –≤–∏–ø–ª–∞—Ç–∏ —Ç–∞ —Ç—Ä–∏–º–∞—î–º–æ –¥–æ–∫—É–º–µ–Ω—Ç–∏ –ø—Ä–æ—î–∫—Ç—É –ø—ñ–¥ —Ä—É–∫–æ—é.\n\n–ù–∞—Ç–∏—Å–Ω—ñ—Ç—å ¬´–î–ê–õ–Ü¬ª, —â–æ–± –ø—Ä–æ–¥–æ–≤–∂–∏—Ç–∏.",
        "en": "üëã <b>Hello, teammate!</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nWelcome to the Bot.BSG workspace. Here we store receipts, track payouts, and keep project documents handy.\n\nPress ‚ÄúNEXT‚Äù to continue.",
        "de": "üëã <b>Hallo, Kollegin oder Kollege!</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nWillkommen im Bot.BSG-Arbeitsbereich. Hier speichern wir Belege, verwalten Auszahlungen und behalten Projektdokumente griffbereit.\n\nDr√ºcken Sie ‚ÄûWEITER‚Äú, um fortzufahren.",
        "pl": "üëã <b>Witaj, wsp√≥≈Çpracowniku!</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nTo przestrze≈Ñ robocza Bot.BSG. Przechowujemy tu paragony, obs≈Çugujemy wyp≈Çaty i mamy dokumenty projektu pod rƒôkƒÖ.\n\nKliknij ‚ÄûDALEJ‚Äù, aby kontynuowaƒá.",
        "ru": "üëã <b>–ü—Ä–∏–≤–µ—Ç, –∫–æ–ª–ª–µ–≥–∞!</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n–í—ã –≤ —Ä–∞–±–æ—á–µ–º –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ Bot.BSG. –ó–¥–µ—Å—å –º—ã —Ö—Ä–∞–Ω–∏–º —á–µ–∫–∏, –æ—Ñ–æ—Ä–º–ª—è–µ–º –≤—ã–ø–ª–∞—Ç—ã –∏ –¥–µ—Ä–∂–∏–º –¥–æ–∫—É–º–µ–Ω—Ç—ã –ø—Ä–æ–µ–∫—Ç–∞ –ø–æ–¥ —Ä—É–∫–æ–π.\n\n–ù–∞–∂–º–∏—Ç–µ ¬´–î–ê–õ–ï–ï¬ª, —á—Ç–æ–±—ã –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å.",
    },
    "INTRO_GREETING_REGISTERED": {
        "uk": "üëã <b>–†–∞–¥–∏–π –≤—ñ—Ç–∞—Ç–∏ –∑–Ω–æ–≤—É!</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n–í–∏ –º–æ–∂–µ—Ç–µ –æ–¥—Ä–∞–∑—É –ø–µ—Ä–µ–π—Ç–∏ –¥–æ –≥–æ–ª–æ–≤–Ω–æ–≥–æ –º–µ–Ω—é, —â–æ–± –ø—Ä–∞—Ü—é–≤–∞—Ç–∏ –∑ —Ä–æ–∑–¥—ñ–ª–∞–º–∏ –±–æ—Ç–∞.\n\n–ù–∞—Ç–∏—Å–Ω—ñ—Ç—å ¬´–î–ê–õ–Ü¬ª, –∞–±–∏ –ø–µ—Ä–µ–π—Ç–∏ –¥–æ –æ—Å–Ω–æ–≤–Ω–∏—Ö –¥—ñ–π.",
        "en": "üëã <b>Welcome back!</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nYou can jump straight to the main menu to work with the bot‚Äôs sections.\n\nPress ‚ÄúNEXT‚Äù to open the main actions.",
        "de": "üëã <b>Willkommen zur√ºck!</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nSie k√∂nnen direkt ins Hauptmen√º wechseln, um mit den Bereichen des Bots zu arbeiten.\n\nDr√ºcken Sie ‚ÄûWEITER‚Äú, um die wichtigsten Aktionen zu √∂ffnen.",
        "pl": "üëã <b>Mi≈Ço zn√≥w Ciƒô widzieƒá!</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nMo≈ºesz od razu przej≈õƒá do menu g≈Ç√≥wnego i korzystaƒá z modu≈Ç√≥w bota.\n\nKliknij ‚ÄûDALEJ‚Äù, aby wy≈õwietliƒá najwa≈ºniejsze opcje.",
        "ru": "üëã <b>–†–∞–¥ —Å–Ω–æ–≤–∞ –≤–∏–¥–µ—Ç—å!</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n–í—ã –º–æ–∂–µ—Ç–µ —Å—Ä–∞–∑—É –ø–µ—Ä–µ–π—Ç–∏ –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é –∏ —Ä–∞–±–æ—Ç–∞—Ç—å —Å —Ä–∞–∑–¥–µ–ª–∞–º–∏ –±–æ—Ç–∞.\n\n–ù–∞–∂–º–∏—Ç–µ ¬´–î–ê–õ–ï–ï¬ª, —á—Ç–æ–±—ã –æ—Ç–∫—Ä—ã—Ç—å –æ—Å–Ω–æ–≤–Ω—ã–µ –¥–µ–π—Å—Ç–≤–∏—è.",
    },
    "INTRO_REG_STEPS": {
        "uk": "üìù <b>–Ø–∫ –ø—Ä–æ–π—Ç–∏ —Ä–µ—î—Å—Ç—Ä–∞—Ü—ñ—é</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n1Ô∏è‚É£ –í–∫–∞–∂—ñ—Ç—å –ø–æ–≤–Ω–µ —ñ–º'—è –æ–¥–Ω–∏–º –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è–º.\n2Ô∏è‚É£ –ü–æ–¥—ñ–ª—ñ—Ç—å—Å—è –Ω–æ–º–µ—Ä–æ–º —Ç–µ–ª–µ—Ñ–æ–Ω—É –∫–Ω–æ–ø–∫–æ—é ¬´üì± –ù–∞–¥—ñ—Å–ª–∞—Ç–∏ –Ω–æ–º–µ—Ä¬ª.\n3Ô∏è‚É£ –ü—ñ—Å–ª—è –ø—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω–Ω—è –≤—ñ–¥–∫—Ä–∏—é—Ç—å—Å—è —á–µ–∫–∏, —Ñ—ñ–Ω–∞–Ω—Å–∏ —Ç–∞ –¥–æ–∫—É–º–µ–Ω—Ç–∏.\n\n–ì–æ—Ç–æ–≤—ñ? –ù–∞—Ç–∏—Å–Ω—ñ—Ç—å ¬´–î–ê–õ–Ü¬ª —Ç–∞ –∑–∞–ø–æ–≤–Ω—ñ—Ç—å –∞–Ω–∫–µ—Ç—É.",
        "en": "üìù <b>Registration steps</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n1Ô∏è‚É£ Send your full name in one message.\n2Ô∏è‚É£ Share your phone number via the ‚Äúüì± Share phone number‚Äù button.\n3Ô∏è‚É£ Once confirmed, you will unlock receipts, finance, and documents.\n\nReady? Press ‚ÄúNEXT‚Äù and complete the form.",
        "de": "üìù <b>So funktioniert die Registrierung</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n1Ô∏è‚É£ Geben Sie Ihren vollst√§ndigen Namen in einer Nachricht an.\n2Ô∏è‚É£ Teilen Sie Ihre Telefonnummer √ºber die Schaltfl√§che ‚Äûüì± Telefonnummer senden‚Äú.\n3Ô∏è‚É£ Nach der Best√§tigung stehen Belege, Finanzen und Dokumente zur Verf√ºgung.\n\nBereit? Dr√ºcken Sie ‚ÄûWEITER‚Äú und f√ºllen Sie das Formular aus.",
        "pl": "üìù <b>Jak przej≈õƒá rejestracjƒô</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n1Ô∏è‚É£ Podaj pe≈Çne imiƒô i nazwisko w jednej wiadomo≈õci.\n2Ô∏è‚É£ Udostƒôpnij numer telefonu przyciskiem ‚Äûüì± Wy≈õlij numer‚Äù.\n3Ô∏è‚É£ Po potwierdzeniu zyskasz dostƒôp do paragon√≥w, finans√≥w i dokument√≥w.\n\nGotowy? Kliknij ‚ÄûDALEJ‚Äù i wype≈Çnij formularz.",
        "ru": "üìù <b>–ö–∞–∫ –ø—Ä–æ–π—Ç–∏ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—é</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n1Ô∏è‚É£ –û—Ç–ø—Ä–∞–≤—å—Ç–µ –ø–æ–ª–Ω–æ–µ –§–ò–û –æ–¥–Ω–∏–º —Å–æ–æ–±—â–µ–Ω–∏–µ–º.\n2Ô∏è‚É£ –ü–æ–¥–µ–ª–∏—Ç–µ—Å—å –Ω–æ–º–µ—Ä–æ–º —Ç–µ–ª–µ—Ñ–æ–Ω–∞ –∫–Ω–æ–ø–∫–æ–π ¬´üì± –û—Ç–ø—Ä–∞–≤–∏—Ç—å –Ω–æ–º–µ—Ä¬ª.\n3Ô∏è‚É£ –ü–æ—Å–ª–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è —Å—Ç–∞–Ω—É—Ç –¥–æ—Å—Ç—É–ø–Ω—ã —á–µ–∫–∏, —Ñ–∏–Ω–∞–Ω—Å—ã –∏ –¥–æ–∫—É–º–µ–Ω—Ç—ã.\n\n–ì–æ—Ç–æ–≤—ã? –ù–∞–∂–º–∏—Ç–µ ¬´–î–ê–õ–ï–ï¬ª –∏ –∑–∞–ø–æ–ª–Ω–∏—Ç–µ –∞–Ω–∫–µ—Ç—É.",
    },
    "INTRO_PROMPT_NAME": {
        "uk": "üìù –í–≤–µ–¥—ñ—Ç—å –ø–æ–≤–Ω–µ –ø—Ä—ñ–∑–≤–∏—â–µ —Ç–∞ —ñ–º'—è –æ–¥–Ω–∏–º –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è–º —É —Ñ–æ—Ä–º–∞—Ç—ñ: –Ü–º'—è –ü—Ä—ñ–∑–≤–∏—â–µ –ü–æ –±–∞—Ç—å–∫–æ–≤—ñ.",
        "en": "üìù Enter your full name in one message using the format: Firstname Lastname Middle name.",
        "de": "üìù Geben Sie Ihren vollst√§ndigen Namen in einer Nachricht ein: Vorname Nachname zweiter Name.",
        "pl": "üìù Wpisz pe≈Çne imiƒô i nazwisko w jednej wiadomo≈õci w formacie: Imiƒô Nazwisko Drugie imiƒô.",
        "ru": "üìù –í–≤–µ–¥–∏—Ç–µ –ø–æ–ª–Ω–æ–µ –§–ò–û –æ–¥–Ω–∏–º —Å–æ–æ–±—â–µ–Ω–∏–µ–º –≤ —Ñ–æ—Ä–º–∞—Ç–µ: –ò–º—è –§–∞–º–∏–ª–∏—è –û—Ç—á–µ—Å—Ç–≤–æ.",
    },
    "INTRO_SECTIONS": {
        "uk": "üìã <b>–ö–ª—é—á–æ–≤—ñ —Ä–æ–∑–¥—ñ–ª–∏</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n‚Ä¢ ¬´üßæ –ß–µ–∫–∏¬ª ‚Äî –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è —Ç–∞ —ñ—Å—Ç–æ—Ä—ñ—è –¥–æ–∫—É–º–µ–Ω—Ç—ñ–≤.\n‚Ä¢ ¬´üíµ –§—ñ–Ω–∞–Ω—Å–∏¬ª ‚Äî —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞, –∑–∞–ø–∏—Ç–∏ —Ç–∞ –ø—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω–Ω—è –≤–∏–ø–ª–∞—Ç.\n‚Ä¢ ¬´üìë –î–æ–∫—É–º–µ–Ω—Ç–∏¬ª ‚Äî —Ñ–∞–π–ª–∏ —Ç–∞ —ñ–Ω—Å—Ç—Ä—É–∫—Ü—ñ—ó —â–æ–¥–æ –ø—Ä–æ—î–∫—Ç—É.\n\n–ù–∞—Ç–∏—Å–Ω—ñ—Ç—å ¬´–î–ê–õ–Ü¬ª, —â–æ–± –ø–µ—Ä–µ–π—Ç–∏ –¥–æ –≥–æ–ª–æ–≤–Ω–æ–≥–æ –º–µ–Ω—é.",
        "en": "üìã <b>Main sections</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n‚Ä¢ ‚Äúüßæ Receipts‚Äù ‚Äî upload and history of documents.\n‚Ä¢ ‚Äúüíµ Finance‚Äù ‚Äî statistics, payout requests, and confirmations.\n‚Ä¢ ‚Äúüìë Documents‚Äù ‚Äî project files and guidelines.\n\nPress ‚ÄúNEXT‚Äù to open the main menu.",
        "de": "üìã <b>Wichtige Bereiche</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n‚Ä¢ ‚Äûüßæ Belege‚Äú ‚Äì Upload und Verlauf der Dokumente.\n‚Ä¢ ‚Äûüíµ Finanzen‚Äú ‚Äì Statistiken, Auszahlungsantr√§ge und Best√§tigungen.\n‚Ä¢ ‚Äûüìë Dokumente‚Äú ‚Äì Projektunterlagen und Richtlinien.\n\nDr√ºcken Sie ‚ÄûWEITER‚Äú, um das Hauptmen√º zu √∂ffnen.",
        "pl": "üìã <b>Najwa≈ºniejsze sekcje</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n‚Ä¢ ‚Äûüßæ Paragony‚Äù ‚Äì wgrywanie i historia dokument√≥w.\n‚Ä¢ ‚Äûüíµ Finanse‚Äù ‚Äì statystyki, wnioski o wyp≈Çatƒô i potwierdzenia.\n‚Ä¢ ‚Äûüìë Dokumenty‚Äù ‚Äì pliki i instrukcje projektowe.\n\nKliknij ‚ÄûDALEJ‚Äù, aby przej≈õƒá do menu g≈Ç√≥wnego.",
        "ru": "üìã <b>–ö–ª—é—á–µ–≤—ã–µ —Ä–∞–∑–¥–µ–ª—ã</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n‚Ä¢ ¬´üßæ –ß–µ–∫–∏¬ª ‚Äî –∑–∞–≥—Ä—É–∑–∫–∞ –∏ –∏—Å—Ç–æ—Ä–∏—è –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤.\n‚Ä¢ ¬´üíµ –§–∏–Ω–∞–Ω—Å—ã¬ª ‚Äî —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞, –∑–∞–ø—Ä–æ—Å—ã –∏ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –≤—ã–ø–ª–∞—Ç.\n‚Ä¢ ¬´üìë –î–æ–∫—É–º–µ–Ω—Ç—ã¬ª ‚Äî —Ñ–∞–π–ª—ã –∏ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ –ø–æ –æ–±—ä–µ–∫—Ç—É.\n\n–ù–∞–∂–º–∏—Ç–µ ¬´–î–ê–õ–ï–ï¬ª, —á—Ç–æ–±—ã –æ—Ç–∫—Ä—ã—Ç—å –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é.",
    },
    "REGISTER_NAME_ERROR": {
        "uk": "‚ùó –ó–¥–∞—î—Ç—å—Å—è, –±—Ä–∞–∫—É—î —á–∞—Å—Ç–∏–Ω–∏ –ü–Ü–ë. –ë—É–¥—å –ª–∞—Å–∫–∞, –≤–∫–∞–∂—ñ—Ç—å —ñ–º'—è, –ø—Ä—ñ–∑–≤–∏—â–µ —Ç–∞ –ø–æ –±–∞—Ç—å–∫–æ–≤—ñ –ø–æ–≤–Ω—ñ—Å—Ç—é.",
        "en": "‚ùó It looks like part of the full name is missing. Please provide first name, last name, and patronymic (if applicable).",
        "de": "‚ùó Es scheint, dass Teile des vollst√§ndigen Namens fehlen. Bitte geben Sie Vorname, Nachname und ggf. zweiten Namen vollst√§ndig an.",
        "pl": "‚ùó WyglƒÖda na to, ≈ºe brakuje czƒô≈õci pe≈Çnego imienia i nazwiska. Podaj imiƒô, nazwisko i, je≈õli dotyczy, drugie imiƒô.",
        "ru": "‚ùó –ü–æ—Ö–æ–∂–µ, –Ω–µ —Ö–≤–∞—Ç–∞–µ—Ç —á–∞—Å—Ç–∏ –§–ò–û. –£–∫–∞–∂–∏—Ç–µ –∏–º—è, —Ñ–∞–º–∏–ª–∏—é –∏ –æ—Ç—á–µ—Å—Ç–≤–æ –ø–æ–ª–Ω–æ—Å—Ç—å—é.",
    },
    "REGISTER_PHONE_PROMPT": {
        "uk": "üìû –ó–∞–ª–∏—à–∏–≤—Å—è –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω—É. –ù–∞—Ç–∏—Å–Ω—ñ—Ç—å ¬´üì± –ù–∞–¥—ñ—Å–ª–∞—Ç–∏ –Ω–æ–º–µ—Ä¬ª, —ñ –±–æ—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –¥–æ–¥–∞—Å—Ç—å –π–æ–≥–æ –¥–æ –∞–Ω–∫–µ—Ç–∏.",
        "en": "üìû We still need your phone number. Tap ‚Äúüì± Share phone number‚Äù and the bot will fill it in automatically.",
        "de": "üìû Uns fehlt noch Ihre Telefonnummer. Tippen Sie auf ‚Äûüì± Telefonnummer senden‚Äú, und der Bot tr√§gt sie automatisch ein.",
        "pl": "üìû Potrzebujemy jeszcze numeru telefonu. Kliknij ‚Äûüì± Wy≈õlij numer‚Äù, a bot uzupe≈Çni go automatycznie.",
        "ru": "üìû –û—Å—Ç–∞–ª—Å—è —Ç–µ–ª–µ—Ñ–æ–Ω –¥–ª—è —Å–≤—è–∑–∏. –ù–∞–∂–º–∏—Ç–µ ¬´üì± –û—Ç–ø—Ä–∞–≤–∏—Ç—å –Ω–æ–º–µ—Ä¬ª, –∏ –±–æ—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø–æ–¥—Å—Ç–∞–≤–∏—Ç –µ–≥–æ –≤ –∞–Ω–∫–µ—Ç—É.",
    },
    "REGISTER_PHONE_ERROR": {
        "uk": "‚ùó –ù–µ –≤–¥–∞–ª–æ—Å—è –æ—Ç—Ä–∏–º–∞—Ç–∏ –Ω–æ–º–µ—Ä. –°–ø—Ä–æ–±—É–π—Ç–µ —â–µ —Ä–∞–∑ –∫–Ω–æ–ø–∫–æ—é ¬´üì± –ù–∞–¥—ñ—Å–ª–∞—Ç–∏ –Ω–æ–º–µ—Ä¬ª.",
        "en": "‚ùó We couldn't read the number. Try again using the ‚Äúüì± Share phone number‚Äù button.",
        "de": "‚ùó Telefonnummer konnte nicht erkannt werden. Versuchen Sie es erneut √ºber die Schaltfl√§che ‚Äûüì± Telefonnummer senden‚Äú.",
        "pl": "‚ùó Nie uda≈Ço siƒô pobraƒá numeru. Spr√≥buj ponownie przyciskiem ‚Äûüì± Wy≈õlij numer‚Äù.",
        "ru": "‚ùó –ù–æ–º–µ—Ä –Ω–µ –ø–æ–ª—É—á–µ–Ω. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑ –∫–Ω–æ–ø–∫–æ–π ¬´üì± –û—Ç–ø—Ä–∞–≤–∏—Ç—å –Ω–æ–º–µ—Ä¬ª.",
    },
    "REGISTER_PHONE_TEXT_PROMPT": {
        "uk": "‚ùó –©–æ–± –ø—Ä–æ–¥–æ–≤–∂–∏—Ç–∏, –≤—ñ–¥–ø—Ä–∞–≤—Ç–µ –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ –∫–Ω–æ–ø–∫–æ—é ¬´üì± –ù–∞–¥—ñ—Å–ª–∞—Ç–∏ –Ω–æ–º–µ—Ä¬ª –Ω–∏–∂—á–µ ‚Äî —Ç–∞–∫ —É–Ω–∏–∫–Ω–µ–º–æ –ø–æ–º–∏–ª–æ–∫.",
        "en": "‚ùó To continue, send your phone number using the ‚Äúüì± Share phone number‚Äù button below to avoid mistakes.",
        "de": "‚ùó Um fortzufahren, senden Sie Ihre Telefonnummer √ºber die Schaltfl√§che ‚Äûüì± Telefonnummer senden‚Äú, um Fehler zu vermeiden.",
        "pl": "‚ùó Aby kontynuowaƒá, wy≈õlij numer telefonu przyciskiem ‚Äûüì± Wy≈õlij numer‚Äù poni≈ºej ‚Äì unikniemy pomy≈Çek.",
        "ru": "‚ùó –ß—Ç–æ–±—ã –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—é, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ –∫–Ω–æ–ø–∫–æ–π ¬´üì± –û—Ç–ø—Ä–∞–≤–∏—Ç—å –Ω–æ–º–µ—Ä¬ª –Ω–∏–∂–µ, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –æ—à–∏–±–æ–∫.",
    },
    "BTN_SEND_PHONE": {
        "uk": "üì± –ù–∞–¥—ñ—Å–ª–∞—Ç–∏ –Ω–æ–º–µ—Ä",
        "en": "üì± Share phone number",
        "de": "üì± Telefonnummer senden",
        "pl": "üì± Wy≈õlij numer",
        "ru": "üì± –û—Ç–ø—Ä–∞–≤–∏—Ç—å –Ω–æ–º–µ—Ä",
    },
    "CHECKS_SECTION_TITLE": {
        "uk": "üßæ <b>–†–æ–∑–¥—ñ–ª —á–µ–∫—ñ–≤</b>",
        "en": "üßæ <b>Receipts section</b>",
        "de": "üßæ <b>Belegbereich</b>",
        "pl": "üßæ <b>Sekcja paragon√≥w</b>",
        "ru": "üßæ <b>–†–∞–∑–¥–µ–ª —á–µ–∫–æ–≤</b>",
    },
    "BTN_BACK_SETTINGS": {
        "uk": "‚¨ÖÔ∏è –ü–æ–≤–µ—Ä–Ω—É—Ç–∏—Å—è",
        "en": "‚¨ÖÔ∏è Back",
        "de": "‚¨ÖÔ∏è Zur√ºck",
        "pl": "‚¨ÖÔ∏è Wr√≥ƒá",
        "ru": "‚¨ÖÔ∏è –ù–∞–∑–∞–¥",
    },
    "CHECKS_MENU_INTRO": {
        "uk": "üßæ <b>–†–æ–∑–¥—ñ–ª —á–µ–∫—ñ–≤</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n–î–æ–¥–∞–≤–∞–π—Ç–µ –Ω–æ–≤—ñ —á–µ–∫–∏, –ø–µ—Ä–µ–≥–ª—è–¥–∞–π—Ç–µ —ñ—Å—Ç–æ—Ä—ñ—é —Ç–∞ –æ–Ω–æ–≤–ª—é–π—Ç–µ —Å—Ç–∞—Ç—É—Å –≤–∏–ø–ª–∞—Ç —É –¥–≤–∞ –∫–ª—ñ–∫–∏.\n–û–±–∏—Ä–∞–π—Ç–µ –¥—ñ—é –∑–∞ –∫–Ω–æ–ø–∫–∞–º–∏ –Ω–∏–∂—á–µ.",
        "en": "üßæ <b>Receipts section</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nUpload new receipts, review history, and update payout status in a couple of taps.\nPick an action using the buttons below.",
        "de": "üßæ <b>Belegbereich</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nLaden Sie neue Belege hoch, pr√ºfen Sie den Verlauf und aktualisieren Sie den Auszahlungsstatus mit wenigen Klicks.\nW√§hlen Sie unten die gew√ºnschte Aktion.",
        "pl": "üßæ <b>Sekcja paragon√≥w</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nDodawaj nowe paragony, przeglƒÖdaj historiƒô i aktualizuj status wyp≈Çat w kilku krokach.\nWybierz odpowiedniƒÖ opcjƒô z przycisk√≥w poni≈ºej.",
        "ru": "üßæ <b>–†–∞–∑–¥–µ–ª —á–µ–∫–æ–≤</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n–î–æ–±–∞–≤–ª—è–π—Ç–µ –Ω–æ–≤—ã–µ —á–µ–∫–∏, –ø—Ä–æ—Å–º–∞—Ç—Ä–∏–≤–∞–π—Ç–µ –∏—Å—Ç–æ—Ä–∏—é –∏ –æ–±–Ω–æ–≤–ª—è–π—Ç–µ —Å—Ç–∞—Ç—É—Å –≤—ã–ø–ª–∞—Ç –≤ –ø–∞—Ä—É –∫–∞—Å–∞–Ω–∏–π.\n–í—ã–±–µ—Ä–∏—Ç–µ –Ω—É–∂–Ω–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ –Ω–∞ –∫–Ω–æ–ø–∫–∞—Ö –Ω–∏–∂–µ.",
    },
    "CHECK_STATS_SUMMARY": {
        "uk": "üìä <b>–û—Å–æ–±–∏—Å—Ç–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ —á–µ–∫–∞—Ö</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nüìÇ –ü—Ä–æ—î–∫—Ç: <b>{project}</b>\nüßæ –í—Å—å–æ–≥–æ —á–µ–∫—ñ–≤: <b>{total_count}</b>\nüí∞ –°—É–º–∞ —á–µ–∫—ñ–≤: <b>{total_amount} –≥—Ä–Ω</b>\nüí∏ –û–ø–ª–∞—á–µ–Ω–æ –∫–æ–º–ø–∞–Ω—ñ—î—é: <b>{paid_amount} –≥—Ä–Ω</b> ({paid_count} —à—Ç.)\n‚è≥ –û—á—ñ–∫—É—î –æ–ø–ª–∞—Ç–∏: <b>{unpaid_amount} –≥—Ä–Ω</b> ({unpaid_count} —à—Ç.){pending_line}",
        "en": "üìä <b>Your receipt statistics</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nüìÇ Project: <b>{project}</b>\nüßæ Total receipts: <b>{total_count}</b>\nüí∞ Receipt amount: <b>{total_amount} UAH</b>\nüí∏ Paid by the company: <b>{paid_amount} UAH</b> ({paid_count} items)\n‚è≥ Awaiting payment: <b>{unpaid_amount} UAH</b> ({unpaid_count} items){pending_line}",
        "de": "üìä <b>Ihre Belegstatistik</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nüìÇ Projekt: <b>{project}</b>\nüßæ Belege insgesamt: <b>{total_count}</b>\nüí∞ Belegsumme: <b>{total_amount} UAH</b>\nüí∏ Vom Unternehmen bezahlt: <b>{paid_amount} UAH</b> ({paid_count} St√ºck)\n‚è≥ Ausstehend: <b>{unpaid_amount} UAH</b> ({unpaid_count} St√ºck){pending_line}",
        "pl": "üìä <b>Twoja statystyka paragon√≥w</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nüìÇ Projekt: <b>{project}</b>\nüßæ Razem paragon√≥w: <b>{total_count}</b>\nüí∞ Suma paragon√≥w: <b>{total_amount} UAH</b>\nüí∏ Op≈Çacone przez firmƒô: <b>{paid_amount} UAH</b> ({paid_count} szt.)\n‚è≥ Do op≈Çacenia: <b>{unpaid_amount} UAH</b> ({unpaid_count} szt.){pending_line}",
        "ru": "üìä <b>–õ–∏—á–Ω–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ —á–µ–∫–∞–º</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nüìÇ –ü—Ä–æ–µ–∫—Ç: <b>{project}</b>\nüßæ –í—Å–µ–≥–æ —á–µ–∫–æ–≤: <b>{total_count}</b>\nüí∞ –°—É–º–º–∞ —á–µ–∫–æ–≤: <b>{total_amount} –≥—Ä–Ω</b>\nüí∏ –û–ø–ª–∞—á–µ–Ω–æ –∫–æ–º–ø–∞–Ω–∏–µ–π: <b>{paid_amount} –≥—Ä–Ω</b> ({paid_count} —à—Ç.)\n‚è≥ –û–∂–∏–¥–∞–µ—Ç –æ–ø–ª–∞—Ç—ã: <b>{unpaid_amount} –≥—Ä–Ω</b> ({unpaid_count} —à—Ç.){pending_line}",
    },
    "CHECK_STATS_PENDING": {
        "uk": "\n‚ùî –°—Ç–∞—Ç—É—Å –Ω–µ –≤–∫–∞–∑–∞–Ω–æ: <b>{amount} –≥—Ä–Ω</b> ({count} —à—Ç.)",
        "en": "\n‚ùî Status not specified: <b>{amount} UAH</b> ({count} items)",
        "de": "\n‚ùî Status nicht angegeben: <b>{amount} UAH</b> ({count} St√ºck)",
        "pl": "\n‚ùî Status nieokre≈õlony: <b>{amount} UAH</b> ({count} szt.)",
        "ru": "\n‚ùî –°—Ç–∞—Ç—É—Å –Ω–µ —É–∫–∞–∑–∞–Ω: <b>{amount} –≥—Ä–Ω</b> ({count} —à—Ç.)",
    },
    "CHECK_STATS_EMPTY": {
        "uk": "\n–£ –≤–∞—Å —â–µ –Ω–µ–º–∞—î –∑–±–µ—Ä–µ–∂–µ–Ω–∏—Ö —á–µ–∫—ñ–≤. –î–æ–¥–∞–π—Ç–µ –ø–µ—Ä—à–∏–π —á–µ—Ä–µ–∑ –∫–Ω–æ–ø–∫—É ¬´üì∑ –î–æ–¥–∞—Ç–∏ —á–µ–∫¬ª.",
        "en": "\nYou haven't saved any receipts yet. Use ‚Äúüì∑ Add receipt‚Äù to upload the first one.",
        "de": "\nSie haben noch keine Belege gespeichert. F√ºgen Sie den ersten √ºber ‚Äûüì∑ Beleg hinzuf√ºgen‚Äú hinzu.",
        "pl": "\nNie masz jeszcze ≈ºadnych paragon√≥w. Dodaj pierwszy przyciskiem ‚Äûüì∑ Dodaj paragon‚Äù.",
        "ru": "\n–£ –≤–∞—Å –µ—â—ë –Ω–µ—Ç —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—ã—Ö —á–µ–∫–æ–≤. –î–æ–±–∞–≤—å—Ç–µ –ø–µ—Ä–≤—ã–π —á–µ—Ä–µ–∑ –∫–Ω–æ–ø–∫—É ¬´üì∑ –î–æ–±–∞–≤–∏—Ç—å —á–µ–∫¬ª.",
    },
    "NP_MENU_TITLE": {
        "uk": "üìÆ <b>Nova Poshta</b>\\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\\n–Ñ–¥–∏–Ω–µ –º–µ–Ω—é –¥–ª—è –ø–æ—à—É–∫—É —Ç–∞ —Å—É–ø—Ä–æ–≤–æ–¥—É –Ω–∞–∫–ª–∞–¥–Ω–∏—Ö. –°–∫–æ—Ä–∏—Å—Ç–∞–π—Ç–µ—Å—å –∫–Ω–æ–ø–∫–∞–º–∏ –Ω–∏–∂—á–µ, —â–æ–± –∑–Ω–∞–π—Ç–∏ –≤—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–Ω—è, –ø–µ—Ä–µ–≥–ª—è–Ω—É—Ç–∏ —ñ—Å—Ç–æ—Ä—ñ—é, –Ω–æ—Ç–∞—Ç–∫–∏ —á–∏ –ø–æ—Å–∏–ª–∫–∏ –≤—ñ–¥ –∫–æ–º–ø–∞–Ω—ñ—ó.",
        "en": "üìÆ <b>Nova Poshta</b>\\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\\nYour central hub for parcel tracking. Use the buttons below to look up TTNs, reopen history, manage notes, and review company deliveries.",
        "de": "üìÆ <b>Nova Poshta</b>\\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\\nZentrale Schaltstelle f√ºr Sendungsnummern. Verwenden Sie die Schaltfl√§chen unten, um TTN zu suchen, den Verlauf zu √∂ffnen, Notizen zu pflegen und Firmensendungen einzusehen.",
        "pl": "üìÆ <b>Nova Poshta</b>\\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\\nPanel do pracy z przesy≈Çkami. Przyciski poni≈ºej umo≈ºliwiajƒÖ wyszukiwanie TTN, podglƒÖd historii, notatek oraz paczek od firmy.",
        "ru": "üìÆ <b>Nova Poshta</b>\\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\\n–¶–µ–Ω—Ç—Ä–∞–ª—å–Ω–æ–µ –º–µ–Ω—é –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –Ω–∞–∫–ª–∞–¥–Ω—ã–º–∏. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫–∏ –Ω–∏–∂–µ, —á—Ç–æ–±—ã –∏—Å–∫–∞—Ç—å –¢–¢–ù, –æ—Ç–∫—Ä—ã–≤–∞—Ç—å –∏—Å—Ç–æ—Ä–∏—é, –∑–∞–º–µ—Ç–∫–∏ –∏ —Ñ–∏—Ä–º–µ–Ω–Ω—ã–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∏—è.",
    },
    "NP_INTERFACE_TEXT": {
        "uk": "üìò <b>–Ø–∫ –ø—Ä–∞—Ü—é–≤–∞—Ç–∏ –∑ —Ä–æ–∑–¥—ñ–ª–æ–º</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n‚Ä¢ ¬´üîç –ü–æ—à—É–∫ –¢–¢–ù¬ª ‚Äî –≤–≤–µ–¥—ñ—Ç—å –Ω–æ–º–µ—Ä —ñ –æ–¥—Ä–∞–∑—É –æ—Ç—Ä–∏–º–∞–π—Ç–µ –∫–≤–∏—Ç–∞–Ω—Ü—ñ—é –∑ –æ–Ω–æ–≤–ª–µ–Ω–∏–º —Å—Ç–∞—Ç—É—Å–æ–º.\n‚Ä¢ ¬´üïì –Ü—Å—Ç–æ—Ä—ñ—è¬ª ‚Äî —à–≤–∏–¥–∫–∏–π –¥–æ—Å—Ç—É–ø –¥–æ –æ—Å—Ç–∞–Ω–Ω—ñ—Ö –ø–µ—Ä–µ–≥–ª—è–¥—ñ–≤.\n‚Ä¢ ¬´‚≠ê –í—ñ–¥–∑–Ω–∞—á–µ–Ω—ñ¬ª ‚Äî –∑–±–µ—Ä—ñ–≥–∞–π—Ç–µ –≤–∞–∂–ª–∏–≤—ñ –Ω–∞–∫–ª–∞–¥–Ω—ñ –ø—ñ–¥ —Ä—É–∫–æ—é.\n‚Ä¢ ¬´üè¢ –ü–æ—Å–∏–ª–∫–∏ BSG¬ª ‚Äî –Ω–∞–∫–ª–∞–¥–Ω—ñ, —è–∫—ñ –ø–µ—Ä–µ–¥–∞–≤ –∞–¥–º—ñ–Ω—ñ—Å—Ç—Ä–∞—Ç–æ—Ä –∫–æ–º–ø–∞–Ω—ñ—ó.\n‚Ä¢ ¬´üì• –û—Ç—Ä–∏–º–∞–Ω—ñ BSG¬ª ‚Äî –ø—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω—ñ –≤—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–Ω—è, —è–∫—ñ –≤–∂–µ –∑–∞–∫—Ä–∏—Ç—ñ.\n‚Ä¢ –î–æ–¥–∞–≤–∞–π—Ç–µ –æ—Å–æ–±–∏—Å—Ç—ñ –∫–æ–º–µ–Ω—Ç–∞—Ä—ñ –¥–æ –¢–¢–ù –ø—Ä—è–º–æ —É –∫–∞—Ä—Ç—Ü—ñ ‚Äî –≤–æ–Ω–∏ –≤—ñ–¥–æ–±—Ä–∞–∂–∞—é—Ç—å—Å—è –ø—ñ–¥ –∫–≤–∏—Ç–∞–Ω—Ü—ñ—î—é.\n\n–°–∫–æ—Ä–∏—Å—Ç–∞–π—Ç–µ—Å—å ¬´‚ùå –°–∫–∞—Å—É–≤–∞—Ç–∏¬ª, —â–æ–± –ø–æ–≤–µ—Ä–Ω—É—Ç–∏—Å—è –≤ —Ü–µ –º–µ–Ω—é.",
        "en": "üìò <b>How to use this section</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n‚Ä¢ ‚Äúüîç Search by TTN‚Äù ‚Äî enter a number and get the refreshed receipt.\n‚Ä¢ ‚Äúüïì History‚Äù ‚Äî reopen your latest lookups with one tap.\n‚Ä¢ ‚Äú‚≠ê Bookmarked‚Äù ‚Äî keep priority shipments within reach.\n‚Ä¢ ‚Äúüè¢ BSG parcels‚Äù ‚Äî TTNs forwarded by the team.\n‚Ä¢ ‚Äúüì• Received BSG‚Äù ‚Äî deliveries already confirmed.\n‚Ä¢ Add personal comments to any TTN from its card ‚Äî they stay under the receipt for quick reference.\n\nTap ‚Äú‚ùå Cancel‚Äù any time to return here.",
        "de": "üìò <b>So nutzen Sie den Bereich</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n‚Ä¢ ‚Äûüîç TTN suchen‚Äú ‚Äì Nummer eingeben und aktualisierten Beleg erhalten.\n‚Ä¢ ‚Äûüïì Verlauf‚Äú ‚Äì letzte Abfragen sofort erneut √∂ffnen.\n‚Ä¢ ‚Äû‚≠ê Markiert‚Äú ‚Äì wichtige Sendungen griffbereit halten.\n‚Ä¢ ‚Äûüè¢ BSG-Sendungen‚Äú ‚Äì Nummern, die das Team zugewiesen hat.\n‚Ä¢ ‚Äûüì• Erhaltene BSG‚Äú ‚Äì bereits best√§tigte Lieferungen.\n‚Ä¢ F√ºgen Sie Kommentare direkt in der Sendungskarte hinzu ‚Äì sie erscheinen unter dem Beleg.\n\nMit ‚Äû‚ùå Abbrechen‚Äú kehren Sie jederzeit zur√ºck.",
        "pl": "üìò <b>Jak korzystaƒá z panelu</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n‚Ä¢ ‚Äûüîç Szukaj TTN‚Äù ‚Äì wpisz numer i otrzymaj od≈õwie≈ºony podglƒÖd.\n‚Ä¢ ‚Äûüïì Historia‚Äù ‚Äì szybki powr√≥t –¥–æ ostatnich wyszukiwa≈Ñ.\n‚Ä¢ ‚Äû‚≠ê Oznaczone‚Äù ‚Äì –Ω–∞–πwa≈ºniejsze przesy≈Çki –ø–æ–¥ rƒôkƒÖ.\n‚Ä¢ ‚Äûüè¢ Przesy≈Çki BSG‚Äù ‚Äì numery przekazane przez administracjƒô.\n‚Ä¢ ‚Äûüì• Odebrane BSG‚Äù ‚Äì przesy≈Çki ju≈º –ø–æ—Çwier–¥zone.\n‚Ä¢ Dodawaj komentarze bezpo≈õrednio w karcie TTN ‚Äì pojawiƒÖ siƒô pod potwierdzeniem.\n\nPrzycisk ‚Äû‚ùå Anuluj‚Äù zawsze wraca –¥–æ tego –º–µ–Ω—é.",
        "ru": "üìò <b>–ö–∞–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è —Ä–∞–∑–¥–µ–ª–æ–º</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n‚Ä¢ ¬´üîç –ü–æ–∏—Å–∫ –¢–¢–ù¬ª ‚Äî –≤–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä –∏ —Å—Ä–∞–∑—É –ø–æ–ª—É—á–∏—Ç–µ –æ–±–Ω–æ–≤–ª—ë–Ω–Ω—ã–π —á–µ–∫.\n‚Ä¢ ¬´üïì –ò—Å—Ç–æ—Ä–∏—è¬ª ‚Äî –±—ã—Å—Ç—Ä—ã–π –¥–æ—Å—Ç—É–ø –∫ –ø–æ—Å–ª–µ–¥–Ω–∏–º –∑–∞–ø—Ä–æ—Å–∞–º.\n‚Ä¢ ¬´‚≠ê –û—Ç–º–µ—á–µ–Ω–Ω—ã–µ¬ª ‚Äî –¥–µ—Ä–∂–∏—Ç–µ –≤–∞–∂–Ω—ã–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∏—è –ø–æ–¥ —Ä—É–∫–æ–π.\n‚Ä¢ ¬´üè¢ –ü–æ—Å—ã–ª–∫–∏ BSG¬ª ‚Äî –Ω–æ–º–µ—Ä–∞, –∫–æ—Ç–æ—Ä—ã–µ –ø–µ—Ä–µ–¥–∞–ª –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä –∫–æ–º–ø–∞–Ω–∏–∏.\n‚Ä¢ ¬´üì• –ü–æ–ª—É—á–µ–Ω–Ω—ã–µ BSG¬ª ‚Äî —É–∂–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥—ë–Ω–Ω—ã–µ –¥–æ—Å—Ç–∞–≤–∫–∏.\n‚Ä¢ –î–æ–±–∞–≤–ª—è–π—Ç–µ –ª–∏—á–Ω—ã–µ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ –ø—Ä—è–º–æ –≤ –∫–∞—Ä—Ç–æ—á–∫–µ –¢–¢–ù ‚Äî –æ–Ω–∏ –±—É–¥—É—Ç –ø–æ–∫–∞–∑–∞–Ω—ã –ø–æ–¥ –∫–≤–∏—Ç–∞–Ω—Ü–∏–µ–π.\n\n–ù–∞–∂–º–∏—Ç–µ ¬´‚ùå –û—Ç–º–µ–Ω–∏—Ç—å¬ª, —á—Ç–æ–±—ã –≤–µ—Ä–Ω—É—Ç—å—Å—è –≤ —ç—Ç–æ –º–µ–Ω—é.",
    },
    "NP_PROMPT_TTN": {
        "uk": "‚úâÔ∏è –ù–∞–¥—ñ—à–ª—ñ—Ç—å –Ω–æ–º–µ—Ä –Ω–∞–∫–ª–∞–¥–Ω–æ—ó –æ–¥–Ω–∏–º –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è–º (–¥–æ–ø—É—Å–∫–∞—é—Ç—å—Å—è —Ü–∏—Ñ—Ä–∏ —Ç–∞ –ª—ñ—Ç–µ—Ä–∏). –ö–Ω–æ–ø–∫–∞ ¬´‚ùå –°–∫–∞—Å—É–≤–∞—Ç–∏¬ª –ø–æ–≤–µ—Ä—Ç–∞—î –¥–æ –º–µ–Ω—é.",
        "en": "‚úâÔ∏è Send the TTN as a single message (digits and letters only). Use ‚Äú‚ùå Cancel‚Äù to return to the menu.",
        "de": "‚úâÔ∏è Senden Sie die TTN als einzelne Nachricht (Ziffern/Buchstaben). Mit ‚Äû‚ùå Abbrechen‚Äú geht es zur√ºck ins Men√º.",
        "pl": "‚úâÔ∏è Wy≈õlij numer TTN w jednej wiadomo≈õci (cyfry i litery). ‚Äû‚ùå Anuluj‚Äù wraca do menu.",
        "ru": "‚úâÔ∏è –û—Ç–ø—Ä–∞–≤—å—Ç–µ –Ω–æ–º–µ—Ä –¢–¢–ù –æ–¥–Ω–∏–º —Å–æ–æ–±—â–µ–Ω–∏–µ–º (—Ü–∏—Ñ—Ä—ã –∏ –±—É–∫–≤—ã). ¬´‚ùå –û—Ç–º–µ–Ω–∏—Ç—å¬ª –≤–µ—Ä–Ω—ë—Ç –≤ –º–µ–Ω—é.",
    },
    "NP_SEARCH_PROGRESS": {
        "uk": "‚è≥ –û—Ç—Ä–∏–º—É—é —Å—Ç–∞—Ç—É—Å –Ω–∞–∫–ª–∞–¥–Ω–æ—ó, –∑–∞—á–µ–∫–∞–π—Ç–µ –∫—ñ–ª—å–∫–∞ —Å–µ–∫—É–Ω–¥‚Ä¶",
        "en": "‚è≥ Fetching parcel status, please wait‚Ä¶",
        "de": "‚è≥ Der Sendungsstatus wird abgerufen, bitte warten‚Ä¶",
        "pl": "‚è≥ Pobieram status przesy≈Çki, proszƒô czekaƒá‚Ä¶",
        "ru": "‚è≥ –ü–æ–ª—É—á–∞–µ–º —Å—Ç–∞—Ç—É—Å –Ω–∞–∫–ª–∞–¥–Ω–æ–π, –ø–æ–¥–æ–∂–¥–∏—Ç–µ‚Ä¶",
    },
    "NP_SEARCH_NOT_FOUND": {
        "uk": "‚ùå –ù–∞–∫–ª–∞–¥–Ω—É {ttn} –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ. –ü–µ—Ä–µ–≤—ñ—Ä—Ç–µ –Ω–æ–º–µ—Ä —ñ —Å–ø—Ä–æ–±—É–π—Ç–µ —â–µ —Ä–∞–∑.",
        "en": "‚ùå TTN {ttn} was not found. Please check the number and try again.",
        "de": "‚ùå Die Sendung {ttn} wurde nicht gefunden. Bitte pr√ºfen Sie die Nummer und versuchen Sie es erneut.",
        "pl": "‚ùå Nie znaleziono przesy≈Çki {ttn}. Sprawd≈∫ numer i spr√≥buj ponownie.",
        "ru": "‚ùå –ù–∞–∫–ª–∞–¥–Ω–∞—è {ttn} –Ω–µ –Ω–∞–π–¥–µ–Ω–∞. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –Ω–æ–º–µ—Ä –∏ –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.",
    },
    "NP_SEARCH_ERROR": {
        "uk": "‚ö†Ô∏è –ù–µ –≤–¥–∞–ª–æ—Å—è –æ—Ç—Ä–∏–º–∞—Ç–∏ –¥–∞–Ω—ñ: {error}",
        "en": "‚ö†Ô∏è Could not retrieve data: {error}",
        "de": "‚ö†Ô∏è Daten konnten nicht abgerufen werden: {error}",
        "pl": "‚ö†Ô∏è Nie uda≈Ço siƒô pobraƒá danych: {error}",
        "ru": "‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ: {error}",
    },
    "NP_REFRESH_NOT_POSSIBLE": {
        "uk": "‚ö†Ô∏è –ù–µ–º–æ–∂–ª–∏–≤–æ –æ–Ω–æ–≤–∏—Ç–∏ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è. –°–ø—Ä–æ–±—É–π—Ç–µ –ø—ñ–∑–Ω—ñ—à–µ.",
        "en": "‚ö†Ô∏è Unable to refresh this message. Please try again later.",
        "de": "‚ö†Ô∏è Nachricht kann nicht aktualisiert werden. Bitte sp√§ter erneut versuchen.",
        "pl": "‚ö†Ô∏è Nie mo≈ºna od≈õwie≈ºyƒá tej wiadomo≈õci. Spr√≥buj ponownie p√≥≈∫niej.",
        "ru": "‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –æ–±–Ω–æ–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.",
    },
    "NP_HISTORY_EMPTY": {
        "uk": "üïì –Ü—Å—Ç–æ—Ä—ñ—è –ø–æ—Ä–æ–∂–Ω—è. –í–∏–∫–æ–Ω–∞–π—Ç–µ –ø–æ—à—É–∫, —â–æ–± –ø–æ–±–∞—á–∏—Ç–∏ –æ—Å—Ç–∞–Ω–Ω—ñ –¢–¢–ù.",
        "en": "üïì History is empty. Run a search to see recent TTNs.",
        "de": "üïì Noch keine Historie. F√ºhren Sie eine Suche aus, um TTN anzuzeigen.",
        "pl": "üïì Historia jest pusta. Wykonaj wyszukiwanie, aby zobaczyƒá TTN.",
        "ru": "üïì –ò—Å—Ç–æ—Ä–∏—è –ø—É—Å—Ç–∞. –í—ã–ø–æ–ª–Ω–∏—Ç–µ –ø–æ–∏—Å–∫, —á—Ç–æ–±—ã —É–≤–∏–¥–µ—Ç—å –ø–æ—Å–ª–µ–¥–Ω–∏–µ –¢–¢–ù.",
    },
    "NP_HISTORY_HEADER": {
        "uk": "üïì <b>–Ü—Å—Ç–æ—Ä—ñ—è –ø–æ—à—É–∫—É</b>\\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\\n–ù–∞—Ç–∏—Å–Ω—ñ—Ç—å –Ω–æ–º–µ—Ä –Ω–∏–∂—á–µ, —â–æ–± –≤—ñ–¥–∫—Ä–∏—Ç–∏ –∫–≤–∏—Ç–∞–Ω—Ü—ñ—é —Ç–∞ –ø–æ–±–∞—á–∏—Ç–∏ –∞–∫—Ç—É–∞–ª—å–Ω–∏–π —Å—Ç–∞—Ç—É—Å.",
        "en": "üïì <b>Search history</b>\\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\\nTap a TTN below to reopen its receipt with the latest status.",
        "de": "üïì <b>Suchverlauf</b>\\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\\nTippen Sie auf eine TTN, um den Beleg mit aktuellem Status zu √∂ffnen.",
        "pl": "üïì <b>Historia wyszukiwa≈Ñ</b>\\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\\nWybierz TTN, aby otworzyƒá podglƒÖd ze ≈õwie≈ºym statusem.",
        "ru": "üïì <b>–ò—Å—Ç–æ—Ä–∏—è –ø–æ–∏—Å–∫–æ–≤</b>\\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\\n–ù–∞–∂–º–∏—Ç–µ –Ω–∞ –¢–¢–ù –Ω–∏–∂–µ, —á—Ç–æ–±—ã –æ—Ç–∫—Ä—ã—Ç—å —á–µ–∫ —Å –∞–∫—Ç—É–∞–ª—å–Ω—ã–º —Å—Ç–∞—Ç—É—Å–æ–º.",
    },
    "NP_BOOKMARKS_EMPTY": {
        "uk": "‚≠ê –í–∏ —â–µ –Ω–µ –ø–æ–∑–Ω–∞—á–∞–ª–∏ –Ω–∞–∫–ª–∞–¥–Ω—ñ. –î–æ–¥–∞–π—Ç–µ –≤–ø–æ–¥–æ–±–∞–Ω—É –¢–¢–ù –ø—ñ–¥ —á–∞—Å –ø–æ—à—É–∫—É.",
        "en": "‚≠ê You haven't bookmarked any TTNs yet. Bookmark a result while viewing a search.",
        "de": "‚≠ê Sie haben noch keine TTN markiert. Markieren Sie Ergebnisse w√§hrend der Suche.",
        "pl": "‚≠ê Nie oznaczono jeszcze ≈ºadnej TTN. Dodaj jƒÖ do oznaczonych podczas przeglƒÖdania wynik√≥w.",
        "ru": "‚≠ê –£ –≤–∞—Å –µ—â—ë –Ω–µ—Ç –æ—Ç–º–µ—á–µ–Ω–Ω—ã—Ö –¢–¢–ù. –î–æ–±–∞–≤—å—Ç–µ –Ω–∞–∫–ª–∞–¥–Ω—É—é –≤ –∏–∑–±—Ä–∞–Ω–Ω–æ–µ –≤–æ –≤—Ä–µ–º—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞.",
    },
    "NP_BOOKMARKS_HEADER": {
        "uk": "‚≠ê <b>–í—ñ–¥–∑–Ω–∞—á–µ–Ω—ñ –Ω–∞–∫–ª–∞–¥–Ω—ñ</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n–û–±–µ—Ä—ñ—Ç—å –¢–¢–ù, —â–æ–± –º–∏—Ç—Ç—î–≤–æ –≤—ñ–¥–∫—Ä–∏—Ç–∏ —ó—ó –∫–≤–∏—Ç–∞–Ω—Ü—ñ—é —Ç–∞ –Ω–æ—Ç–∞—Ç–∫–∏.",
        "en": "‚≠ê <b>Bookmarked TTNs</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nSelect a TTN to instantly open its receipt and notes.",
        "de": "‚≠ê <b>Markierte TTN</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nW√§hlen Sie eine TTN, um Beleg und Notizen sofort zu √∂ffnen.",
        "pl": "‚≠ê <b>Oznaczone TTN</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nWybierz TTN, aby szybko zobaczyƒá podglƒÖd i notatki.",
        "ru": "‚≠ê <b>–û—Ç–º–µ—á–µ–Ω–Ω—ã–µ –Ω–∞–∫–ª–∞–¥–Ω—ã–µ</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n–í—ã–±–µ—Ä–∏—Ç–µ –¢–¢–ù, —á—Ç–æ–±—ã —Å—Ä–∞–∑—É –æ—Ç–∫—Ä—ã—Ç—å —á–µ–∫ –∏ –∑–∞–º–µ—Ç–∫–∏."
    },
    "NP_NOTE_PROMPT": {
        "uk": "üí¨ –ù–∞–ø–∏—à—ñ—Ç—å –∫–æ–º–µ–Ω—Ç–∞—Ä –¥–ª—è –¢–¢–ù {ttn} —Ç–∞ –Ω–∞–¥—ñ—à–ª—ñ—Ç—å –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è–º. –©–æ–± —Å–∫–∞—Å—É–≤–∞—Ç–∏, —Å–∫–æ—Ä–∏—Å—Ç–∞–π—Ç–µ—Å—å ¬´‚ùå –°–∫–∞—Å—É–≤–∞—Ç–∏¬ª –∞–±–æ –Ω–∞–ø–∏—à—ñ—Ç—å ¬´–≤—ñ–¥–º—ñ–Ω–∞¬ª.",
        "en": "üí¨ Type a comment for TTN {ttn} and send it as a message. Use ‚Äú‚ùå Cancel‚Äù or type ‚Äúcancel‚Äù to abort.",
        "de": "üí¨ Schreiben Sie eine Notiz f√ºr TTN {ttn} und senden Sie sie als Nachricht. Mit ‚Äû‚ùå Abbrechen‚Äú oder dem Wort ‚Äûabbrechen‚Äú beenden.",
        "pl": "üí¨ Napisz komentarz do TTN {ttn} i wy≈õlij wiadomo≈õƒá. U≈ºyj ‚Äû‚ùå Anuluj‚Äù lub wpisz ‚Äûanuluj‚Äù, aby przerwaƒá.",
        "ru": "üí¨ –ù–∞–ø–∏—à–∏—Ç–µ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –¥–ª—è –¢–¢–ù {ttn} –∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ–º. –ú–æ–∂–Ω–æ –æ—Ç–º–µ–Ω–∏—Ç—å —á–µ—Ä–µ–∑ ¬´‚ùå –û—Ç–º–µ–Ω–∏—Ç—å¬ª –∏–ª–∏ —Å–ª–æ–≤–æ ¬´–æ—Ç–º–µ–Ω–∞¬ª.",
    },
    "NP_NOTE_CANCELLED": {
        "uk": "‚ÑπÔ∏è –î–æ–¥–∞–≤–∞–Ω–Ω—è –∫–æ–º–µ–Ω—Ç–∞—Ä—è —Å–∫–∞—Å–æ–≤–∞–Ω–æ.",
        "en": "‚ÑπÔ∏è Comment cancelled.",
        "de": "‚ÑπÔ∏è Kommentar verworfen.",
        "pl": "‚ÑπÔ∏è Dodawanie komentarza przerwano.",
        "ru": "‚ÑπÔ∏è –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –Ω–µ —Å–æ—Ö—Ä–∞–Ω—ë–Ω.",
    },
    "NP_NOTE_SAVED": {
        "uk": "‚úÖ –ö–æ–º–µ–Ω—Ç–∞—Ä –∑–±–µ—Ä–µ–∂–µ–Ω–æ.",
        "en": "‚úÖ Comment saved.",
        "de": "‚úÖ Kommentar gespeichert.",
        "pl": "‚úÖ Komentarz zapisano.",
        "ru": "‚úÖ –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π —Å–æ—Ö—Ä–∞–Ω—ë–Ω.",
    },
    "NP_COMMENT_SECTION_TITLE": {
        "uk": "üí¨ –ö–æ–º–µ–Ω—Ç–∞—Ä—ñ ({count})",
        "en": "üí¨ Comments ({count})",
        "de": "üí¨ Kommentare ({count})",
        "pl": "üí¨ Komentarze ({count})",
        "ru": "üí¨ –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ ({count})",
    },
    "NP_BOOKMARK_ADDED": {
        "uk": "‚úÖ –ù–∞–∫–ª–∞–¥–Ω—É –¥–æ–¥–∞–Ω–æ –¥–æ –≤—ñ–¥–∑–Ω–∞—á–µ–Ω–∏—Ö.",
        "en": "‚úÖ TTN added to bookmarks.",
        "de": "‚úÖ TTN wurde markiert.",
        "pl": "‚úÖ TTN dodano do oznaczonych.",
        "ru": "‚úÖ –ù–∞–∫–ª–∞–¥–Ω–∞—è –¥–æ–±–∞–≤–ª–µ–Ω–∞ –≤ –æ—Ç–º–µ—á–µ–Ω–Ω—ã–µ.",
    },
    "NP_BOOKMARK_REMOVED": {
        "uk": "‚úÖ –ù–∞–∫–ª–∞–¥–Ω—É –ø—Ä–∏–±—Ä–∞–Ω–æ –∑ –≤—ñ–¥–∑–Ω–∞—á–µ–Ω–∏—Ö.",
        "en": "‚úÖ TTN removed from bookmarks.",
        "de": "‚úÖ Markierung f√ºr die TTN entfernt.",
        "pl": "‚úÖ TTN usuniƒôto z oznaczonych.",
        "ru": "‚úÖ –ù–∞–∫–ª–∞–¥–Ω–∞—è —É–¥–∞–ª–µ–Ω–∞ –∏–∑ –æ—Ç–º–µ—á–µ–Ω–Ω—ã—Ö.",
    },
    "NP_ASSIGN_PROMPT_TTN": {
        "uk": "üì¨ –í–≤–µ–¥—ñ—Ç—å –Ω–æ–º–µ—Ä –¢–¢–ù, —è–∫—É –ø–æ—Ç—Ä—ñ–±–Ω–æ –∑–∞–∫—Ä—ñ–ø–∏—Ç–∏ –∑–∞ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–µ–º. ¬´‚ùå –°–∫–∞—Å—É–≤–∞—Ç–∏¬ª –ø–æ–≤–µ—Ä—Ç–∞—î –¥–æ –º–µ–Ω—é.",
        "en": "üì¨ Enter the TTN you want to assign to a user. Press ‚Äú‚ùå Cancel‚Äù to return.",
        "de": "üì¨ Geben Sie die TTN ein, die einem Nutzer zugeordnet werden soll. Mit ‚Äû‚ùå Abbrechen‚Äú zur√ºck zum Men√º.",
        "pl": "üì¨ Podaj numer TTN, kt√≥ry chcesz przypisaƒá u≈ºytkownikowi. ‚Äû‚ùå Anuluj‚Äù wraca do menu.",
        "ru": "üì¨ –í–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä –¢–¢–ù, –∫–æ—Ç–æ—Ä—ã–π –Ω—É–∂–Ω–æ –∑–∞–∫—Ä–µ–ø–∏—Ç—å –∑–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º. ¬´‚ùå –û—Ç–º–µ–Ω–∏—Ç—å¬ª –≤–µ—Ä–Ω—ë—Ç –≤ –º–µ–Ω—é.",
    },
    "NP_ASSIGN_PROMPT_USER": {
        "uk": "üë§ –û–±–µ—Ä—ñ—Ç—å –æ—Ç—Ä–∏–º—É–≤–∞—á–∞ –∑—ñ —Å–ø–∏—Å–∫—É –Ω–∏–∂—á–µ –∞–±–æ –≤–≤–µ–¥—ñ—Ç—å –π–æ–≥–æ BSU/ID. ¬´‚ùå –°–∫–∞—Å—É–≤–∞—Ç–∏¬ª –∑—É–ø–∏–Ω—è—î –æ–ø–µ—Ä–∞—Ü—ñ—é.",
        "en": "üë§ Pick the recipient from the list below or type their BSU/ID. Use ‚Äú‚ùå Cancel‚Äù to stop.",
        "de": "üë§ W√§hlen Sie den Empf√§nger √ºber die Liste oder geben Sie BSU/ID ein. Mit ‚Äû‚ùå Abbrechen‚Äú beenden.",
        "pl": "üë§ Wybierz odbiorcƒô z listy poni≈ºej lub wpisz jego BSU/ID. ‚Äû‚ùå Anuluj‚Äù przerywa operacjƒô.",
        "ru": "üë§ –í—ã–±–µ—Ä–∏—Ç–µ –ø–æ–ª—É—á–∞—Ç–µ–ª—è –∫–Ω–æ–ø–∫–æ–π –Ω–∏–∂–µ –∏–ª–∏ –≤–≤–µ–¥–∏—Ç–µ –µ–≥–æ BSU/ID. ¬´‚ùå –û—Ç–º–µ–Ω–∏—Ç—å¬ª –ø—Ä–µ–∫—Ä–∞—â–∞–µ—Ç –æ–ø–µ—Ä–∞—Ü–∏—é.",
    },
    "NP_ASSIGN_USER_NOT_FOUND": {
        "uk": "‚ùó –ö–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞ –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ. –ü–µ—Ä–µ–≤—ñ—Ä—Ç–µ –¥–∞–Ω—ñ —Ç–∞ —Å–ø—Ä–æ–±—É–π—Ç–µ —â–µ —Ä–∞–∑.",
        "en": "‚ùó User not found. Please check the details and try again.",
        "de": "‚ùó Benutzer nicht gefunden. Bitte pr√ºfen Sie die Angaben und versuchen Sie es erneut.",
        "pl": "‚ùó Nie znaleziono u≈ºytkownika. Sprawd≈∫ dane i spr√≥buj ponownie.",
        "ru": "‚ùó –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –¥–∞–Ω–Ω—ã–µ –∏ –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.",
    },
    "NP_ASSIGN_PROMPT_NOTE": {
        "uk": "üìù –î–æ–¥–∞–π—Ç–µ –∫–æ—Ä–æ—Ç–∫–µ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –∞–±–æ –Ω–∞—Ç–∏—Å–Ω—ñ—Ç—å ¬´‚è≠ –ü—Ä–æ–ø—É—Å—Ç–∏—Ç–∏¬ª. ¬´‚ùå –°–∫–∞—Å—É–≤–∞—Ç–∏¬ª –∑—É–ø–∏–Ω—è—î –ø–µ—Ä–µ–¥–∞—á—É.",
        "en": "üìù Add a short note or tap ‚Äú‚è≠ Skip‚Äù. ‚Äú‚ùå Cancel‚Äù stops the handover.",
        "de": "üìù F√ºgen Sie eine kurze Notiz hinzu oder tippen Sie auf ‚Äû‚è≠ √úberspringen‚Äú. ‚Äû‚ùå Abbrechen‚Äú beendet den Vorgang.",
        "pl": "üìù Dodaj kr√≥tki komentarz albo wybierz ‚Äû‚è≠ Pomi≈Ñ‚Äù. ‚Äû‚ùå Anuluj‚Äù ko≈Ñczy operacjƒô.",
        "ru": "üìù –î–æ–±–∞–≤—å—Ç–µ –∫–æ—Ä–æ—Ç–∫–∏–π –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ ¬´‚è≠ –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å¬ª. ¬´‚ùå –û—Ç–º–µ–Ω–∏—Ç—å¬ª –ø—Ä–µ–∫—Ä–∞—â–∞–µ—Ç –ø–µ—Ä–µ–¥–∞—á—É.",
    },
    "NP_ASSIGN_SKIP_TOAST": {
        "uk": "–ö–æ–º–µ–Ω—Ç–∞—Ä –Ω–µ –¥–æ–¥–∞–Ω–æ.",
        "en": "No note attached.",
        "de": "Keine Notiz hinzugef√ºgt.",
        "pl": "Notatki nie dodano.",
        "ru": "–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –Ω–µ –¥–æ–±–∞–≤–ª–µ–Ω.",
    },
    "NP_ASSIGN_CANCELLED": {
        "uk": "‚ÑπÔ∏è –ü–µ—Ä–µ–¥–∞—á–∞ –¢–¢–ù —Å–∫–∞—Å–æ–≤–∞–Ω–∞.",
        "en": "‚ÑπÔ∏è TTN forwarding cancelled.",
        "de": "‚ÑπÔ∏è Weitergabe der TTN wurde abgebrochen.",
        "pl": "‚ÑπÔ∏è Przekazanie TTN zosta≈Ço przerwane.",
        "ru": "‚ÑπÔ∏è –ü–µ—Ä–µ–¥–∞—á–∞ –¢–¢–ù –æ—Ç–º–µ–Ω–µ–Ω–∞.",
    },
    "NP_CANCELLED_TOAST": {
        "uk": "–î—ñ—é —Å–∫–∞—Å–æ–≤–∞–Ω–æ.",
        "en": "Action cancelled.",
        "de": "Aktion abgebrochen.",
        "pl": "Dzia≈Çanie anulowano.",
        "ru": "–î–µ–π—Å—Ç–≤–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ.",
    },
    "NP_ASSIGN_DONE": {
        "uk": "üè¢ <b>–ü–µ—Ä–µ–¥–∞—á–∞ –æ—Ñ–æ—Ä–º–ª–µ–Ω–∞</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nüîñ –¢–¢–ù: <code>{ttn}</code>\nüë§ –û—Ç—Ä–∏–º—É–≤–∞—á: {user}\nüïí –ü—Ä–∏–∑–Ω–∞—á–µ–Ω–æ: {time}\n\n‚úÖ –ü–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –Ω–∞–¥—ñ—Å–ª–∞–Ω–æ.",
        "en": "üè¢ <b>Forwarding complete</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nüîñ TTN: <code>{ttn}</code>\nüë§ Recipient: {user}\nüïí Assigned: {time}\n\n‚úÖ Notification sent.",
        "de": "üè¢ <b>Weitergabe abgeschlossen</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nüîñ TTN: <code>{ttn}</code>\nüë§ Empf√§nger: {user}\nüïí Zugeordnet: {time}\n\n‚úÖ Benachrichtigung gesendet.",
        "pl": "üè¢ <b>Przekazanie zako≈Ñczone</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nüîñ TTN: <code>{ttn}</code>\nüë§ Odbiorca: {user}\nüïí Przypisano: {time}\n\n‚úÖ Powiadomienie wys≈Çano.",
        "ru": "üè¢ <b>–ü–µ—Ä–µ–¥–∞—á–∞ –æ—Ñ–æ—Ä–º–ª–µ–Ω–∞</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nüîñ –¢–¢–ù: <code>{ttn}</code>\nüë§ –ü–æ–ª—É—á–∞—Ç–µ–ª—å: {user}\nüïí –ù–∞–∑–Ω–∞—á–µ–Ω–æ: {time}\n\n‚úÖ –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ.",
    },
    "NP_ASSIGN_DONE_NOTE_LABEL": {
        "uk": "üìù –ö–æ–º–µ–Ω—Ç–∞—Ä –∞–¥–º—ñ–Ω—ñ—Å—Ç—Ä–∞—Ç–æ—Ä–∞:\n{note}",
        "en": "üìù Admin note:\n{note}",
        "de": "üìù Notiz des Administrators:\n{note}",
        "pl": "üìù Notatka administratora:\n{note}",
        "ru": "üìù –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞:\n{note}",
    },
    "NP_ASSIGN_NOTIFY_USER": {
        "uk": "üì¶ –ê–¥–º—ñ–Ω—ñ—Å—Ç—Ä–∞—Ç–æ—Ä {admin} –ø–µ—Ä–µ–¥–∞–≤ –≤–∞–º –Ω–∞–∫–ª–∞–¥–Ω—É <b>{ttn}</b>. –í—ñ–¥–∫—Ä–∏–π—Ç–µ –∫–∞—Ä—Ç–∫—É –Ω–∏–∂—á–µ, —â–æ–± –ø–µ—Ä–µ–≥–ª—è–Ω—É—Ç–∏ —Å—Ç–∞—Ç—É—Å —ñ –ø—ñ–¥—Ç–≤–µ—Ä–¥–∏—Ç–∏ –æ—Ç—Ä–∏–º–∞–Ω–Ω—è.",
        "en": "üì¶ Administrator {admin} forwarded TTN <b>{ttn}</b> to you. Open the card below to review the status and confirm delivery.",
        "de": "üì¶ Administrator {admin} hat Ihnen die TTN <b>{ttn}</b> √ºbergeben. √ñffnen Sie die Karte unten, um Status und Empfang zu pr√ºfen.",
        "pl": "üì¶ Administrator {admin} przekaza≈Ç Ci TTN <b>{ttn}</b>. Otw√≥rz kartƒô poni≈ºej, aby sprawdziƒá status i potwierdziƒá odbi√≥r.",
        "ru": "üì¶ –ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä {admin} –ø–µ—Ä–µ–¥–∞–ª –≤–∞–º –¢–¢–ù <b>{ttn}</b>. –û—Ç–∫—Ä–æ–π—Ç–µ –∫–∞—Ä—Ç–æ—á–∫—É –Ω–∏–∂–µ, —á—Ç–æ–±—ã –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —Å—Ç–∞—Ç—É—Å –∏ –ø–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å –ø–æ–ª—É—á–µ–Ω–∏–µ.",
    },
    "NP_ASSIGNED_EMPTY": {
        "uk": "üè¢ –ù–æ–≤–∏—Ö –ø–æ—Å–∏–ª–æ–∫ BSG –ø–æ–∫–∏ –Ω–µ–º–∞—î. –Ø–∫ —Ç—ñ–ª—å–∫–∏ –∞–¥–º—ñ–Ω—ñ—Å—Ç—Ä–∞—Ç–æ—Ä –ø–µ—Ä–µ–¥–∞—Å—Ç—å –¢–¢–ù, –≤–∏ –æ—Ç—Ä–∏–º–∞—î—Ç–µ —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è.",
        "en": "üè¢ No BSG parcels right now. You'll be notified as soon as an administrator forwards a TTN.",
        "de": "üè¢ Zurzeit keine BSG-Sendungen. Sie erhalten eine Nachricht, sobald ein Administrator eine TTN weiterleitet.",
        "pl": "üè¢ Obecnie brak przesy≈Çek BSG. Dostaniesz powiadomienie, gdy administrator przeka≈ºe TTN.",
        "ru": "üè¢ –ù–æ–≤—ã—Ö –ø–æ—Å—ã–ª–æ–∫ BSG –ø–æ–∫–∞ –Ω–µ—Ç. –ú—ã —Å–æ–æ–±—â–∏–º, –∫–∞–∫ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä –ø–µ—Ä–µ–¥–∞—Å—Ç –¢–¢–ù.",
    },
    "NP_ASSIGNED_HEADER": {
        "uk": "üè¢ <b>–ü–æ—Å–∏–ª–∫–∏ BSG</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n–û–±–µ—Ä—ñ—Ç—å –Ω–∞–∫–ª–∞–¥–Ω—É, —â–æ–± –ø–µ—Ä–µ–≥–ª—è–Ω—É—Ç–∏ —Å—Ç–∞—Ç—É—Å, –∑–∞–ª–∏—à–∏—Ç–∏ –∫–æ–º–µ–Ω—Ç–∞—Ä –∞–±–æ –ø—ñ–¥—Ç–≤–µ—Ä–¥–∏—Ç–∏ –æ—Ç—Ä–∏–º–∞–Ω–Ω—è.",
        "en": "üè¢ <b>BSG parcels</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nPick a TTN to review its status, add a comment, or confirm delivery.",
        "de": "üè¢ <b>BSG-Sendungen</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nW√§hlen Sie eine TTN, um Status, Kommentar oder den Empfang zu best√§tigen.",
        "pl": "üè¢ <b>Przesy≈Çki BSG</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nWybierz TTN, aby sprawdziƒá status, dodaƒá komentarz lub potwierdziƒá odbi√≥r.",
        "ru": "üè¢ <b>–ü–æ—Å—ã–ª–∫–∏ BSG</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n–í—ã–±–µ—Ä–∏—Ç–µ –Ω–∞–∫–ª–∞–¥–Ω—É—é, —á—Ç–æ–±—ã –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å —Å—Ç–∞—Ç—É—Å, –æ—Å—Ç–∞–≤–∏—Ç—å –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –∏–ª–∏ –ø–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å –ø–æ–ª—É—á–µ–Ω–∏–µ.",
    },
    "NP_ASSIGNED_DETAIL_TITLE": {
        "uk": "üè¢ <b>–ü–æ—Å–∏–ª–∫–∞ BSG</b>",
        "en": "üè¢ <b>BSG parcel</b>",
        "de": "üè¢ <b>BSG-Sendung</b>",
        "pl": "üè¢ <b>Przesy≈Çka BSG</b>",
        "ru": "üè¢ <b>–ü–æ—Å—ã–ª–∫–∞ BSG</b>",
    },
    "NP_ASSIGNED_CONFIRM_SENT": {
        "uk": "‚úÖ –ü–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –≤—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–æ –∞–¥–º—ñ–Ω—ñ—Å—Ç—Ä–∞—Ç–æ—Ä–∞–º.",
        "en": "‚úÖ Notification sent to the administrators.",
        "de": "‚úÖ Benachrichtigung an die Administratoren gesendet.",
        "pl": "‚úÖ Powiadomienie wys≈Çano administratorom.",
        "ru": "‚úÖ –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞–º.",
    },
    "NP_ASSIGNMENT_ALREADY_DONE": {
        "uk": "‚ÑπÔ∏è –¶—è –ø–æ—Å–∏–ª–∫–∞ –≤–∂–µ –≤—ñ–¥–º—ñ—á–µ–Ω–∞ —è–∫ –æ—Ç—Ä–∏–º–∞–Ω–∞.",
        "en": "‚ÑπÔ∏è This parcel has already been marked as received.",
        "de": "‚ÑπÔ∏è Diese Sendung wurde bereits als erhalten markiert.",
        "pl": "‚ÑπÔ∏è Ta przesy≈Çka zosta≈Ça ju≈º oznaczona jako odebrana.",
        "ru": "‚ÑπÔ∏è –≠—Ç–∞ –ø–æ—Å—ã–ª–∫–∞ —É–∂–µ –æ—Ç–º–µ—á–µ–Ω–∞ –∫–∞–∫ –ø–æ–ª—É—á–µ–Ω–Ω–∞—è.",
    },
    "NP_DELIVERY_ACK_RECORDED": {
        "uk": "‚úÖ –î—è–∫—É—î–º–æ! –ú–∏ –ø–æ–≤—ñ–¥–æ–º–∏–ª–∏ –∞–¥–º—ñ–Ω—ñ—Å—Ç—Ä–∞—Ç–æ—Ä—ñ–≤ –ø—Ä–æ –æ—Ç—Ä–∏–º–∞–Ω–Ω—è.",
        "en": "‚úÖ Thank you! The administrators have been notified.",
        "de": "‚úÖ Danke! Die Administratoren wurden informiert.",
        "pl": "‚úÖ Dziƒôkujemy! Administratorzy zostali poinformowani.",
        "ru": "‚úÖ –°–ø–∞—Å–∏–±–æ! –ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã —É–≤–µ–¥–æ–º–ª–µ–Ω—ã.",
    },
    "NP_RECEIVED_EMPTY": {
        "uk": "üì• –ü–æ–∫–∏ —â–æ –Ω–µ–º–∞—î –ø—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω–∏—Ö –ø–æ—Å–∏–ª–æ–∫ BSG. –ü—ñ—Å–ª—è –æ—Ç—Ä–∏–º–∞–Ω–Ω—è —Å–∫–æ—Ä–∏—Å—Ç–∞–π—Ç–µ—Å—è –∫–Ω–æ–ø–∫–æ—é ¬´–ü–æ—Å–∏–ª–∫–∞ –æ—Ç—Ä–∏–º–∞–Ω–∞¬ª –≤ –∫–∞—Ä—Ç—Ü—ñ –Ω–∞–∫–ª–∞–¥–Ω–æ—ó.",
        "en": "üì• No received BSG parcels yet. Use ‚ÄúParcel received‚Äù on the TTN card once the delivery is in your hands.",
        "de": "üì• Noch keine best√§tigten BSG-Sendungen. Nutzen Sie ‚ÄûSendung erhalten‚Äú in der Karte, sobald die Lieferung bei Ihnen ist.",
        "pl": "üì• Brak potwierdzonych przesy≈Çek BSG. Po odebraniu u≈ºyj przycisku ‚ÄûPrzesy≈Çka odebrana‚Äù w karcie TTN.",
        "ru": "üì• –ü–æ–¥—Ç–≤–µ—Ä–∂–¥—ë–Ω–Ω—ã—Ö –ø–æ—Å—ã–ª–æ–∫ BSG –ø–æ–∫–∞ –Ω–µ—Ç. –ü–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è –Ω–∞–∂–º–∏—Ç–µ ¬´–ü–æ—Å—ã–ª–∫–∞ –ø–æ–ª—É—á–µ–Ω–∞¬ª –≤ –∫–∞—Ä—Ç–æ—á–∫–µ –Ω–∞–∫–ª–∞–¥–Ω–æ–π.",
    },
    "NP_RECEIVED_HEADER": {
        "uk": "üì• <b>–û—Ç—Ä–∏–º–∞–Ω—ñ –ø–æ—Å–∏–ª–∫–∏ BSG</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n–ü–µ—Ä–µ–≥–ª—è–Ω—å—Ç–µ —Å—Ç–∞—Ç—É—Å–∏, –∫–æ–º–µ–Ω—Ç–∞—Ä—ñ —Ç–∞ —ñ—Å—Ç–æ—Ä—ñ—é –¥–ª—è –ø—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω–∏—Ö –Ω–∞–∫–ª–∞–¥–Ω–∏—Ö.",
        "en": "üì• <b>Received BSG parcels</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nReview statuses, comments, and history for confirmed deliveries.",
        "de": "üì• <b>Erhaltene BSG-Sendungen</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nPr√ºfen Sie Status, Kommentare und Historie best√§tigter Lieferungen.",
        "pl": "üì• <b>Odebrane przesy≈Çki BSG</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nSprawd≈∫ statusy, komentarze i historiƒô potwierdzonych dostaw.",
        "ru": "üì• <b>–ü–æ–ª—É—á–µ–Ω–Ω—ã–µ –ø–æ—Å—ã–ª–∫–∏ BSG</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n–ü—Ä–æ—Å–º–æ—Ç—Ä–∏—Ç–µ —Å—Ç–∞—Ç—É—Å—ã, –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ –∏ –∏—Å—Ç–æ—Ä–∏—é –ø–æ–¥—Ç–≤–µ—Ä–∂–¥—ë–Ω–Ω—ã—Ö –¥–æ—Å—Ç–∞–≤–æ–∫.",
    },
}

LANG_CODES = {code for code, _ in LANG_ORDER}
LANG_LABELS = {code: label for code, label in LANG_ORDER}


def normalize_lang(code: Optional[str]) -> str:
    if isinstance(code, str) and code in LANG_CODES:
        return code
    return DEFAULT_LANG


def resolve_lang(target: Any) -> str:
    if isinstance(target, str):
        return normalize_lang(target)
    if isinstance(target, dict):
        return normalize_lang(target.get("lang"))
    if isinstance(target, int):
        profile = load_user(target)
        if profile:
            return normalize_lang(profile.get("lang"))
    return DEFAULT_LANG


def tr(target: Any, text: str, **kwargs) -> str:
    if not isinstance(text, str):
        return text
    lang = resolve_lang(target)
    mapping = TEXTS.get(text)
    if mapping:
        template = mapping.get(lang) or mapping.get(DEFAULT_LANG) or next(iter(mapping.values()))
    else:
        template = text
    if kwargs:
        try:
            return template.format(**kwargs)
        except Exception:
            return template
    return template

bot = Bot(token=TOKEN, parse_mode="HTML")
dp = Dispatcher(bot, storage=MemoryStorage())

# runtime cache
users_runtime: Dict[int, dict] = {}
admins: set = set()
active_project = {"name": None}
alerts_poll_task: Optional[asyncio.Task] = None
alerts_history_cache: Dict[str, Dict[str, Any]] = {}


# ========================== FSM ==========================
class OnboardFSM(StatesGroup):
    language = State()
    welcome = State()
    briefing = State()
    instructions = State()
    last_name = State()
    first_name = State()
    middle_name = State()
    birthdate = State()
    region = State()
    region_confirm = State()
    phone = State()
    photo = State()


class ProfileEditFSM(StatesGroup):
    waiting_last_name = State()
    waiting_first_name = State()
    waiting_middle_name = State()
    waiting_birthdate = State()
    waiting_region = State()
    region_confirm = State()
    waiting_phone = State()
    waiting_photo = State()


class AdminProfileEditFSM(StatesGroup):
    waiting_last_name = State()
    waiting_first_name = State()
    waiting_middle_name = State()
    waiting_birthdate = State()
    waiting_region = State()
    region_confirm = State()
    waiting_phone = State()
    waiting_photo = State()


class ReceiptFSM(StatesGroup):
    waiting_photo = State()
    waiting_amount = State()
    waiting_description = State()
    waiting_paid_choice = State()
    preview = State()

class ProjectCreateFSM(StatesGroup):
    enter_name = State()
    enter_region = State()
    enter_location = State()
    enter_description = State()
    enter_start_date = State()
    enter_end_date = State()
    upload_pdf = State()


class PhotoFSM(StatesGroup):
    collecting = State()


class SosFSM(StatesGroup):
    waiting_location = State()


class NovaPoshtaFSM(StatesGroup):
    waiting_ttn = State()
    waiting_note = State()
    waiting_assign_ttn = State()
    waiting_assign_user = State()
    waiting_assign_note = State()


# ========================== FS HELPERS ==========================
def ensure_dirs():
    os.makedirs("data", exist_ok=True)
    os.makedirs(BASE_PATH, exist_ok=True)
    os.makedirs(USERS_PATH, exist_ok=True)
    os.makedirs(FIN_PATH, exist_ok=True)
    os.makedirs(ALERTS_STORAGE_BASE, exist_ok=True)

def proj_path(name: str) -> str: return os.path.join(BASE_PATH, name)
def proj_info_file(name: str) -> str: return os.path.join(proj_path(name), "project.json")
def proj_pdf_dir(name: str) -> str: return os.path.join(proj_path(name), "pdf")
def proj_ledger(name: str) -> str: return os.path.join(proj_path(name), "ledger.xlsx")
def proj_finance_file(name: str) -> str: return os.path.join(proj_path(name), "finance.json")
def proj_receipts_dir(name: str, uid: int) -> str: return os.path.join(proj_path(name), "receipts", str(uid))
def proj_photos_dir(name: str) -> str: return os.path.join(proj_path(name), "photos")
def proj_photos_meta(name: str) -> str: return os.path.join(proj_photos_dir(name), "photos.json")
def user_file(uid: int) -> str: return os.path.join(USERS_PATH, f"{uid}.json")


def generate_photo_id() -> str:
    return secrets.token_hex(8)


def project_token(name: str) -> str:
    digest = hashlib.sha1(name.encode("utf-8")).digest()[:4]
    return base64.urlsafe_b64encode(digest).decode("ascii").rstrip("=")


def _project_existing_codes(exclude: Optional[str] = None) -> Set[str]:
    ensure_dirs()
    codes: Set[str] = set()
    if not os.path.exists(BASE_PATH):
        return codes
    for d in os.listdir(BASE_PATH):
        if exclude and d == exclude:
            continue
        info_path = proj_info_file(d)
        if not os.path.exists(info_path):
            continue
        try:
            payload = json.load(open(info_path, "r", encoding="utf-8"))
        except Exception:
            continue
        code = payload.get("code")
        if isinstance(code, str) and code:
            codes.add(code)
    return codes


def _project_code_prefix(name: str) -> str:
    cleaned = re.sub(r"[^A-Za-z–ê-–Ø–∞-—è–Å—ë–á—ó–Ü—ñ–Ñ—î“ê“ë ]+", " ", (name or "")).strip()
    parts = [p for p in cleaned.split() if p]
    letters: List[str] = []
    for part in parts:
        for ch in part:
            if ch.isalpha():
                letters.append(ch.upper())
                break
        if len(letters) >= 2:
            break
    fallback = list("PR")
    while len(letters) < 2:
        letters.append(fallback[len(letters) % len(fallback)])
    return "".join(letters[:2])


def generate_project_code(name: str, existing: Optional[Set[str]] = None) -> str:
    prefix = _project_code_prefix(name)
    existing = existing or set()
    for length, upper in ((3, 999), (4, 9999)):
        for num in range(1, upper + 1):
            candidate = f"{prefix}{num:0{length}d}"
            if candidate not in existing:
                return candidate
    # Fallback: timestamp-based unique code
    return f"{prefix}{int(datetime.now().timestamp())}"


def _decode_exif_text(value: Any) -> Optional[str]:
    if value is None:
        return None
    if isinstance(value, bytes):
        for encoding in ("utf-16-le", "utf-8"):
            try:
                decoded = value.decode(encoding, errors="ignore").rstrip("\x00")
                return decoded.strip() or None
            except Exception:
                continue
        return None
    if isinstance(value, str):
        stripped = value.strip()
        return stripped or None
    if isinstance(value, (list, tuple)):
        parts = [_decode_exif_text(part) for part in value]
        joined = ", ".join(part for part in parts if part)
        return joined or None
    try:
        return str(value)
    except Exception:
        return None


def _fraction_to_float(value: Any) -> Optional[float]:
    try:
        return float(value)
    except Exception:
        try:
            num, denom = value
            return float(num) / float(denom) if denom else None
        except Exception:
            return None
    return None


def _convert_to_degrees(values: Any) -> Optional[float]:
    try:
        d, m, s = values
    except Exception:
        return None
    deg = _fraction_to_float(d)
    min_ = _fraction_to_float(m)
    sec = _fraction_to_float(s)
    if deg is None or min_ is None or sec is None:
        return None
    return deg + (min_ / 60.0) + (sec / 3600.0)


def extract_image_metadata(path: str) -> Dict[str, Any]:
    meta: Dict[str, Any] = {"analyzed": True}
    try:
        with Image.open(path) as img:
            raw_exif = getattr(img, "_getexif", lambda: None)()
    except Exception:
        return meta

    if not raw_exif:
        return meta

    exif: Dict[str, Any] = {}
    for tag, value in raw_exif.items():
        name = ExifTags.TAGS.get(tag, tag)
        exif[name] = value

    gps_raw = exif.get("GPSInfo")
    if isinstance(gps_raw, dict):
        gps_decoded: Dict[str, Any] = {}
        for key, value in gps_raw.items():
            readable = ExifTags.GPSTAGS.get(key, key)
            gps_decoded[readable] = value
        lat = _convert_to_degrees(gps_decoded.get("GPSLatitude"))
        lat_ref = gps_decoded.get("GPSLatitudeRef")
        lon = _convert_to_degrees(gps_decoded.get("GPSLongitude"))
        lon_ref = gps_decoded.get("GPSLongitudeRef")
        if lat is not None and lon is not None:
            if isinstance(lat_ref, str) and lat_ref.upper() == "S":
                lat = -lat
            if isinstance(lon_ref, str) and lon_ref.upper() == "W":
                lon = -lon
            meta["gps"] = {"lat": round(lat, 6), "lon": round(lon, 6)}

    address_keys = [
        "XPSubLocation", "SubLocation", "City", "ProvinceState", "State", "Country", "CountryName",
        "ImageDescription", "XPComment", "XPSubject", "XPKeywords", "XPTitle"
    ]
    parts: List[str] = []
    seen: Set[str] = set()
    for key in address_keys:
        text = _decode_exif_text(exif.get(key))
        if not text:
            continue
        norm = text.strip()
        lower = norm.lower()
        if lower in seen:
            continue
        seen.add(lower)
        parts.append(norm)
    if parts:
        meta["address"] = ", ".join(parts)

    for dt_key in ("DateTimeOriginal", "DateTimeDigitized", "DateTime"):
        dt_raw = _decode_exif_text(exif.get(dt_key))
        if not dt_raw:
            continue
        parsed = None
        for fmt in ("%Y:%m:%d %H:%M:%S", "%Y-%m-%d %H:%M:%S"):
            try:
                parsed = datetime.strptime(dt_raw, fmt)
                break
            except Exception:
                continue
        if parsed:
            meta["captured_at"] = parsed.strftime("%Y-%m-%d %H:%M")
        else:
            meta["captured_at"] = dt_raw
        break

    make = _decode_exif_text(exif.get("Make"))
    model = _decode_exif_text(exif.get("Model"))
    camera_parts = [part for part in (make, model) if part]
    if camera_parts:
        meta["camera"] = " ".join(camera_parts)

    return meta


def ensure_photo_metadata(project: str, entry: dict) -> bool:
    meta = entry.get("meta")
    if not isinstance(meta, dict):
        meta = {}
    if meta.get("analyzed"):
        entry["meta"] = meta
        return False
    file_name = entry.get("file")
    if not file_name:
        meta["analyzed"] = True
        entry["meta"] = meta
        return True
    path = os.path.join(proj_photos_dir(project), file_name)
    if not os.path.exists(path):
        meta["analyzed"] = True
        entry["meta"] = meta
        return True
    extracted = extract_image_metadata(path)
    combined = {k: v for k, v in meta.items() if k != "analyzed"}
    combined.update(extracted)
    if "analyzed" not in combined:
        combined["analyzed"] = True
    entry["meta"] = combined
    return True


def load_project_photos(name: str) -> List[dict]:
    ensure_project_structure(name)
    path = proj_photos_meta(name)
    if not os.path.exists(path):
        return []
    try:
        raw = json.load(open(path, "r", encoding="utf-8"))
    except Exception:
        return []
    if not isinstance(raw, list):
        return []

    items: List[dict] = []
    changed = False
    for entry in raw:
        if not isinstance(entry, dict):
            continue
        normalized = dict(entry)
        if not normalized.get("id"):
            normalized["id"] = generate_photo_id()
            changed = True
        if not isinstance(normalized.get("meta"), dict):
            normalized["meta"] = {}
            changed = True
        if ensure_photo_metadata(name, normalized):
            changed = True
        items.append(normalized)

    if changed:
        save_project_photos(name, items)
    return items


def project_photo_count(name: str) -> int:
    return len(load_project_photos(name))


def find_photo_entry(project: str, entry_id: str) -> Tuple[int, Optional[dict], List[dict]]:
    photos = load_project_photos(project)
    if not entry_id:
        return -1, None, photos
    for idx, entry in enumerate(photos):
        if not isinstance(entry, dict):
            continue
        if entry.get("id") == entry_id or entry.get("file") == entry_id:
            return idx, entry, photos
    return -1, None, photos


def save_project_photos(name: str, items: List[dict]):
    os.makedirs(proj_photos_dir(name), exist_ok=True)
    json.dump(items, open(proj_photos_meta(name), "w", encoding="utf-8"), ensure_ascii=False, indent=2)

def ensure_project_structure(name: str):
    os.makedirs(proj_path(name), exist_ok=True)
    os.makedirs(proj_pdf_dir(name), exist_ok=True)
    os.makedirs(os.path.join(proj_path(name), "receipts"), exist_ok=True)
    os.makedirs(proj_photos_dir(name), exist_ok=True)
    if not os.path.exists(proj_finance_file(name)):
        json.dump({"requests": {}}, open(proj_finance_file(name), "w", encoding="utf-8"), ensure_ascii=False, indent=2)
    if not os.path.exists(proj_ledger(name)):
        wb = Workbook(); ws = wb.active; ws.title = "Ledger"
        ws.append(["–î–∞—Ç–∞", "–í—Ä–µ–º—è", "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å", "BSU", "–ù–æ–º–µ—Ä —á–µ–∫–∞", "–°—É–º–º–∞", "–§–∞–π–ª", "–û–ø–∏—Å–∞–Ω–∏–µ", "–û–ø–ª–∞—á–µ–Ω (1/0/None)"])
        _autosize(ws)
        wb.save(proj_ledger(name))
    if not os.path.exists(proj_photos_meta(name)):
        save_project_photos(name, [])
    if not os.path.exists(proj_info_file(name)):
        existing_codes = _project_existing_codes(exclude=name)
        info = {"name": name, "location": "", "description": "",
                "start_date": "", "end_date": "", "region": "", "code": generate_project_code(name, existing_codes),
                "active": False, "pdf": [], "created": datetime.now().isoformat()}
        json.dump(info, open(proj_info_file(name), "w", encoding="utf-8"), ensure_ascii=False, indent=2)
    _alerts_ensure_storage(name)

def list_projects() -> List[str]:
    ensure_dirs()
    return [d for d in os.listdir(BASE_PATH) if os.path.isdir(os.path.join(BASE_PATH, d))]


def project_from_token(token: str) -> Optional[str]:
    if not token:
        return None
    for name in list_projects():
        if project_token(name) == token:
            return name
    return None


def load_project_info(name: str) -> dict:
    ensure_project_structure(name)
    info = json.load(open(proj_info_file(name), "r", encoding="utf-8"))
    updated = False
    if "region" not in info:
        info["region"] = ""
        updated = True
    if not info.get("code"):
        existing_codes = _project_existing_codes(exclude=name)
        info["code"] = generate_project_code(info.get("name") or name, existing_codes)
        updated = True
    if updated:
        save_project_info(name, info)
    return info

def save_project_info(name: str, info: dict):
    json.dump(info, open(proj_info_file(name), "w", encoding="utf-8"), ensure_ascii=False, indent=2)

def _autosize(ws):
    for col in ws.columns:
        max_length = 0
        col_letter = get_column_letter(col[0].column)
        for cell in col:
            try:
                val = str(cell.value) if cell.value is not None else ""
                if len(val) > max_length:
                    max_length = len(val)
            except Exception:
                pass
        ws.column_dimensions[col_letter].width = min(max_length + 2, 60)


# ========================== BOT STATE PERSIST ==========================
def load_bot_state() -> dict:
    ensure_dirs()
    if not os.path.exists(BOT_FILE):
        st = {"active_project": None, "admins": [], "version": BOT_VERSION, "revision": BOT_REVISION}
        save_bot_state(st); return st
    return json.load(open(BOT_FILE, "r", encoding="utf-8"))

def save_bot_state(state: dict):
    json.dump(state, open(BOT_FILE, "w", encoding="utf-8"), ensure_ascii=False, indent=2)

def sync_state():
    st = load_bot_state()
    active_project["name"] = st.get("active_project")
    admins.clear(); admins.update(st.get("admins", []))

def persist_state():
    st = load_bot_state()
    st["active_project"] = active_project["name"]
    st["admins"] = list(admins)
    st["version"] = BOT_VERSION
    st["revision"] = BOT_REVISION
    save_bot_state(st)

def set_active_project(name: Optional[str]):
    active_project["name"] = name
    persist_state()


# ========================== USERS PERSIST ==========================
def load_user(uid: int) -> Optional[dict]:
    path = user_file(uid)
    if not os.path.exists(path):
        return None
    with open(path, "r", encoding="utf-8") as fh:
        return json.load(fh)


def save_user(profile: dict):
    ensure_dirs()
    path = user_file(profile["user_id"])
    tmp_path = f"{path}.tmp"
    try:
        with open(tmp_path, "w", encoding="utf-8") as fh:
            json.dump(profile, fh, ensure_ascii=False, indent=2)
            fh.flush()
            os.fsync(fh.fileno())
        os.replace(tmp_path, path)
    finally:
        if os.path.exists(tmp_path):
            try:
                os.remove(tmp_path)
            except Exception:
                pass


def load_all_users() -> List[dict]:
    ensure_dirs()
    if not os.path.exists(USERS_PATH):
        return []
    profiles: List[dict] = []
    for name in os.listdir(USERS_PATH):
        if not name.endswith(".json"):
            continue
        path = os.path.join(USERS_PATH, name)
        try:
            profiles.append(json.load(open(path, "r", encoding="utf-8")))
        except Exception:
            continue
    return profiles


def normalize_bsu_code(code: str) -> Optional[str]:
    if not code:
        return None
    digits = re.sub(r"[^0-9]", "", code)
    if len(digits) != 4:
        return None
    return f"BSU-{digits}"


def find_user_by_bsu(code: str, profiles: Optional[List[dict]] = None) -> Optional[dict]:
    normalized = normalize_bsu_code(code)
    if not normalized:
        return None
    profiles = profiles or load_all_users()
    target = normalized.upper()
    for prof in profiles:
        bsu = str(prof.get("bsu") or "").upper()
        if bsu == target:
            return prof
    return None


def find_user_by_username(username: str, profiles: Optional[List[dict]] = None) -> Optional[dict]:
    if not username:
        return None
    normalized = username.lstrip("@").strip().lower()
    if not normalized:
        return None
    profiles = profiles or load_all_users()
    for prof in profiles:
        tg_username = ((prof.get("tg") or {}).get("username") or "").lower()
        if tg_username == normalized:
            return prof
    return None


def resolve_user_reference(msg: types.Message) -> Optional[dict]:
    if msg.forward_from:
        profile = load_user(msg.forward_from.id)
        if profile:
            return profile
    contact = getattr(msg, "contact", None)
    if contact and contact.user_id:
        profile = load_user(contact.user_id)
        if profile:
            return profile

    text = (msg.text or "").strip()
    if not text:
        return None

    profiles = load_all_users()

    bsu_candidate = find_user_by_bsu(text, profiles=profiles)
    if bsu_candidate:
        return bsu_candidate

    digits = re.sub(r"[^0-9]", "", text)
    if digits:
        try:
            profile = load_user(int(digits))
            if profile:
                return profile
        except Exception:
            pass

    if text.startswith("@"):
        username_match = find_user_by_username(text, profiles=profiles)
        if username_match:
            return username_match

    return None


def normalize_profile_receipts(profile: dict) -> bool:
    changed = False
    receipts = profile.get("receipts")
    if isinstance(receipts, dict):
        for items in receipts.values():
            if not isinstance(items, list):
                continue
            for entry in items:
                if "payout" not in entry:
                    entry["payout"] = None
                    changed = True
                history = entry.get("payout_history")
                if not isinstance(history, list):
                    entry["payout_history"] = []
                    changed = True
    return changed


NAME_ALLOWED_CHARS = "A-Za-z–ê-–Ø–∞-—è–Å—ë–á—ó–Ü—ñ–Ñ—î“ê“ë º'‚Äô\-\s"
NAME_VALID_RE = re.compile(rf"^[{NAME_ALLOWED_CHARS}]+$")
SKIP_KEYWORDS = {"–Ω–µ—Ç", "–Ω–µ–º–∞—î", "–Ω–µ–º–∞", "no", "skip", "none", "n/a", "-"}


def normalize_person_name(value: Optional[str]) -> str:
    if not value:
        return ""
    text = str(value)
    text = text.replace("`", "'").replace("‚Äô", "'").replace(" º", "'")
    text = re.sub(r"\s+", " ", text).strip()
    return text


def beautify_name(value: Optional[str]) -> str:
    text = normalize_person_name(value)
    if not text:
        return ""

    def _capitalize(fragment: str) -> str:
        if not fragment:
            return fragment
        return fragment[0].upper() + fragment[1:].lower()

    words: List[str] = []
    for word in text.split(" "):
        if not word:
            continue
        parts: List[str] = []
        for sub in re.split(r"([-'])", word):
            if sub in ("-", "'"):
                parts.append(sub)
            elif sub:
                parts.append(_capitalize(sub))
        words.append("".join(parts))
    return " ".join(words)


def validate_name(value: str) -> bool:
    if not value:
        return False
    text = normalize_person_name(value)
    if len(text) < 2:
        return False
    return bool(NAME_VALID_RE.match(text))


def compose_fullname(last_name: str, first_name: str, middle_name: Optional[str]) -> str:
    parts = [last_name, first_name]
    if middle_name:
        parts.append(middle_name)
    return " ".join(part for part in parts if part)


def sanitize_phone_input(text: Optional[str]) -> Optional[str]:
    if not text:
        return None
    raw = text.strip()
    digits = re.sub(r"\D+", "", raw)
    if not digits:
        return None
    if raw.startswith("+"):
        normalized = "+" + digits
    elif len(digits) == 10 and digits.startswith("0"):
        normalized = "+38" + digits
    elif len(digits) >= 11 and digits.startswith("380"):
        normalized = "+" + digits
    elif len(digits) >= 10:
        normalized = "+" + digits
    else:
        return None
    if len(re.sub(r"\D", "", normalized)) < 10:
        return None
    return normalized


def parse_birthdate_text(value: Optional[str]) -> Optional[datetime]:
    if not value:
        return None
    raw = re.sub(r"\s+", "", str(value))
    if not raw:
        return None
    normalized = raw.replace("/", ".").replace("-", ".")
    parts = normalized.split(".")
    try:
        if len(parts) == 3:
            day, month, year = parts
            if len(year) == 2:
                year = "19" + year if int(year) >= 50 else "20" + year
            dt = datetime(int(year), int(month), int(day))
        else:
            dt = datetime.strptime(raw, "%Y%m%d")
    except Exception:
        return None
    if dt.year < 1900:
        return None
    if dt.date() > datetime.now().date():
        return None
    return dt


def compute_age(birthdate: datetime) -> Optional[int]:
    if not birthdate:
        return None
    today = datetime.now().date()
    years = today.year - birthdate.year
    if (today.month, today.day) < (birthdate.month, birthdate.day):
        years -= 1
    return max(years, 0)


def format_birthdate_display(birthdate_iso: Optional[str], lang: Optional[str] = None) -> str:
    if not birthdate_iso:
        return "‚Äî"
    try:
        dt = datetime.strptime(birthdate_iso, "%Y-%m-%d")
    except Exception:
        return birthdate_iso
    age = compute_age(dt)
    formatted = dt.strftime("%d.%m.%Y")
    if age is None:
        return formatted
    lang = normalize_lang(lang)
    suffix_map = {
        "uk": "—Ä–æ–∫—ñ–≤",
        "en": "yo",
        "de": "J.",
        "pl": "lat",
        "ru": "–ª–µ—Ç",
    }
    suffix = suffix_map.get(lang, "yo")
    return f"{formatted} ({age} {suffix})"


def ensure_user_dir(uid: int) -> str:
    path = os.path.join(USERS_PATH, str(uid))
    os.makedirs(path, exist_ok=True)
    return path


def user_profile_photo_path(uid: int) -> str:
    return os.path.join(ensure_user_dir(uid), "profile.jpg")


async def store_profile_photo(uid: int, photo: types.PhotoSize) -> Optional[dict]:
    if not photo:
        return None
    ensure_user_dir(uid)
    dest = user_profile_photo_path(uid)
    tmp_path = f"{dest}.tmp"
    try:
        await photo.download(destination_file=tmp_path)
        with Image.open(tmp_path) as img:
            img = ImageOps.exif_transpose(img)
            img = img.convert("RGB")
            img.thumbnail((1280, 1280))
            width, height = img.size
            exif = img.getexif() if hasattr(img, "getexif") else None
            taken_iso = None
            if exif:
                for tag, value in exif.items():
                    name = ExifTags.TAGS.get(tag, tag)
                    if name in ("DateTimeOriginal", "DateTimeDigitized", "DateTime"):
                        text = _decode_exif_text(value)
                        if text:
                            for fmt in ("%Y:%m:%d %H:%M:%S", "%Y-%m-%d %H:%M:%S"):
                                try:
                                    taken_iso = datetime.strptime(text, fmt).isoformat()
                                    break
                                except Exception:
                                    continue
                            if taken_iso:
                                break
            img.save(tmp_path, format="JPEG", quality=90)
        os.replace(tmp_path, dest)
        meta = {
            "file_id": photo.file_id,
            "file_unique_id": photo.file_unique_id,
            "uploaded_at": datetime.now(timezone.utc).isoformat(),
            "width": width,
            "height": height,
        }
        if taken_iso:
            meta["taken_at"] = taken_iso
        return meta
    except Exception:
        if os.path.exists(tmp_path):
            try:
                os.remove(tmp_path)
            except Exception:
                pass
        raise


def remove_profile_photo(uid: int) -> None:
    path = user_profile_photo_path(uid)
    if os.path.exists(path):
        try:
            os.remove(path)
        except Exception:
            pass


def _safe_name(s: str) -> str:
    s = (s or "").strip()
    if not s: return "User"
    s = re.sub(r"[^A-Za-z–ê-–Ø–∞-—è0-9_\- ]+", "", s)
    s = s.replace("  ", " ").strip()
    return s or "User"


def _sanitize_filename(name: str) -> str:
    base = (name or "").strip()
    if not base:
        return "file"
    base = re.sub(r"[\\/:*?\"<>|]+", "_", base)
    base = re.sub(r"[^A-Za-z–ê-–Ø–∞-—è0-9_\-]+", "_", base)
    base = re.sub(r"_+", "_", base).strip("_")
    return base or "file"

def ensure_user(uid: int, tg_payload: dict, fullname: Optional[str] = None, phone: Optional[str] = None,
                lang: Optional[str] = None, lang_confirmed: Optional[bool] = None) -> dict:
    ensure_user_dir(uid)
    prof = load_user(uid)
    now_iso = datetime.now(timezone.utc).isoformat()
    if not prof:
        bsu = f"BSU-{random.randint(1000, 9999)}"
        prof = {
            "user_id": uid,
            "tg": dict(tg_payload),
            "first_name": "",
            "last_name": "",
            "middle_name": "",
            "fullname": fullname or tg_payload.get("first_name") or f"User{uid}",
            "phone": phone or "",
            "region": "",
            "birthdate": "",
            "photo": {},
            "bsu": bsu,
            "counters": {"receipt_seq": 0},
            "receipts": {},
            "payouts": [],
            "lang": normalize_lang(lang) if lang else DEFAULT_LANG,
            "lang_confirmed": bool(lang),
            "profile_completed": False,
            "created_at": now_iso,
            "updated_at": now_iso,
        }
    else:
        prof["tg"] = {**prof.get("tg", {}), **tg_payload}
        prof.setdefault("first_name", "")
        prof.setdefault("last_name", "")
        prof.setdefault("middle_name", "")
        prof.setdefault("fullname", fullname or prof.get("fullname") or tg_payload.get("first_name") or f"User{uid}")
        prof.setdefault("phone", "")
        prof.setdefault("region", "")
        prof.setdefault("birthdate", "")
        prof.setdefault("photo", {})
        prof.setdefault("counters", {"receipt_seq": 0})
        prof.setdefault("receipts", {})
        prof.setdefault("payouts", [])
        prof.setdefault("lang", DEFAULT_LANG)
        prof.setdefault("lang_confirmed", bool(prof.get("lang") in LANG_CODES))
        prof.setdefault("profile_completed", False)
        prof.setdefault("created_at", now_iso)
        if fullname:
            prof["fullname"] = fullname
        if phone:
            prof["phone"] = phone
        if lang is not None:
            prof["lang"] = normalize_lang(lang)
        if lang_confirmed is not None:
            prof["lang_confirmed"] = bool(lang_confirmed)
        if "bsu" not in prof:
            prof["bsu"] = f"BSU-{random.randint(1000, 9999)}"
        prof["updated_at"] = now_iso
    if normalize_profile_receipts(prof):
        pass
    save_user(prof)
    return prof


def get_user_lang(uid: int) -> str:
    prof = load_user(uid)
    if not prof:
        return DEFAULT_LANG
    return normalize_lang(prof.get("lang"))


def set_user_lang(uid: int, lang: str, confirmed: bool = True) -> dict:
    prof = load_user(uid)
    if not prof:
        raise ValueError("User profile must exist before setting language")
    prof["lang"] = normalize_lang(lang)
    prof["lang_confirmed"] = bool(confirmed)
    save_user(prof)
    return prof

def next_receipt_no(prof: dict) -> str:
    prof["counters"]["receipt_seq"] = int(prof["counters"].get("receipt_seq", 0)) + 1
    save_user(prof)
    return f"RID-{prof['counters']['receipt_seq']:04d}"

def user_append_receipt(uid: int, project: str, date: str, time: str, amount: float, filename: str, desc: str, paid, receipt_no: str):
    prof = load_user(uid) or {"user_id": uid, "receipts": {}}
    recmap = prof.get("receipts", {})
    lst = recmap.get(project, [])
    lst.append({
        "date": date,
        "time": time,
        "sum": float(amount),
        "file": filename,
        "desc": desc or "",
        "paid": paid,
        "receipt_no": receipt_no,
        "payout": None,
        "payout_history": []
    })
    recmap[project] = lst
    prof["receipts"] = recmap
    save_user(prof)

def user_project_receipts(uid: int, project: str) -> List[dict]:
    prof = load_user(uid)
    if not prof: return []
    changed = normalize_profile_receipts(prof)
    if changed:
        save_user(prof)
    return list((prof.get("receipts", {}) or {}).get(project, []))

def user_project_stats(uid: int, project: str) -> Dict[str, float]:
    recs = user_project_receipts(uid, project)
    total = 0.0
    paid_sum = 0.0
    unpaid_sum = 0.0
    pending_sum = 0.0
    unspecified_sum = 0.0
    for r in recs:
        try:
            amount = float(r.get("sum", 0.0))
        except (TypeError, ValueError):
            amount = 0.0
        total += amount
        paid_flag = r.get("paid")
        payout_status = (r.get("payout") or {}).get("status") if isinstance(r.get("payout"), dict) else None
        if paid_flag is True:
            paid_sum += amount
        elif paid_flag is False:
            if payout_status in ("pending", "approved"):
                pending_sum += amount
            else:
                unpaid_sum += amount
        else:
            unspecified_sum += amount
    return {
        "count": len(recs),
        "total": round(total, 2),
        "paid": round(paid_sum, 2),
        "unpaid": round(unpaid_sum, 2),
        "pending": round(pending_sum, 2),
        "unspecified": round(unspecified_sum, 2)
    }


def iter_user_payout_refs(prof: dict) -> List[dict]:
    payouts = prof.get("payouts", []) or []
    normalized: List[dict] = []
    changed = False
    for entry in payouts:
        if isinstance(entry, dict) and entry.get("id"):
            req_id = entry.get("id")
            project = entry.get("project")
            code = entry.get("code")
            normalized.append({"id": req_id, "project": project, "code": code})
        elif isinstance(entry, str):
            req_id = entry
            obj = finance_load_request(req_id)
            project = obj.get("project") if obj else None
            code = obj.get("code") if obj else None
            normalized.append({"id": req_id, "project": project, "code": code})
            changed = True
        else:
            changed = True
    if changed:
        prof["payouts"] = normalized
        save_user(prof)
    return normalized


# ========================== FINANCE FILES ==========================
def load_finance_data(project: str) -> dict:
    ensure_project_structure(project)
    path = proj_finance_file(project)
    if not os.path.exists(path):
        data = {"requests": {}}
        save_finance_data(project, data)
        return data
    try:
        with open(path, "r", encoding="utf-8") as fh:
            data = json.load(fh) or {}
    except Exception:
        data = {"requests": {}}
    if not isinstance(data, dict):
        data = {"requests": {}}
    if not isinstance(data.get("requests"), dict):
        data["requests"] = {}
    return data


def save_finance_data(project: str, data: dict):
    ensure_project_structure(project)
    path = proj_finance_file(project)
    json.dump(data, open(path, "w", encoding="utf-8"), ensure_ascii=False, indent=2)


def finance_generate_code() -> str:
    ensure_dirs()
    existing = set()
    for project in list_projects():
        data = load_finance_data(project)
        for item in data.get("requests", {}).values():
            code = item.get("code")
            if code:
                existing.add(code)
    if os.path.isdir(FIN_PATH):
        for f in os.listdir(FIN_PATH):
            if not f.endswith(".json"):
                continue
            try:
                payload = json.load(open(os.path.join(FIN_PATH, f), "r", encoding="utf-8"))
            except Exception:
                continue
            code = payload.get("code")
            if code:
                existing.add(code)
    while True:
        code = f"ID-BRD-{random.randint(0, 9999):04d}"
        if code not in existing:
            return code


def finance_new_request(uid: int, project: str, receipts: List[dict]) -> dict:
    ensure_dirs()
    data = load_finance_data(project)
    ts = int(datetime.now().timestamp())
    req_id = f"req_{ts}_{uid}"
    while req_id in data.get("requests", {}):
        ts += 1
        req_id = f"req_{ts}_{uid}"
    code = finance_generate_code()
    files: List[str] = []
    items: List[dict] = []
    total = 0.0
    now_iso = datetime.now().isoformat()
    for rec in receipts:
        file_name = rec.get("file") or ""
        files.append(file_name)
        try:
            amount = float(rec.get("sum", 0.0))
        except (TypeError, ValueError):
            amount = 0.0
        total += amount
        items.append({
            "file": file_name,
            "receipt_no": rec.get("receipt_no"),
            "amount": round(amount, 2),
            "desc": rec.get("desc"),
            "status": "pending",
            "updated_at": now_iso
        })
    payload = {
        "id": req_id,
        "code": code,
        "user_id": uid,
        "project": project,
        "sum": round(float(total), 2),
        "files": files,
        "items": items,
        "status": "pending",
        "approved_by": None,
        "approved_at": None,
        "confirmed_at": None,
        "created_at": now_iso,
        "history": [{"status": "pending", "timestamp": now_iso}]
    }
    data.setdefault("requests", {})[req_id] = payload
    save_finance_data(project, data)
    prof = load_user(uid) or {}
    arr = prof.get("payouts", [])
    entry = {"id": req_id, "project": project, "code": code}
    if not any(isinstance(x, dict) and x.get("id") == req_id for x in arr):
        arr.append(entry)
        prof["payouts"] = arr
        save_user(prof)
    fin_state_set(project, uid, req_id, "pending")
    update_receipts_for_request(uid, project, files, "pending", payload)
    return finance_request_defaults(payload)


def finance_load_request(req_id: str, project_hint: Optional[str]=None) -> Optional[dict]:
    projects: List[str]
    if project_hint:
        projects = [project_hint]
    else:
        projects = list_projects()
    for name in projects:
        if not name:
            continue
        data = load_finance_data(name)
        obj = (data.get("requests") or {}).get(req_id)
        if obj:
            if not obj.get("project"):
                obj["project"] = name
                finance_save_request(obj)
            return finance_request_defaults(obj)
    if project_hint:
        return finance_load_request(req_id, None)
    legacy_path = os.path.join(FIN_PATH, f"{req_id}.json")
    if os.path.exists(legacy_path):
        try:
            obj = json.load(open(legacy_path, "r", encoding="utf-8"))
        except Exception:
            obj = None
        if obj:
            project = obj.get("project") or project_hint
            if project:
                obj["project"] = project
                finance_save_request(obj)
                try:
                    os.remove(legacy_path)
                except Exception:
                    pass
            return finance_request_defaults(obj)
    return None


def finance_save_request(obj: dict):
    project = obj.get("project")
    if not project:
        return
    obj = finance_request_defaults(obj) or obj
    data = load_finance_data(project)
    data.setdefault("requests", {})[obj["id"]] = obj
    save_finance_data(project, data)


def finance_list(filter_status: Optional[str]=None) -> List[dict]:
    ensure_dirs()
    out = []
    for project in list_projects():
        data = load_finance_data(project)
        for req in data.get("requests", {}).values():
            if not req.get("project"):
                req["project"] = project
                finance_save_request(req)
            if (filter_status is None) or (req.get("status") == filter_status):
                out.append(finance_request_defaults(req) or req)
    out.sort(key=lambda x: x.get("created_at", ""), reverse=True)
    return out


def project_fin_state_file(name: str) -> str:
    return os.path.join(proj_path(name), "finance_state.json")


def load_project_fin_state(name: str) -> dict:
    ensure_project_structure(name)
    path = project_fin_state_file(name)
    if not os.path.exists(path):
        data = {"active_requests": {}}
        save_project_fin_state(name, data)
        return data
    try:
        with open(path, "r", encoding="utf-8") as fh:
            data = json.load(fh)
            if "active_requests" not in data:
                data["active_requests"] = {}
            return data
    except Exception:
        data = {"active_requests": {}}
        save_project_fin_state(name, data)
        return data


def save_project_fin_state(name: str, data: dict):
    ensure_project_structure(name)
    path = project_fin_state_file(name)
    json.dump(data, open(path, "w", encoding="utf-8"), ensure_ascii=False, indent=2)


def fin_state_set(name: str, uid: int, req_id: str, status: str):
    state = load_project_fin_state(name)
    state.setdefault("active_requests", {})[str(uid)] = {
        "request_id": req_id,
        "status": status,
        "project": name,
        "updated_at": datetime.now().isoformat()
    }
    save_project_fin_state(name, state)


def fin_state_clear(name: str, uid: int):
    state = load_project_fin_state(name)
    if str(uid) in state.get("active_requests", {}):
        state["active_requests"].pop(str(uid), None)
        save_project_fin_state(name, state)


def fin_state_get(name: str, uid: int) -> Optional[dict]:
    state = load_project_fin_state(name)
    return (state.get("active_requests", {}) or {}).get(str(uid))


def finance_active_request_for_user(uid: int, project: str) -> Optional[dict]:
    entry = fin_state_get(project, uid)
    if not entry:
        return None
    req = finance_load_request(entry.get("request_id"), project)
    if req and req.get("status") in {"pending", "approved"}:
        return req
    fin_state_clear(project, uid)
    return None


def finance_request_defaults(obj: Optional[dict]) -> Optional[dict]:
    if not obj:
        return obj
    if not isinstance(obj.get("history"), list):
        obj["history"] = []
    if not isinstance(obj.get("items"), list):
        obj["items"] = []
    return obj


def finance_append_history(obj: dict, status: str, extra: Optional[dict] = None):
    if obj is None:
        return
    entry = {"status": status, "timestamp": datetime.now().isoformat()}
    if extra:
        entry.update(extra)
    history = obj.setdefault("history", [])
    history.append(entry)


def finance_update_items_status(obj: dict, status: str, timestamp: Optional[str] = None):
    if obj is None:
        return
    if timestamp is None:
        timestamp = datetime.now().isoformat()
    items = obj.setdefault("items", [])
    for item in items:
        if isinstance(item, dict):
            item["status"] = status
            item["updated_at"] = timestamp


def update_receipts_for_request(uid: int, project: str, files: List[str], status: str, request: dict):
    prof = load_user(uid) or {}
    recmap = prof.get("receipts", {})
    recs = recmap.get(project, [])
    if not isinstance(recs, list) or not recs:
        return
    now_iso = datetime.now().isoformat()
    req_id = request.get("id")
    req_code = request.get("code") or req_id
    changed = False
    for entry in recs:
        if entry.get("file") not in files:
            continue
        history = entry.get("payout_history")
        if not isinstance(history, list):
            history = []
            entry["payout_history"] = history
        try:
            amount_value = float(entry.get("sum", 0.0))
        except (TypeError, ValueError):
            amount_value = 0.0
        history.append({
            "status": status,
            "timestamp": now_iso,
            "request_id": req_id,
            "code": req_code,
            "project": project,
            "amount": amount_value
        })
        payout = entry.get("payout") if isinstance(entry.get("payout"), dict) else {}
        if status in ("pending", "approved"):
            payout.update({
                "request_id": req_id,
                "code": req_code,
                "status": status,
                "updated_at": now_iso
            })
            if status == "pending":
                payout.setdefault("assigned_at", now_iso)
            if status == "approved":
                payout["approved_at"] = now_iso
            entry["payout"] = payout
        elif status == "confirmed":
            payout.update({
                "request_id": req_id,
                "code": req_code,
                "status": "confirmed",
                "updated_at": now_iso,
                "confirmed_at": now_iso,
                "assigned_at": payout.get("assigned_at", now_iso),
                "approved_at": payout.get("approved_at")
            })
            entry["payout"] = payout
            entry["paid"] = True
            entry["paid_at"] = now_iso
            entry["paid_request_id"] = req_id
            entry["paid_request_code"] = req_code
        elif status == "closed":
            if entry.get("paid") is not True:
                entry.pop("paid_request_id", None)
                entry.pop("paid_request_code", None)
                entry.pop("paid_at", None)
            entry["payout"] = None
        changed = True
    if changed:
        recmap[project] = recs
        prof["receipts"] = recmap
        save_user(prof)


# ========================== RECEIPT SAVE (FILE + EXCEL) ==========================
def ensure_user_receipts_dir(project: str, uid: int):
    os.makedirs(proj_receipts_dir(project, uid), exist_ok=True)

def _excel_ensure_sheet_user(wb: Workbook, sheet_name: str):
    if sheet_name not in wb.sheetnames:
        ws = wb.create_sheet(title=sheet_name)
        ws.append(["–î–∞—Ç–∞", "–í—Ä–µ–º—è", "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å", "BSU", "–ù–æ–º–µ—Ä —á–µ–∫–∞", "–°—É–º–º–∞", "–§–∞–π–ª", "–û–ø–∏—Å–∞–Ω–∏–µ", "–û–ø–ª–∞—á–µ–Ω (1/0/None)"])
        _autosize(ws)

def _excel_append_row(project: str, username: str, bsu: str, receipt_no: str, amount: float, filename: str, desc: str, paid):
    path = proj_ledger(project)
    if not os.path.exists(path):
        wb = Workbook(); ws = wb.active; ws.title = "Ledger"
        ws.append(["–î–∞—Ç–∞", "–í—Ä–µ–º—è", "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å", "BSU", "–ù–æ–º–µ—Ä —á–µ–∫–∞", "–°—É–º–º–∞", "–§–∞–π–ª", "–û–ø–∏—Å–∞–Ω–∏–µ", "–û–ø–ª–∞—á–µ–Ω (1/0/None)"])
        _autosize(ws)
        wb.save(path)
    wb = load_workbook(path)
    if "Ledger" not in wb.sheetnames:
        ws = wb.create_sheet("Ledger", 0)
        ws.append(["–î–∞—Ç–∞", "–í—Ä–µ–º—è", "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å", "BSU", "–ù–æ–º–µ—Ä —á–µ–∫–∞", "–°—É–º–º–∞", "–§–∞–π–ª", "–û–ø–∏—Å–∞–Ω–∏–µ", "–û–ø–ª–∞—á–µ–Ω (1/0/None)"])

    ws = wb["Ledger"]
    now = datetime.now()
    paid_cell = None if paid is None else (1 if paid else 0)
    ws.append([now.strftime("%Y-%m-%d"), now.strftime("%H:%M"), username, bsu, receipt_no, float(amount), filename, desc or "", paid_cell])
    _autosize(ws)

    # –õ–∏—Å—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    user_sheet = f"{_safe_name(username)}_{bsu}"
    _excel_ensure_sheet_user(wb, user_sheet)
    wsu = wb[user_sheet]
    wsu.append([now.strftime("%Y-%m-%d"), now.strftime("%H:%M"), username, bsu, receipt_no, float(amount), filename, desc or "", paid_cell])
    _autosize(wsu)

    wb.save(path)

def save_receipt(project: str, uid: int, amount: float, tmp_img: str, desc: str, paid) -> Tuple[str, str, datetime, str]:
    ensure_user_receipts_dir(project, uid)
    now = datetime.now()
    prof = load_user(uid) or {}
    username = prof.get("fullname") or f"User{uid}"
    bsu = prof.get("bsu", f"BSU-{uid%10000:04d}")
    rid = next_receipt_no(prof)  # RID-XXXX

    base = f"{_safe_name(username)}_BSU{bsu.replace('BSU-','')}_{rid}_{now.strftime('%Y-%m-%d_%H-%M-%S')}_amt-{amount:.2f}.jpg"
    dst = os.path.join(proj_receipts_dir(project, uid), base)
    # –ø–µ—Ä–µ—Å—Ç—Ä–∞—Ö–æ–≤–∫–∞ –Ω–∞ —É–Ω–∏–∫–∞–ª—å–Ω–æ—Å—Ç—å
    i = 1
    while os.path.exists(dst):
        base = f"{_safe_name(username)}_BSU{bsu.replace('BSU-','')}_{rid}_{now.strftime('%Y-%m-%d_%H-%M-%S')}_{i}_amt-{amount:.2f}.jpg"
        dst = os.path.join(proj_receipts_dir(project, uid), base)
        i += 1
    if tmp_img and os.path.exists(tmp_img):
        os.replace(tmp_img, dst)

    _excel_append_row(project, username, bsu, rid, amount, base, desc, paid)
    user_append_receipt(uid, project, now.strftime("%Y-%m-%d"), now.strftime("%H:%M"), amount, base, desc, paid, rid)
    return base, dst, now, rid


# ========================== HELPERS & MEN–£–° ==========================
def fmt_money(x: float) -> str: return f"{x:.2f}"


def h(value: Any) -> str:
    if value is None:
        return ""
    return html_escape(str(value), quote=False)


def format_datetime_short(value: Optional[str]) -> str:
    if not value:
        return ""
    try:
        return datetime.fromisoformat(value).strftime("%Y-%m-%d %H:%M")
    except Exception:
        return str(value)


def format_day_month(value: Optional[str]) -> str:
    if not value:
        return ""
    try:
        return datetime.fromisoformat(value).strftime("%d.%m")
    except Exception:
        return ""


NP_FIELD_LABELS = {
    "uk": {
        "ttn": "–¢–¢–ù",
        "status": "–°—Ç–∞—Ç—É—Å",
        "last_update": "–û–Ω–æ–≤–ª–µ–Ω–æ",
        "delivery_date": "–ü–ª–∞–Ω–æ–≤–∞ –¥–æ—Å—Ç–∞–≤–∫–∞",
        "estimated_date": "–û—Ä—ñ—î–Ω—Ç–æ–≤–Ω–æ",
        "recipient": "–Ü–º‚Äô—è",
        "recipient_city": "–ú—ñ—Å—Ç–æ",
        "recipient_warehouse": "–í—ñ–¥–¥—ñ–ª–µ–Ω–Ω—è",
        "sender": "–Ü–º‚Äô—è",
        "sender_city": "–ú—ñ—Å—Ç–æ",
        "sender_warehouse": "–í—ñ–¥–¥—ñ–ª–µ–Ω–Ω—è",
        "service_type": "–°–µ—Ä–≤—ñ—Å",
        "weight": "–í–∞–≥–∞",
        "cost": "–û—Ü—ñ–Ω–æ—á–Ω–∞ –≤–∞—Ä—Ç—ñ—Å—Ç—å",
        "section_summary": "–°–í–û–î–ö–ê",
        "section_recipient": "–û–¢–†–ò–ú–£–í–ê–ß",
        "section_sender": "–í–Ü–î–ü–†–ê–í–ù–ò–ö",
        "section_parcel": "–ü–û–°–ò–õ–ö–ê",
    },
    "en": {
        "ttn": "TTN",
        "status": "Status",
        "last_update": "Updated",
        "delivery_date": "Planned delivery",
        "estimated_date": "Estimated",
        "recipient": "Name",
        "recipient_city": "City",
        "recipient_warehouse": "Branch",
        "sender": "Name",
        "sender_city": "City",
        "sender_warehouse": "Branch",
        "service_type": "Service",
        "weight": "Weight",
        "cost": "Declared value",
        "section_summary": "Summary",
        "section_recipient": "Recipient",
        "section_sender": "Sender",
        "section_parcel": "Parcel",
    },
    "de": {
        "ttn": "TTN",
        "status": "Status",
        "last_update": "Aktualisiert",
        "delivery_date": "Geplante Zustellung",
        "estimated_date": "Voraussichtlich",
        "recipient": "Name",
        "recipient_city": "Stadt",
        "recipient_warehouse": "Filiale",
        "sender": "Name",
        "sender_city": "Stadt",
        "sender_warehouse": "Filiale",
        "service_type": "Service",
        "weight": "Gewicht",
        "cost": "Deklarierter Wert",
        "section_summary": "√úbersicht",
        "section_recipient": "Empf√§nger",
        "section_sender": "Absender",
        "section_parcel": "Sendung",
    },
    "pl": {
        "ttn": "TTN",
        "status": "Status",
        "last_update": "Aktualizacja",
        "delivery_date": "Planowana dostawa",
        "estimated_date": "Szacunkowo",
        "recipient": "Imiƒô",
        "recipient_city": "Miasto",
        "recipient_warehouse": "Oddzia≈Ç",
        "sender": "Imiƒô",
        "sender_city": "Miasto",
        "sender_warehouse": "Oddzia≈Ç",
        "service_type": "Us≈Çuga",
        "weight": "Waga",
        "cost": "Deklarowana warto≈õƒá",
        "section_summary": "Podsumowanie",
        "section_recipient": "Odbiorca",
        "section_sender": "Nadawca",
        "section_parcel": "Przesy≈Çka",
    },
    "ru": {
        "ttn": "–¢–¢–ù",
        "status": "–°—Ç–∞—Ç—É—Å",
        "last_update": "–û–±–Ω–æ–≤–ª–µ–Ω–æ",
        "delivery_date": "–ü–ª–∞–Ω–æ–≤–∞—è –¥–æ—Å—Ç–∞–≤–∫–∞",
        "estimated_date": "–û—Ä–∏–µ–Ω—Ç–∏—Ä–æ–≤–æ—á–Ω–æ",
        "recipient": "–ò–º—è",
        "recipient_city": "–ì–æ—Ä–æ–¥",
        "recipient_warehouse": "–û—Ç–¥–µ–ª–µ–Ω–∏–µ",
        "sender": "–ò–º—è",
        "sender_city": "–ì–æ—Ä–æ–¥",
        "sender_warehouse": "–û—Ç–¥–µ–ª–µ–Ω–∏–µ",
        "service_type": "–°–µ—Ä–≤–∏—Å",
        "weight": "–í–µ—Å",
        "cost": "–û—Ü–µ–Ω–æ—á–Ω–∞—è —Å—Ç–æ–∏–º–æ—Å—Ç—å",
        "section_summary": "–°–í–û–î–ö–ê",
        "section_recipient": "–ü–û–õ–£–ß–ê–¢–ï–õ–¨",
        "section_sender": "–û–¢–ü–†–ê–í–ò–¢–ï–õ–¨",
        "section_parcel": "–ü–û–°–´–õ–ö–ê",
    },
}

NP_WEIGHT_SUFFIX = {
    "uk": " –∫–≥",
    "en": " kg",
    "de": " kg",
    "pl": " kg",
    "ru": " –∫–≥",
}

NP_COST_SUFFIX = {
    "uk": " –≥—Ä–Ω",
    "en": " UAH",
    "de": " UAH",
    "pl": " UAH",
    "ru": " –≥—Ä–Ω",
}

NP_SECTION_ICONS = {
    "section_summary": "üìå",
    "section_recipient": "üéØ",
    "section_sender": "üöö",
    "section_parcel": "üì¶",
}

NP_TTN_TITLE = {
    "uk": "üßæ <b>Nova Poshta ‚Äî –∫–≤–∏—Ç–∞–Ω—Ü—ñ—è</b>\nüîñ –¢–¢–ù: <code>{ttn}</code>",
    "en": "üßæ <b>Nova Poshta ‚Äî receipt</b>\nüîñ TTN: <code>{ttn}</code>",
    "de": "üßæ <b>Nova Poshta ‚Äî Beleg</b>\nüîñ TTN: <code>{ttn}</code>",
    "pl": "üßæ <b>Nova Poshta ‚Äî potwierdzenie</b>\nüîñ TTN: <code>{ttn}</code>",
    "ru": "üßæ <b>Nova Poshta ‚Äî –∫–≤–∏—Ç–∞–Ω—Ü–∏—è</b>\nüîñ –¢–¢–ù: <code>{ttn}</code>",
}

NP_ASSIGN_INFO_LINE = {
    "uk": "üè¢ –ü–µ—Ä–µ–¥–∞–≤ –∞–¥–º—ñ–Ω—ñ—Å—Ç—Ä–∞—Ç–æ—Ä: {name} ‚Ä¢ {time}",
    "en": "üè¢ Assigned by admin {name} ‚Ä¢ {time}",
    "de": "üè¢ Zugewiesen durch Admin {name} ‚Ä¢ {time}",
    "pl": "üè¢ Przypisane przez admina {name} ‚Ä¢ {time}",
    "ru": "üè¢ –ü–µ—Ä–µ–¥–∞–ª –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä: {name} ‚Ä¢ {time}",
}

NP_ASSIGN_DELIVERED_LINE = {
    "uk": "‚úÖ –û—Ç—Ä–∏–º–∞–Ω–Ω—è –ø—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω–æ: {time}",
    "en": "‚úÖ Delivery confirmed: {time}",
    "de": "‚úÖ Empfang best√§tigt: {time}",
    "pl": "‚úÖ Odbi√≥r potwierdzony: {time}",
    "ru": "‚úÖ –ü–æ–ª—É—á–µ–Ω–∏–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–æ: {time}",
}

NP_ADMIN_NOTE_PREFIX = {
    "uk": "üí¨ –ö–æ–º–µ–Ω—Ç–∞—Ä –∞–¥–º—ñ–Ω—ñ—Å—Ç—Ä–∞—Ç–æ—Ä–∞: {note}",
    "en": "üí¨ Admin note: {note}",
    "de": "üí¨ Hinweis des Admins: {note}",
    "pl": "üí¨ Notatka administratora: {note}",
    "ru": "üí¨ –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞: {note}",
}

NP_COMMENT_SECTION_TITLE = {
    "uk": "üí¨ –ö–æ–º–µ–Ω—Ç–∞—Ä—ñ ({count})",
    "en": "üí¨ Comments ({count})",
    "de": "üí¨ Kommentare ({count})",
    "pl": "üí¨ Komentarze ({count})",
    "ru": "üí¨ –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ ({count})",
}

NP_DELIVERY_RECEIPT_TITLE = {
    "uk": "üì¶ –ü–æ—Å–∏–ª–∫–∞ –æ—Ç—Ä–∏–º–∞–Ω–∞",
    "en": "üì¶ Parcel received",
    "de": "üì¶ Sendung erhalten",
    "pl": "üì¶ Przesy≈Çka odebrana",
    "ru": "üì¶ –ü–æ—Å—ã–ª–∫–∞ –ø–æ–ª—É—á–µ–Ω–∞",
}

NP_DELIVERY_STATUS_CONFIRMED = {
    "uk": "–ü—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω–æ",
    "en": "Confirmed",
    "de": "Best√§tigt",
    "pl": "Potwierdzono",
    "ru": "–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–æ",
}

NP_DELIVERY_RECEIPT_LABELS = {
    "uk": {"ttn": "–¢–¢–ù", "recipient": "–û—Ç—Ä–∏–º—É–≤–∞—á", "date": "–î–∞—Ç–∞", "status": "–°—Ç–∞—Ç—É—Å"},
    "en": {"ttn": "TTN", "recipient": "Recipient", "date": "Date", "status": "Status"},
    "de": {"ttn": "TTN", "recipient": "Empf√§nger", "date": "Datum", "status": "Status"},
    "pl": {"ttn": "TTN", "recipient": "Odbiorca", "date": "Data", "status": "Status"},
    "ru": {"ttn": "–¢–¢–ù", "recipient": "–ü–æ–ª—É—á–∞—Ç–µ–ª—å", "date": "–î–∞—Ç–∞", "status": "–°—Ç–∞—Ç—É—Å"},
}

NP_DATETIME_CARD_FORMATS = {
    "uk": "%d.%m.%Y ‚Ä¢ %H:%M",
    "en": "%d.%m.%Y ‚Ä¢ %H:%M",
    "de": "%d.%m.%Y ‚Ä¢ %H:%M",
    "pl": "%d.%m.%Y ‚Ä¢ %H:%M",
    "ru": "%d.%m.%Y ‚Ä¢ %H:%M",
}

NP_REFRESH_BUTTON_LABEL = {
    "uk": "üîÑ –û–Ω–æ–≤–∏—Ç–∏",
    "en": "üîÑ Refresh",
    "de": "üîÑ Aktualisieren",
    "pl": "üîÑ Od≈õwie≈º",
    "ru": "üîÑ –û–±–Ω–æ–≤–∏—Ç—å",
}

NP_NOTE_BUTTON_LABEL = {
    "uk": "üí¨ –î–æ–¥–∞—Ç–∏ –∫–æ–º–µ–Ω—Ç–∞—Ä",
    "en": "üí¨ Add comment",
    "de": "üí¨ Kommentar hinzuf√ºgen",
    "pl": "üí¨ Dodaj komentarz",
    "ru": "üí¨ –î–æ–±–∞–≤–∏—Ç—å –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π",
}

NP_CLOSE_BUTTON_LABEL = {
    "uk": "‚ùå –ó–∞–∫—Ä–∏—Ç–∏",
    "en": "‚ùå Close",
    "de": "‚ùå Schlie√üen",
    "pl": "‚ùå Zamknij",
    "ru": "‚ùå –ó–∞–∫—Ä—ã—Ç—å",
}

NP_BOOKMARK_ADD_BUTTON = {
    "uk": "‚≠ê –î–æ–¥–∞—Ç–∏ –≤ –æ–±—Ä–∞–Ω–µ",
    "en": "‚≠ê Bookmark",
    "de": "‚≠ê Merken",
    "pl": "‚≠ê Oznacz",
    "ru": "‚≠ê –û—Ç–º–µ—Ç–∏—Ç—å",
}

NP_BOOKMARK_REMOVE_BUTTON = {
    "uk": "‚≠ê –ü—Ä–∏–±—Ä–∞—Ç–∏ –∑ –æ–±—Ä–∞–Ω–æ–≥–æ",
    "en": "‚≠ê Remove bookmark",
    "de": "‚≠ê Entfernen",
    "pl": "‚≠ê Usu≈Ñ oznaczenie",
    "ru": "‚≠ê –£–¥–∞–ª–∏—Ç—å –æ—Ç–º–µ—Ç–∫—É",
}

NP_MARK_RECEIVED_LABEL = {
    "uk": "‚úÖ –ü–æ—Å–∏–ª–∫—É –æ—Ç—Ä–∏–º–∞–Ω–æ",
    "en": "‚úÖ Parcel received",
    "de": "‚úÖ Sendung erhalten",
    "pl": "‚úÖ Przesy≈Çka odebrana",
    "ru": "‚úÖ –ü–æ—Å—ã–ª–∫–∞ –ø–æ–ª—É—á–µ–Ω–∞",
}

NP_CANCEL_BUTTON_LABEL = {
    "uk": "‚ùå –°–∫–∞—Å—É–≤–∞—Ç–∏",
    "en": "‚ùå Cancel",
    "de": "‚ùå Abbrechen",
    "pl": "‚ùå Anuluj",
    "ru": "‚ùå –û—Ç–º–µ–Ω–∏—Ç—å",
}

NP_ASSIGN_SKIP_BUTTON_LABEL = {
    "uk": "‚è≠ –ü—Ä–æ–ø—É—Å—Ç–∏—Ç–∏",
    "en": "‚è≠ Skip",
    "de": "‚è≠ √úberspringen",
    "pl": "‚è≠ Pomi≈Ñ",
    "ru": "‚è≠ –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å",
}

NP_CANCEL_WORDS = {"–æ—Ç–º–µ–Ω–∞", "cancel", "—Å–∫–∞—Å—É–≤–∞—Ç–∏", "–≤—ñ–¥–º—ñ–Ω–∞", "anuluj", "abbrechen", "stop"}


def _np_pick(lang: str, mapping: Dict[str, str]) -> str:
    return mapping.get(lang) or mapping.get(DEFAULT_LANG) or next(iter(mapping.values()))


def _np_format_weight(lang: str, value: Any) -> str:
    try:
        num = float(str(value).replace(",", "."))
        if abs(num - round(num)) < 0.01:
            num_disp = str(int(round(num)))
        else:
            num_disp = f"{num:.2f}".rstrip("0").rstrip(".")
    except Exception:
        return str(value)
    return f"{num_disp}{_np_pick(lang, NP_WEIGHT_SUFFIX)}"


def _np_format_cost(lang: str, value: Any) -> str:
    try:
        num = float(str(value).replace(",", "."))
    except Exception:
        return str(value)
    return f"{fmt_money(num)}{_np_pick(lang, NP_COST_SUFFIX)}"


def format_np_short_entry(payload: Optional[dict]) -> str:
    if not payload:
        return ""
    status = str(payload.get("Status") or payload.get("StatusCode") or payload.get("StatusDescription") or "").strip()
    city = str(payload.get("CityRecipient") or payload.get("CitySender") or "").strip()
    if status and city:
        return f"{status} ¬∑ {city}"
    return status or city


def _np_extract_value(payload: Optional[dict], *keys: str) -> str:
    if not payload:
        return ""
    for key in keys:
        if key is None:
            continue
        raw = payload.get(key)
        if raw is None:
            continue
        if isinstance(raw, (int, float)):
            value = f"{raw}"
        else:
            value = str(raw)
        value = value.strip()
        if value:
            return value
    return ""


def _np_render_receipt_block(entries: List[Tuple[str, ...]]) -> str:
    items: List[Dict[str, Any]] = []
    for entry in entries:
        if not entry:
            continue
        kind = entry[0]
        if kind == "sep":
            if items and items[-1]["type"] != "sep":
                items.append({"type": "sep"})
            continue
        if kind == "section":
            title = str(entry[1]).strip()
            if title:
                items.append({"type": "section", "text": title})
            continue
        label = str(entry[1]).strip()
        value = ""
        if len(entry) > 2 and entry[2] is not None:
            value = str(entry[2]).strip()
        if not value and kind == "kv_opt":
            continue
        if not value:
            value = "‚Äî"
        items.append({"type": "kv", "label": label or "‚Äî", "value": value})

    while items and items[-1]["type"] == "sep":
        items.pop()

    if not items:
        return "‚Äî"

    kv_items = [item for item in items if item["type"] == "kv"]
    label_width = max((len(item["label"]) for item in kv_items), default=0)
    value_column = max(20, min(40, label_width + 4))

    lines: List[str] = []
    for item in items:
        if item["type"] == "sep":
            if lines and lines[-1] != "":
                lines.append("")
            continue
        if item["type"] == "section":
            if lines and lines[-1] != "":
                lines.append("")
            lines.append(item["text"])
            continue
        label = item["label"].strip()
        prefix = f"{label}:" if label else ""
        gap = value_column - len(prefix)
        if gap < 2:
            gap = 2
        spaces = " " * gap
        raw_value = item["value"]
        value_lines = [line.strip() for line in raw_value.splitlines()] or ["‚Äî"]
        first_line = value_lines[0] or "‚Äî"
        line_prefix = prefix + spaces
        lines.append(line_prefix + first_line)
        indent = " " * len(line_prefix)
        for extra in value_lines[1:]:
            extra_line = extra or "‚Äî"
            lines.append(indent + extra_line)

    while lines and lines[-1] == "":
        lines.pop()

    return "\n".join(lines)


def np_format_delivery_timestamp(value: Optional[str], lang: str) -> str:
    if not value:
        return ""
    raw = str(value)
    try:
        dt = datetime.fromisoformat(raw)
    except Exception:
        try:
            dt = datetime.strptime(raw, "%Y-%m-%d %H:%M")
        except Exception:
            return raw
    fmt = NP_DATETIME_CARD_FORMATS.get(lang) or NP_DATETIME_CARD_FORMATS.get(DEFAULT_LANG) or "%d.%m.%Y ‚Ä¢ %H:%M"
    try:
        return dt.strftime(fmt)
    except Exception:
        return raw


def np_render_delivery_receipt(lang: str, ttn: Any, recipient: Any, delivered_at: Optional[str]) -> str:
    labels = (
        NP_DELIVERY_RECEIPT_LABELS.get(lang)
        or NP_DELIVERY_RECEIPT_LABELS.get(DEFAULT_LANG)
        or next(iter(NP_DELIVERY_RECEIPT_LABELS.values()))
    )
    entries: List[Tuple[str, ...]] = [
        ("kv", labels.get("ttn", "TTN"), str(ttn) if ttn is not None else ""),
        ("kv", labels.get("recipient", "Recipient"), str(recipient) if recipient is not None else ""),
        ("kv", labels.get("date", "Date"), np_format_delivery_timestamp(delivered_at, lang)),
        ("kv", labels.get("status", "Status"), _np_pick(lang, NP_DELIVERY_STATUS_CONFIRMED)),
    ]
    block_plain = _np_render_receipt_block(entries)
    header = _np_pick(lang, NP_DELIVERY_RECEIPT_TITLE)
    return f"{header}\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n<pre>{html_escape(block_plain)}</pre>"


def format_np_status(uid: int, ttn: str, payload: Optional[dict],
                     note_entries: Optional[List[Dict[str, Any]]] = None,
                     assignment: Optional[dict] = None) -> str:
    lang = resolve_lang(uid)
    labels = NP_FIELD_LABELS.get(lang) or NP_FIELD_LABELS[DEFAULT_LANG]
    header = _np_pick(lang, NP_TTN_TITLE).format(ttn=h(ttn))

    def field_label(key: str) -> str:
        return labels.get(key, key)

    def section_title(key: str) -> str:
        base = labels.get(key, key)
        icon = NP_SECTION_ICONS.get(key)
        title = base.strip().upper()
        if icon and not title.startswith(icon):
            return f"{icon} {title}"
        return title

    summary_rows: List[Tuple[str, ...]] = [
        ("section", section_title("section_summary")),
        ("kv", field_label("ttn"), str(ttn)),
        ("kv", field_label("status"), _np_extract_value(payload, "Status", "StatusDescription", "StatusCode") or "‚Äî"),
    ]

    last_update = _np_extract_value(payload, "LastUpdatedDate")
    if last_update:
        summary_rows.append(("kv_opt", field_label("last_update"), last_update))
    delivery_date = _np_extract_value(payload, "ScheduledDeliveryDate")
    if delivery_date:
        summary_rows.append(("kv_opt", field_label("delivery_date"), delivery_date))
    estimated_date = _np_extract_value(payload, "EstimatedDeliveryDate")
    if estimated_date:
        summary_rows.append(("kv_opt", field_label("estimated_date"), estimated_date))

    recipient_section: List[Tuple[str, ...]] = []
    recipient_name = _np_extract_value(payload, "RecipientFullName", "RecipientDescription", "RecipientName")
    if recipient_name:
        recipient_section.append(("kv", field_label("recipient"), recipient_name))
    recipient_city = _np_extract_value(payload, "CityRecipient")
    if recipient_city:
        recipient_section.append(("kv_opt", field_label("recipient_city"), recipient_city))
    recipient_branch = _np_extract_value(payload, "WarehouseRecipient")
    if recipient_branch:
        recipient_section.append(("kv_opt", field_label("recipient_warehouse"), recipient_branch))

    sender_section: List[Tuple[str, ...]] = []
    sender_name = _np_extract_value(payload, "SenderFullNameEW", "SenderFullName", "SenderName")
    if sender_name:
        sender_section.append(("kv", field_label("sender"), sender_name))
    sender_city = _np_extract_value(payload, "CitySender")
    if sender_city:
        sender_section.append(("kv_opt", field_label("sender_city"), sender_city))
    sender_branch = _np_extract_value(payload, "WarehouseSender")
    if sender_branch:
        sender_section.append(("kv_opt", field_label("sender_warehouse"), sender_branch))

    parcel_section: List[Tuple[str, ...]] = []
    service_type = _np_extract_value(payload, "ServiceType")
    if service_type:
        parcel_section.append(("kv_opt", field_label("service_type"), service_type))
    weight_raw = _np_extract_value(payload, "DocumentWeight", "FactualWeight")
    if weight_raw:
        parcel_section.append(("kv", field_label("weight"), _np_format_weight(lang, weight_raw)))
    cost_raw = _np_extract_value(payload, "DocumentCost", "EstimatedDeliveryCost")
    if cost_raw:
        parcel_section.append(("kv", field_label("cost"), _np_format_cost(lang, cost_raw)))

    receipt_entries: List[Tuple[str, ...]] = list(summary_rows)

    def push_section(title_key: str, rows: List[Tuple[str, ...]]):
        if not rows:
            return
        if receipt_entries:
            receipt_entries.append(("sep",))
        receipt_entries.append(("section", section_title(title_key)))
        receipt_entries.extend(rows)

    push_section("section_recipient", recipient_section)
    push_section("section_sender", sender_section)
    push_section("section_parcel", parcel_section)

    block_plain = _np_render_receipt_block(receipt_entries)
    block_html = f"<pre>{html_escape(block_plain)}</pre>"

    note_entries = list(note_entries or [])

    parts: List[str] = [header, block_html]

    footer_lines: List[str] = []
    comment_lines: List[str] = []
    if note_entries:
        comment_lines.append(_np_pick(lang, NP_COMMENT_SECTION_TITLE).format(count=len(note_entries)))
        for note in note_entries[:3]:
            timestamp_raw = note.get("timestamp") if isinstance(note, dict) else None
            timestamp = format_datetime_short(timestamp_raw) or (timestamp_raw or "")
            timestamp_disp = h(timestamp) if timestamp else "‚Äî"
            note_text = (note.get("text") if isinstance(note, dict) else "") or ""
            snippet = _np_trim_label(note_text.strip(), 220) if note_text else "‚Äî"
            comment_lines.append(f"‚Ä¢ {timestamp_disp} ‚Äî {h(snippet)}")
        if len(note_entries) > 3:
            comment_lines.append("‚Ä¶")
    if comment_lines:
        footer_lines.extend(comment_lines)

    assignment_lines: List[str] = []
    if assignment:
        admin_id = assignment.get("assigned_by")
        admin_name = None
        if admin_id:
            prof = load_user(admin_id) or {}
            admin_name = prof.get("fullname") or prof.get("tg", {}).get("first_name")
        admin_display = admin_name or (f"ID {admin_id}" if admin_id else "‚Äî")
        assigned_time = format_datetime_short(assignment.get("created_at")) or assignment.get("created_at") or "‚Äî"
        assignment_lines.append(
            _np_pick(lang, NP_ASSIGN_INFO_LINE).format(name=h(admin_display), time=h(assigned_time))
        )
        note_text = assignment.get("note")
        if note_text:
            assignment_lines.append(_np_pick(lang, NP_ADMIN_NOTE_PREFIX).format(note=h(note_text)))
        delivered_at = assignment.get("delivered_at")
        if delivered_at:
            delivered_time = format_datetime_short(delivered_at) or delivered_at or "‚Äî"
            assignment_lines.append(
                _np_pick(lang, NP_ASSIGN_DELIVERED_LINE).format(time=h(delivered_time))
            )

    if assignment_lines:
        if footer_lines:
            footer_lines.append("")
        footer_lines.extend(assignment_lines)

    if footer_lines:
        parts.append("\n".join(footer_lines))

    return "\n\n".join(part for part in parts if part)


async def np_send_card(uid: int, chat_id: int, text: str,
                       kb: Optional[InlineKeyboardMarkup] = None) -> types.Message:
    runtime = users_runtime.setdefault(uid, {})
    previous = runtime.get("np_last_card")
    if isinstance(previous, (list, tuple)) and len(previous) == 2:
        prev_chat, prev_mid = previous
        try:
            await bot.delete_message(prev_chat, prev_mid)
        except Exception:
            pass
        flow_items = runtime.get("flow_msgs", [])
        runtime["flow_msgs"] = [item for item in flow_items if not (item[0] == prev_chat and item[1] == prev_mid)]
    msg = await bot.send_message(chat_id, text, reply_markup=kb, disable_web_page_preview=True)
    flow_track(uid, msg)
    runtime["np_last_card"] = (msg.chat.id, msg.message_id)
    return msg


def np_prepare_view(uid: int, ttn: str, payload: Optional[dict] = None,
                    force_fetch: bool = False,
                    allow_bookmark: bool = True) -> Tuple[Optional[str], Optional[InlineKeyboardMarkup], Optional[dict], Optional[dict], Optional[str]]:
    actual_payload = payload or np_get_cached_status(uid, ttn)
    error_message = None
    if force_fetch or actual_payload is None:
        success, fetched_payload, error_message = np_fetch_tracking(ttn)
        if not success:
            return None, None, None, None, error_message
        actual_payload = fetched_payload
        np_remember_search(uid, ttn, actual_payload)

    assignment = np_get_assignment(ttn)
    if actual_payload and assignment:
        np_refresh_assignment_status(ttn, actual_payload)

    if assignment and not (assignment.get("assigned_to") == uid or uid in admins):
        assignment_display = None
    else:
        assignment_display = assignment

    notes_map = np_list_notes(uid, ttn)
    note_entries = notes_map.get(ttn, [])
    text = format_np_status(uid, ttn, actual_payload, note_entries=note_entries, assignment=assignment_display)
    kb = kb_np_result(
        uid,
        ttn,
        bookmarked=np_has_bookmark(uid, ttn),
        allow_assign=(uid in admins),
        assignment=assignment_display,
        allow_bookmark=allow_bookmark,
    )
    return text, kb, actual_payload, assignment_display, None


def receipt_status_text(paid, target: Any = DEFAULT_LANG) -> str:
    if paid is True:
        return tr(target, "STATUS_PAID")
    if paid is False:
        return tr(target, "STATUS_UNPAID")
    return tr(target, "STATUS_UNKNOWN")


def format_receipt_caption(receipt: dict, project: Optional[str] = None) -> str:
    date_part = h(receipt.get("date", "‚Äî")) or "‚Äî"
    time_raw = receipt.get("time")
    date_line = f"üìÖ {date_part} {h(time_raw)}".strip() if time_raw else f"üìÖ {date_part}"
    try:
        amount = float(receipt.get("sum", 0.0))
    except (TypeError, ValueError):
        amount = 0.0
    desc = receipt.get("desc")
    desc_text = h(desc) if desc else "‚Äî"
    file_name = receipt.get("file")
    file_text = h(file_name) if file_name else "‚Äî"
    lines = [f"üÜî –ù–æ–º–µ—Ä: <b>{h(receipt.get('receipt_no', '‚Äî'))}</b>"]
    if project:
        lines.append(f"üìÇ –ü—Ä–æ–µ–∫—Ç: <b>{h(project)}</b>")
    lines.append(date_line)
    lines.append(f"üí∞ {fmt_money(amount)} –≥—Ä–Ω")
    lines.append(f"üìù {desc_text}")
    lines.append(f"üîñ {receipt_status_text(receipt.get('paid'))}")
    lines.append(f"üìÑ {file_text}")
    payout = receipt.get("payout") if isinstance(receipt.get("payout"), dict) else None
    if payout and payout.get("status"):
        code_raw = payout.get("code") or payout.get("request_id")
        code_txt = h(code_raw) if code_raw else "‚Äî"
        status = payout.get("status")
        if status == "pending":
            ts = format_datetime_short(payout.get("assigned_at") or payout.get("updated_at"))
            tail = f" ({ts})" if ts else ""
            lines.append(f"‚è≥ –ó–∞–ø—Ä–æ—Å: {code_txt}{tail}")
        elif status == "approved":
            ts = format_datetime_short(payout.get("updated_at"))
            tail = f" ({ts})" if ts else ""
            lines.append(f"üí∂ –ó–∞–ø—Ä–æ—Å –æ–¥–æ–±—Ä–µ–Ω: {code_txt}{tail}")
        elif status == "confirmed":
            ts = format_datetime_short(payout.get("confirmed_at"))
            tail = f" ({ts})" if ts else ""
            lines.append(f"üí∏ –í—ã–ø–ª–∞—Ç–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞: {code_txt}{tail}")
        elif status == "closed":
            ts = format_datetime_short(payout.get("updated_at"))
            tail = f" ({ts})" if ts else ""
            lines.append(f"üì≠ –ó–∞–ø—Ä–æ—Å –∑–∞–∫—Ä—ã—Ç: {code_txt}{tail}")
    elif receipt.get("paid") is True:
        ts = format_datetime_short(receipt.get("paid_at"))
        code_txt = h(receipt.get("paid_request_code")) if receipt.get("paid_request_code") else None
        if code_txt:
            tail = f" ({ts})" if ts else ""
            lines.append(f"üí∏ –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–æ –ø–æ {code_txt}{tail}")
        elif ts:
            lines.append(f"üí∏ –û–ø–ª–∞—á–µ–Ω–æ {ts}")
    return "\n".join(lines)


def format_photo_caption(project_info: dict, entry: dict) -> str:
    project_name = h(project_info.get("name", "‚Äî")) or "‚Äî"
    project_code = h(project_info.get("code") or "‚Äî")
    original = h(entry.get("original") or entry.get("file") or "‚Äî")
    stored = h(entry.get("file") or "‚Äî")
    uploader_name = h(entry.get("uploader_name") or "‚Äî")
    uploader_bsu = h(entry.get("uploader_bsu") or "‚Äî")
    uploader_id = entry.get("uploader_id")
    uploader_id_text = h(str(uploader_id)) if uploader_id is not None else "‚Äî"
    uploaded_at = format_datetime_short(entry.get("uploaded_at")) or "‚Äî"

    lines = [
        "üñº <b>–ö–∞—Ä—Ç–æ—á–∫–∞ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏</b>",
        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ",
        f"üèó –û–±—ä–µ–∫—Ç: <b>{project_name}</b> ({project_code})",
        f"üìõ –û—Ä–∏–≥–∏–Ω–∞–ª: {original}",
        f"üìÇ –§–∞–π–ª –∞—Ä—Ö–∏–≤–∞: {stored}",
        f"üë§ –ê–≤—Ç–æ—Ä: {uploader_name} (ID {uploader_id_text}, {uploader_bsu})",
        f"üïí –ó–∞–≥—Ä—É–∂–µ–Ω–æ: {h(uploaded_at)}",
    ]

    meta = entry.get("meta") if isinstance(entry.get("meta"), dict) else {}
    meta_lines: List[str] = []
    captured = meta.get("captured_at")
    if captured:
        meta_lines.append(f"üì∏ –î–∞—Ç–∞ —Å—ä—ë–º–∫–∏: {h(captured)}")
    gps = meta.get("gps") if isinstance(meta, dict) else None
    if isinstance(gps, dict) and gps.get("lat") is not None and gps.get("lon") is not None:
        meta_lines.append(f"üåê –ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã: {gps['lat']:.6f}, {gps['lon']:.6f}")
    address = meta.get("address")
    if address:
        meta_lines.append(f"üèô –õ–æ–∫–∞—Ü–∏—è (EXIF): {h(address)}")
    camera = meta.get("camera")
    if camera:
        meta_lines.append(f"üì∑ –ö–∞–º–µ—Ä–∞: {h(camera)}")

    if meta_lines:
        lines.append("")
        lines.extend(meta_lines)

    lines.extend(["", "‚ÑπÔ∏è –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫–∏ –ø–æ–¥ —Å–æ–æ–±—â–µ–Ω–∏–µ–º, —á—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å –æ—Ä–∏–≥–∏–Ω–∞–ª –∏–ª–∏ –∑–∞–∫—Ä—ã—Ç—å –∫–∞—Ä—Ç–æ—á–∫—É."])
    return "\n".join(lines)


def photo_entry_keyboard(project: str, entry: dict, viewer_id: int, *, file_exists: bool = True) -> InlineKeyboardMarkup:
    kb = InlineKeyboardMarkup()
    entry_id = entry.get("id") or entry.get("file")
    project_id = project_token(project)
    buttons: List[InlineKeyboardButton] = []
    if entry_id and file_exists:
        buttons.append(InlineKeyboardButton("üì§ –û—Ä–∏–≥–∏–Ω–∞–ª", callback_data=f"photo_original:{project_id}:{entry_id}"))
    if entry_id and (viewer_id in admins or viewer_id == entry.get("uploader_id")):
        buttons.append(InlineKeyboardButton("üóë –£–¥–∞–ª–∏—Ç—å", callback_data=f"photo_delete:{project_id}:{entry_id}"))
    if buttons:
        kb.row(*buttons)
    kb.add(InlineKeyboardButton("‚ùå –ó–∞–∫—Ä—ã—Ç—å", callback_data="broadcast_close"))
    return kb


def format_receipt_stat_entry(index: int, receipt: dict) -> str:
    indent = "&nbsp;&nbsp;&nbsp;"
    rid = h(receipt.get("receipt_no", "‚Äî")) or "‚Äî"
    date_text = h(receipt.get("date") or "‚Äî") or "‚Äî"
    time_raw = receipt.get("time")
    if time_raw:
        date_text = f"{date_text} {h(time_raw)}"
    try:
        amount = float(receipt.get("sum", 0.0))
    except (TypeError, ValueError):
        amount = 0.0
    desc = receipt.get("desc")
    desc_text = h(desc) if desc else "‚Äî"
    file_name = receipt.get("file")
    file_text = h(file_name) if file_name else "‚Äî"
    status_text = receipt_status_text(receipt.get("paid"))
    lines = [
        f"{index:02d}. <b>{rid}</b>",
        f"{indent}üìÖ {date_text}",
        f"{indent}üí∞ {fmt_money(amount)} –≥—Ä–Ω ‚Äî {status_text}",
        f"{indent}üìù {desc_text}",
        f"{indent}üìÑ {file_text}",
    ]
    payout_note = ""
    payout_obj = receipt.get("payout") if isinstance(receipt.get("payout"), dict) else None
    if payout_obj and payout_obj.get("status"):
        status = payout_obj.get("status")
        icon_map = {
            "pending": "‚è≥",
            "approved": "üí∂",
            "confirmed": "üí∏",
            "closed": "üì≠",
        }
        label_map = {
            "pending": "–ó–∞–ø—Ä–æ—Å –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É",
            "approved": "–í—ã–ø–ª–∞—Ç–∞ –æ–¥–æ–±—Ä–µ–Ω–∞",
            "confirmed": "–í—ã–ø–ª–∞—Ç–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞",
            "closed": "–ó–∞–ø—Ä–æ—Å –∑–∞–∫—Ä—ã—Ç",
        }
        icon = icon_map.get(status, "‚ÑπÔ∏è")
        label = label_map.get(status, status)
        extras: List[str] = []
        code = payout_obj.get("code") or payout_obj.get("request_id")
        if code:
            extras.append(f"ID {h(code)}")
        stamp = format_datetime_short(
            payout_obj.get("updated_at")
            or payout_obj.get("confirmed_at")
            or payout_obj.get("assigned_at")
        )
        if stamp:
            extras.append(stamp)
        if extras:
            payout_note = f"{icon} {label} ‚Äî {' ‚Äî '.join(extras)}"
        else:
            payout_note = f"{icon} {label}"
    elif receipt.get("paid") is True:
        extras: List[str] = []
        code = receipt.get("paid_request_code")
        if code:
            extras.append(f"ID {h(code)}")
        stamp = format_datetime_short(receipt.get("paid_at"))
        if stamp:
            extras.append(stamp)
        if extras:
            payout_note = f"üí∏ –í—ã–ø–ª–∞—Ç–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞ ‚Äî {' ‚Äî '.join(extras)}"
    elif isinstance(receipt.get("payout_history"), list) and receipt["payout_history"]:
        last_event = receipt["payout_history"][-1]
        if isinstance(last_event, dict) and last_event.get("status"):
            status = last_event.get("status")
            if status == "closed":
                extras: List[str] = []
                code = last_event.get("code") or last_event.get("request_id")
                if code:
                    extras.append(f"ID {h(code)}")
                stamp = format_datetime_short(last_event.get("timestamp"))
                if stamp:
                    extras.append(stamp)
                if extras:
                    payout_note = f"üì≠ –ó–∞–ø—Ä–æ—Å –∑–∞–∫—Ä—ã—Ç –≤—Ä—É—á–Ω—É—é ‚Äî {' ‚Äî '.join(extras)}"
                else:
                    payout_note = "üì≠ –ó–∞–ø—Ä–æ—Å –∑–∞–∫—Ä—ã—Ç –≤—Ä—É—á–Ω—É—é"
    if payout_note:
        lines.append(f"{indent}{payout_note}")
    return "\n".join(lines)


def extract_receipt_prefix(message: Optional[types.Message]) -> Optional[str]:
    if not message:
        return None
    raw = (message.caption or message.text or "").strip()
    if not raw:
        return None
    first_line = raw.split("\n", 1)[0].strip()
    if first_line.startswith("üßæ"):
        return first_line
    return None


async def send_receipt_card(chat_id: int, project: str, owner_uid: int, receipt: dict,
                            kb: Optional[InlineKeyboardMarkup] = None,
                            include_project: bool = False,
                            prefix: Optional[str] = None) -> types.Message:
    caption = format_receipt_caption(receipt, project if include_project else None)
    if prefix:
        caption = f"{prefix}\n{caption}"
    file_name = receipt.get("file") or ""
    path = os.path.join(proj_receipts_dir(project, owner_uid), file_name) if file_name else ""
    if path and os.path.exists(path):
        try:
            return await bot.send_photo(chat_id, InputFile(path), caption=caption, reply_markup=kb)
        except Exception:
            pass
    notices: List[str] = []
    if file_name:
        if path and not os.path.exists(path):
            notices.append("‚ö†Ô∏è –§–æ—Ç–æ —á–µ–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.")
        else:
            notices.append("‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Ñ–æ—Ç–æ —á–µ–∫–∞.")
    else:
        notices.append("‚ö†Ô∏è –§–æ—Ç–æ —á–µ–∫–∞ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç.")
    body = "\n".join(notices + [caption])
    return await bot.send_message(chat_id, body, reply_markup=kb)


def project_status_text(uid: int) -> str:
    if not active_project["name"]:
        return tr(uid, "ANCHOR_NO_PROJECT", bot=h(BOT_NAME))
    info = load_project_info(active_project["name"])
    photo_total = project_photo_count(active_project["name"])
    assignments = np_list_assignments(uid)
    total_assigned = len(assignments)
    pending_assigned = sum(1 for item in assignments if not item.get("delivered_at"))
    delivered_count = max(0, total_assigned - pending_assigned)
    bsg_section = tr(
        uid,
        "ANCHOR_PROJECT_BSG_SUMMARY",
        total=total_assigned,
        pending=pending_assigned,
        delivered=delivered_count,
    )
    alerts_section = alerts_anchor_section(uid)
    name = h(info.get("name", "‚Äî")) or "‚Äî"
    region = h(info.get("region") or "‚Äî")
    location = h(info.get("location", "‚Äî")) or "‚Äî"
    start = h(info.get("start_date", "‚Äî")) or "‚Äî"
    end = h(info.get("end_date", "‚Äî")) or "‚Äî"
    code = h(info.get("code") or "‚Äî")
    return tr(
        uid,
        "ANCHOR_PROJECT",
        bot=h(BOT_NAME),
        name=name,
        code=code,
        region=region,
        location=location,
        photos=photo_total,
        start=start,
        end=end,
        bsg_section=bsg_section,
        alerts_section=alerts_section,
    )




def kb_root(uid: int) -> InlineKeyboardMarkup:
    kb = InlineKeyboardMarkup()
    kb.row(
        InlineKeyboardButton(tr(uid, "BTN_CHECKS"), callback_data="menu_checks"),
        InlineKeyboardButton(tr(uid, "BTN_DOCUMENTS"), callback_data="menu_docs"),
    )
    kb.add(InlineKeyboardButton(tr(uid, "BTN_PHOTO_TIMELINE"), callback_data="menu_photos"))
    kb.row(
        InlineKeyboardButton(tr(uid, "BTN_FINANCE"), callback_data="menu_finance"),
        InlineKeyboardButton(tr(uid, "BTN_ALERTS"), callback_data="menu_alerts"),
    )
    kb.row(
        InlineKeyboardButton(tr(uid, "BTN_SOS"), callback_data="menu_sos"),
        InlineKeyboardButton(tr(uid, "BTN_NOVA_POSHTA"), callback_data="menu_np"),
    )
    kb.add(InlineKeyboardButton(tr(uid, "BTN_SETTINGS"), callback_data="menu_settings"))
    kb.add(InlineKeyboardButton(tr(uid, "BTN_PROFILE"), callback_data="menu_profile"))
    if uid in admins:
        kb.add(InlineKeyboardButton(tr(uid, "BTN_ADMIN"), callback_data="menu_admin"))
    kb.add(InlineKeyboardButton(tr(uid, "BTN_ABOUT"), callback_data="menu_about"))
    return kb


def kb_profile_cancel(uid: int) -> InlineKeyboardMarkup:
    kb = InlineKeyboardMarkup()
    kb.add(InlineKeyboardButton(tr(uid, "BTN_PROFILE_CANCEL"), callback_data="profile_cancel"))
    return kb


def kb_admin_edit_cancel(uid: int) -> InlineKeyboardMarkup:
    kb = InlineKeyboardMarkup()
    kb.add(InlineKeyboardButton(tr(uid, "BTN_PROFILE_CANCEL"), callback_data="adm_edit_cancel"))
    return kb


def profile_has_photo(profile: dict) -> bool:
    photo = profile.get("photo") or {}
    if not isinstance(photo, dict):
        return False
    path = user_profile_photo_path(profile.get("user_id")) if profile.get("user_id") else None
    return bool(path and os.path.exists(path) and photo.get("status") != "skipped")


def profile_photo_status_label(uid: int, profile: dict) -> str:
    photo = profile.get("photo") or {}
    if not photo:
        return tr(uid, "PROFILE_PHOTO_STATUS_MISSING")
    status = photo.get("status")
    if status == "skipped":
        return tr(uid, "PROFILE_PHOTO_STATUS_SKIPPED")
    if profile_has_photo(profile):
        return tr(uid, "PROFILE_PHOTO_STATUS_OK")
    return tr(uid, "PROFILE_PHOTO_STATUS_MISSING")


def profile_summary_text(uid: int, profile: dict, edit_mode: bool = False) -> str:
    missing = tr(uid, "PROFILE_VALUE_MISSING")
    last_name = h(profile.get("last_name") or missing)
    first_name = h(profile.get("first_name") or missing)
    middle_name = h(profile.get("middle_name") or missing)
    birthdate = format_birthdate_display(profile.get("birthdate"), resolve_lang(uid))
    region = h(profile.get("region") or missing)
    phone = h(profile.get("phone") or missing)
    tg = profile.get("tg") or {}
    tg_id = str(profile.get("user_id", "‚Äî"))
    tg_username = tg.get("username")
    username_disp = h(f"@{tg_username}" if tg_username else missing)
    bsu = h(profile.get("bsu") or missing)
    photo_status = h(profile_photo_status_label(uid, profile))
    lines = [
        tr(uid, "PROFILE_HEADER"),
        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ",
        f"{tr(uid, 'PROFILE_FIELD_LAST_NAME')}: <b>{last_name}</b>",
        f"{tr(uid, 'PROFILE_FIELD_FIRST_NAME')}: <b>{first_name}</b>",
        f"{tr(uid, 'PROFILE_FIELD_MIDDLE_NAME')}: <b>{middle_name}</b>",
        f"{tr(uid, 'PROFILE_FIELD_BIRTHDATE')}: <b>{h(birthdate)}</b>",
        f"{tr(uid, 'PROFILE_FIELD_REGION')}: <b>{region}</b>",
        f"{tr(uid, 'PROFILE_FIELD_PHONE')}: <b>{phone}</b>",
        f"{tr(uid, 'PROFILE_FIELD_BSU')}: <b>{bsu}</b>",
        f"{tr(uid, 'PROFILE_FIELD_TG_USERNAME')}: <b>{username_disp}</b>",
        f"{tr(uid, 'PROFILE_FIELD_TG_ID')}: <code>{tg_id}</code>",
        f"{tr(uid, 'PROFILE_FIELD_PHOTO')}: <b>{photo_status}</b>",
    ]
    if edit_mode:
        lines.append("")
        lines.append(tr(uid, "PROFILE_EDIT_HINT"))
    return "\n".join(lines)


def kb_profile_menu(uid: int, profile: dict, edit_mode: bool = False, show_photo: bool = False) -> InlineKeyboardMarkup:
    kb = InlineKeyboardMarkup()
    has_photo = profile_has_photo(profile)
    if edit_mode:
        kb.row(
            InlineKeyboardButton(tr(uid, "BTN_PROFILE_FIELD_LAST"), callback_data="profile_edit_last"),
            InlineKeyboardButton(tr(uid, "BTN_PROFILE_FIELD_FIRST"), callback_data="profile_edit_first"),
        )
        kb.row(
            InlineKeyboardButton(tr(uid, "BTN_PROFILE_FIELD_MIDDLE"), callback_data="profile_edit_middle"),
            InlineKeyboardButton(tr(uid, "BTN_PROFILE_FIELD_BIRTHDATE"), callback_data="profile_edit_birthdate"),
        )
        kb.row(
            InlineKeyboardButton(tr(uid, "BTN_PROFILE_FIELD_REGION"), callback_data="profile_edit_region"),
            InlineKeyboardButton(tr(uid, "BTN_PROFILE_FIELD_PHONE"), callback_data="profile_edit_phone"),
        )
        kb.add(InlineKeyboardButton(tr(uid, "BTN_PROFILE_UPDATE_PHOTO"), callback_data="profile_edit_photo"))
        if has_photo:
            kb.add(InlineKeyboardButton(tr(uid, "BTN_PROFILE_REMOVE_PHOTO"), callback_data="profile_remove_photo"))
        kb.add(InlineKeyboardButton(tr(uid, "BTN_PROFILE_DONE"), callback_data="profile_done"))
    else:
        kb.add(InlineKeyboardButton(tr(uid, "BTN_PROFILE_EDIT"), callback_data="profile_edit"))
        if has_photo:
            if show_photo:
                kb.add(InlineKeyboardButton(tr(uid, "BTN_PROFILE_HIDE_PHOTO"), callback_data="profile_hide_photo"))
            else:
                kb.add(InlineKeyboardButton(tr(uid, "BTN_PROFILE_VIEW_PHOTO"), callback_data="profile_view_photo"))
    kb.add(InlineKeyboardButton(tr(uid, "BTN_BACK_ROOT"), callback_data="back_root"))
    return kb


def kb_profile_region_prompt(uid: int) -> InlineKeyboardMarkup:
    kb = InlineKeyboardMarkup()
    kb.add(InlineKeyboardButton(tr(uid, "REGISTER_REGION_BUTTON"), callback_data="profile_region_open"))
    kb.add(InlineKeyboardButton(tr(uid, "BTN_PROFILE_CANCEL"), callback_data="profile_cancel"))
    return kb


def kb_profile_region_picker(uid: int) -> InlineKeyboardMarkup:
    kb = InlineKeyboardMarkup(row_width=2)
    for idx, region in enumerate(UKRAINE_REGIONS):
        kb.insert(InlineKeyboardButton(region, callback_data=f"profile_region_pick:{idx}"))
    kb.add(InlineKeyboardButton(tr(uid, "BTN_PROFILE_CANCEL"), callback_data="profile_cancel"))
    return kb


def kb_profile_phone_keyboard(uid: int) -> ReplyKeyboardMarkup:
    kb = ReplyKeyboardMarkup(resize_keyboard=True, one_time_keyboard=True)
    kb.add(KeyboardButton(tr(uid, "BTN_SEND_PHONE"), request_contact=True))
    kb.add(KeyboardButton(tr(uid, "BTN_PROFILE_CANCEL")))
    return kb


async def show_profile(uid: int, *, edit_mode: Optional[bool] = None, show_photo: Optional[bool] = None):
    runtime = profile_runtime(uid)
    if edit_mode is None or show_photo is None:
        current_edit, current_photo = profile_get_flags(uid)
        if edit_mode is None:
            edit_mode = current_edit
        if show_photo is None:
            show_photo = current_photo
    profile = load_user(uid) or ensure_user(uid, runtime.get("tg", {}))
    profile.setdefault("user_id", uid)
    has_photo = profile_has_photo(profile)
    if show_photo and not has_photo:
        await profile_send_notification(uid, tr(uid, "PROFILE_NO_PHOTO"))
        show_photo = False
    profile_set_flags(uid, edit_mode=edit_mode, show_photo=show_photo and has_photo)
    caption = profile_summary_text(uid, profile, edit_mode=edit_mode)
    kb = kb_profile_menu(uid, profile, edit_mode=edit_mode, show_photo=show_photo and has_photo)
    if show_photo and has_photo:
        await anchor_replace_with_photo(uid, user_profile_photo_path(uid), caption, kb)
    else:
        profile_set_flags(uid, show_photo=False)
        chat = profile_chat_id(uid)
        if chat:
            await anchor_upsert(uid, chat, caption, kb)


def kb_alerts(uid: int) -> InlineKeyboardMarkup:
    kb = InlineKeyboardMarkup()
    kb.add(InlineKeyboardButton(tr(uid, "ALERTS_BTN_OVERVIEW"), callback_data="alerts_overview"))
    kb.add(InlineKeyboardButton(tr(uid, "ALERTS_BTN_ACTIVE"), callback_data="alerts_active"))
    kb.add(InlineKeyboardButton(tr(uid, "ALERTS_BTN_HISTORY"), callback_data="alerts_history"))
    kb.add(InlineKeyboardButton(tr(uid, "ALERTS_BTN_SUBSCRIPTIONS"), callback_data="alerts_subscriptions"))
    kb.add(InlineKeyboardButton(tr(uid, "BTN_BACK_ROOT"), callback_data="back_root"))
    return kb


def kb_checks(uid: int) -> InlineKeyboardMarkup:
    kb = InlineKeyboardMarkup()
    kb.add(InlineKeyboardButton(tr(uid, "BTN_ADD_RECEIPT"), callback_data="check_add"))
    kb.add(InlineKeyboardButton(tr(uid, "BTN_MY_STATS"), callback_data="check_stats"))
    kb.add(InlineKeyboardButton(tr(uid, "BTN_MY_RECEIPTS"), callback_data="check_list"))
    kb.add(InlineKeyboardButton(tr(uid, "BTN_RECEIPT_HISTORY"), callback_data="check_history"))
    kb.add(InlineKeyboardButton(tr(uid, "BTN_BACK_ROOT"), callback_data="back_root"))
    return kb


def kb_photos(uid: int) -> InlineKeyboardMarkup:
    kb = InlineKeyboardMarkup()
    kb.add(InlineKeyboardButton(tr(uid, "BTN_UPLOAD_PHOTO"), callback_data="photo_upload"))
    kb.add(InlineKeyboardButton(tr(uid, "BTN_VIEW_OBJECT_PHOTOS"), callback_data="photo_view"))
    kb.add(InlineKeyboardButton(tr(uid, "BTN_BACK_ROOT"), callback_data="back_root"))
    return kb


def kb_photo_session_controls(has_uploads: bool) -> InlineKeyboardMarkup:
    kb = InlineKeyboardMarkup()
    if has_uploads:
        kb.row(
            InlineKeyboardButton("üóÇ –ü–æ—Å–º–æ—Ç—Ä–µ—Ç—å –∑–∞–≥—Ä—É–∂–µ–Ω–Ω–æ–µ", callback_data="photo_session_preview"),
            InlineKeyboardButton("‚úÖ –ó–∞–≤–µ—Ä—à–∏—Ç—å –∑–∞–≥—Ä—É–∑–∫—É", callback_data="photo_finish"),
        )
    kb.add(InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∏—Ç—å", callback_data="photo_cancel"))
    return kb


def kb_photo_view_actions() -> InlineKeyboardMarkup:
    kb = InlineKeyboardMarkup()
    kb.row(
        InlineKeyboardButton("‚ùå –ó–∞–∫—Ä—ã—Ç—å", callback_data="photo_view_close"),
        InlineKeyboardButton("üè† –ù–∞ –≥–ª–∞–≤–Ω—É—é", callback_data="photo_view_root"),
    )
    return kb


def _format_photo_session_entry(idx: int, entry: dict) -> str:
    original = entry.get("original") or entry.get("file") or "‚Äî"
    uploaded_at = entry.get("uploaded_at")
    if isinstance(uploaded_at, str):
        try:
            dt = datetime.fromisoformat(uploaded_at)
            uploaded_at = dt.strftime("%d.%m.%Y %H:%M")
        except ValueError:
            uploaded_at = uploaded_at.replace("T", " ")
    return f"{idx}. {h(original)} ‚Äî {h(uploaded_at or '‚Äî')}"


def _build_photo_session_text(info: dict, uploaded: List[dict], last_entry: Optional[dict] = None) -> str:
    name = h(info.get("name", "‚Äî"))
    code = h(info.get("code") or "‚Äî")
    lines = [
        "üì§ <b>–ó–∞–≥—Ä—É–∑–∫–∞ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–π –æ–±—ä–µ–∫—Ç–∞</b>",
        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ",
        f"üìÇ –ü—Ä–æ–µ–∫—Ç: <b>{name}</b> ({code})",
        "",
        "–û—Ç–ø—Ä–∞–≤–ª—è–π—Ç–µ –æ–¥–Ω–æ –∏–ª–∏ –Ω–µ—Å–∫–æ–ª—å–∫–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π: –º–æ–∂–Ω–æ –ø—Ä–∏–∫—Ä–µ–ø–ª—è—Ç—å —Ñ–æ—Ç–æ –Ω–∞–ø—Ä—è–º—É—é –∏–ª–∏ –¥–æ–∫—É–º–µ–Ω—Ç–æ–º –±–µ–∑ —Å–∂–∞—Ç–∏—è.",
        "–ö–∞–∂–¥—ã–π —Ñ–∞–π–ª —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç—Å—è –≤ —Ö—Ä–æ–Ω–æ–ª–æ–≥–∏—é –≤–º–µ—Å—Ç–µ —Å –≤–∞—à–∏–º –∏–º–µ–Ω–µ–º –∏ –≤—Ä–µ–º–µ–Ω–µ–º –∑–∞–≥—Ä—É–∑–∫–∏.",
        "",
    ]
    if uploaded:
        lines.append(f"üì∏ –£–∂–µ –∑–∞–≥—Ä—É–∂–µ–Ω–æ: <b>{len(uploaded)}</b>")
        lines.append("–°–ø–∏—Å–æ–∫ —Ñ–∞–π–ª–æ–≤:")
        lines.extend(_format_photo_session_entry(idx + 1, entry) for idx, entry in enumerate(uploaded))
        if last_entry:
            marker = last_entry.get("original") or last_entry.get("file")
            if marker:
                lines.append("")
                lines.append(f"üÜï –ü–æ—Å–ª–µ–¥–Ω–µ–µ –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ: <b>{h(marker)}</b>")
        lines.append("")
        lines.append("–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫—É ¬´üóÇ –ü–æ—Å–º–æ—Ç—Ä–µ—Ç—å –∑–∞–≥—Ä—É–∂–µ–Ω–Ω–æ–µ¬ª, —á—Ç–æ–±—ã –ø–µ—Ä–µ—Å–º–æ—Ç—Ä–µ—Ç—å —Ñ–∞–π–ª—ã –±–µ–∑ –ø–æ–≤—Ç–æ—Ä–Ω–æ–π –∑–∞–≥—Ä—É–∑–∫–∏.")
    else:
        lines.append("–ü–æ–∫–∞ –Ω–µ—Ç –∑–∞–≥—Ä—É–∂–µ–Ω–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –ø–µ—Ä–≤–æ–µ —Ñ–æ—Ç–æ, —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å —Å–ø–∏—Å–æ–∫.")
    lines.append("")
    lines.append("–ü—Ä–æ–¥–æ–ª–∂–∞–π—Ç–µ –æ—Ç–ø—Ä–∞–≤–ª—è—Ç—å —Ñ–æ—Ç–æ –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫–∏ –Ω–∏–∂–µ –¥–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –∏–ª–∏ –æ—Ç–º–µ–Ω—ã —Å–µ—Å—Å–∏–∏.")
    return "\n".join(lines)


async def _photo_refresh_session_message(chat_id: int, uid: int, state: FSMContext, info: dict,
                                         uploaded: List[dict], last_entry: Optional[dict] = None):
    data = await state.get_data()
    target = data.get("photo_session_message")
    text = _build_photo_session_text(info, uploaded, last_entry)
    kb = kb_photo_session_controls(bool(uploaded))
    if isinstance(target, (list, tuple)) and len(target) == 2:
        tgt_chat, tgt_id = target
        try:
            await bot.edit_message_text(text, tgt_chat, tgt_id, reply_markup=kb)
            return
        except MessageNotModified:
            return
        except Exception:
            await _delete_message_safe(tgt_chat, tgt_id)
    msg = await bot.send_message(chat_id, text, reply_markup=kb)
    flow_track(uid, msg)
    await state.update_data(photo_session_message=(msg.chat.id, msg.message_id))


def kb_finance_root(user_has_pending_confirm: bool=False) -> InlineKeyboardMarkup:
    kb = InlineKeyboardMarkup()
    if user_has_pending_confirm:
        kb.add(InlineKeyboardButton("‚úÖ –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å –ø–æ–ª—É—á–µ–Ω–∏–µ –≤—ã–ø–ª–∞—Ç", callback_data="fin_confirm_list"))
    kb.add(InlineKeyboardButton("‚è≥ –ù–µ–æ–ø–ª–∞—á–µ–Ω–Ω—ã–µ —á–µ–∫–∏", callback_data="fin_unpaid_list"))
    kb.add(InlineKeyboardButton("üì® –ó–∞–ø—Ä–æ—Å–∏—Ç—å –≤—ã–ø–ª–∞—Ç—É", callback_data="fin_request_payout"))
    kb.add(InlineKeyboardButton("üìö –ò—Å—Ç–æ—Ä–∏—è –≤—ã–ø–ª–∞—Ç", callback_data="fin_history"))
    kb.add(InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞ –≥–ª–∞–≤–Ω—É—é", callback_data="back_root"))
    return kb


def kb_novaposhta(uid: int) -> InlineKeyboardMarkup:
    kb = InlineKeyboardMarkup()
    kb.add(InlineKeyboardButton(tr(uid, "BTN_NP_INTERFACE"), callback_data="np_interface"))
    kb.add(InlineKeyboardButton(tr(uid, "BTN_NP_SEARCH"), callback_data="np_search"))
    kb.add(InlineKeyboardButton(tr(uid, "BTN_NP_HISTORY"), callback_data="np_history"))
    kb.add(InlineKeyboardButton(tr(uid, "BTN_NP_BOOKMARKS"), callback_data="np_bookmarks"))
    kb.add(InlineKeyboardButton(tr(uid, "BTN_NP_ASSIGNED"), callback_data="np_assigned"))
    kb.add(InlineKeyboardButton(tr(uid, "BTN_NP_RECEIVED"), callback_data="np_received"))
    if uid in admins:
        kb.add(InlineKeyboardButton(tr(uid, "BTN_NP_ASSIGN_SEND"), callback_data="np_assign_start"))
    kb.add(InlineKeyboardButton(tr(uid, "BTN_BACK_ROOT"), callback_data="back_root"))
    return kb


def kb_np_cancel(uid: int) -> InlineKeyboardMarkup:
    lang = resolve_lang(uid)
    kb = InlineKeyboardMarkup()
    kb.add(InlineKeyboardButton(_np_pick(lang, NP_CANCEL_BUTTON_LABEL), callback_data="np_cancel"))
    return kb


def kb_np_assign_note(uid: int) -> InlineKeyboardMarkup:
    lang = resolve_lang(uid)
    kb = InlineKeyboardMarkup()
    kb.add(InlineKeyboardButton(_np_pick(lang, NP_ASSIGN_SKIP_BUTTON_LABEL), callback_data="np_assign_skip"))
    kb.add(InlineKeyboardButton(_np_pick(lang, NP_CANCEL_BUTTON_LABEL), callback_data="np_cancel"))
    return kb


def kb_np_result(uid: int, ttn: str, *, bookmarked: bool,
                 allow_assign: bool = False,
                 assignment: Optional[dict] = None,
                 allow_bookmark: bool = True) -> InlineKeyboardMarkup:
    lang = resolve_lang(uid)
    kb = InlineKeyboardMarkup()

    refresh_btn = InlineKeyboardButton(
        _np_pick(lang, NP_REFRESH_BUTTON_LABEL),
        callback_data=f"np_refresh:{ttn}"
    )

    if allow_bookmark:
        bookmark_label = _np_pick(
            lang,
            NP_BOOKMARK_REMOVE_BUTTON if bookmarked else NP_BOOKMARK_ADD_BUTTON
        )
        bookmark_btn = InlineKeyboardButton(bookmark_label, callback_data=f"np_bookmark:{ttn}")
        kb.row(refresh_btn, bookmark_btn)
    else:
        kb.add(refresh_btn)

    kb.add(InlineKeyboardButton(_np_pick(lang, NP_NOTE_BUTTON_LABEL), callback_data=f"np_note:{ttn}"))

    if assignment and not assignment.get("delivered_at"):
        kb.add(InlineKeyboardButton(_np_pick(lang, NP_MARK_RECEIVED_LABEL), callback_data=f"np_assigned_received:{ttn}"))

    if allow_assign:
        kb.add(InlineKeyboardButton(tr(uid, "BTN_NP_ASSIGN_SEND"), callback_data=f"np_assign_quick:{ttn}"))

    kb.add(InlineKeyboardButton(_np_pick(lang, NP_CLOSE_BUTTON_LABEL), callback_data="np_close"))
    return kb


def np_build_list_keyboard(uid: int, options: List[Tuple[str, str]], prefix: str,
                           back_callback: str = "menu_np") -> InlineKeyboardMarkup:
    kb = InlineKeyboardMarkup()
    for value, label in options:
        kb.add(InlineKeyboardButton(label, callback_data=f"{prefix}:{value}"))
    kb.add(InlineKeyboardButton(tr(uid, "BTN_BACK_SETTINGS"), callback_data=back_callback))
    return kb


def kb_admin_root() -> InlineKeyboardMarkup:
    kb = InlineKeyboardMarkup()
    kb.add(InlineKeyboardButton("üë• –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏", callback_data="adm_users"))
    kb.add(InlineKeyboardButton("üìÇ –ü—Ä–æ–µ–∫—Ç—ã", callback_data="adm_projects"))
    kb.add(InlineKeyboardButton("üíµ –§–∏–Ω–∞–Ω—Å—ã", callback_data="adm_finance"))
    kb.add(InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞ –≥–ª–∞–≤–Ω—É—é", callback_data="back_root"))
    return kb


def kb_admin_projects() -> InlineKeyboardMarkup:
    kb = InlineKeyboardMarkup()
    kb.add(InlineKeyboardButton("üìã –°–ø–∏—Å–æ–∫", callback_data="proj_list"))
    kb.add(InlineKeyboardButton("‚ûï –°–æ–∑–¥–∞—Ç—å", callback_data="proj_create"))
    kb.add(InlineKeyboardButton("üîÑ –ê–∫—Ç–∏–≤–∏—Ä–æ–≤–∞—Ç—å", callback_data="proj_activate"))
    kb.add(InlineKeyboardButton("‚úÖ –ó–∞–≤–µ—Ä—à–∏—Ç—å", callback_data="proj_finish"))
    kb.add(InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="menu_admin"))
    return kb


def admin_collect_user_stats(profile: dict) -> dict:
    receipts = profile.get("receipts") or {}
    projects = sorted(receipts.keys()) if isinstance(receipts, dict) else []
    total_count = 0
    total_sum = 0.0
    paid_sum = 0.0
    unpaid_sum = 0.0
    for recs in receipts.values():
        if not isinstance(recs, list):
            continue
        for entry in recs:
            try:
                amount = float(entry.get("sum") or 0.0)
            except (TypeError, ValueError):
                amount = 0.0
            total_count += 1
            total_sum += amount
            if entry.get("paid") is True:
                paid_sum += amount
            elif entry.get("paid") is False:
                unpaid_sum += amount
    payouts = profile.get("payouts") or []
    pending_payouts = [p for p in payouts if (p.get("status") not in {"confirmed", "closed"})]
    confirmed_payouts = [p for p in payouts if p.get("status") in {"confirmed", "closed"}]
    return {
        "projects": projects,
        "total_count": total_count,
        "total_sum": total_sum,
        "paid_sum": paid_sum,
        "unpaid_sum": unpaid_sum,
        "pending_payouts": pending_payouts,
        "confirmed_payouts": confirmed_payouts,
    }


def admin_user_card_text(viewer_uid: int, profile: dict, *, edit_mode: bool = False) -> str:
    stats = admin_collect_user_stats(profile)
    base = profile_summary_text(viewer_uid, profile, edit_mode=False)
    lines = [base, "", "üíº <b>–ê–∫—Ç–∏–≤–Ω—ñ—Å—Ç—å</b>"]
    lines.append(f"üìÇ –ü—Ä–æ—î–∫—Ç—ñ–≤: <b>{len(stats['projects'])}</b>")
    lines.append(f"üßæ –ß–µ–∫—ñ–≤: <b>{stats['total_count']}</b>")
    lines.append(f"üí∞ –°—É–º–∞ —á–µ–∫—ñ–≤: <b>{fmt_money(stats['total_sum'])} –≥—Ä–Ω</b>")
    lines.append(f"‚úÖ –û–ø–ª–∞—á–µ–Ω–æ: <b>{fmt_money(stats['paid_sum'])} –≥—Ä–Ω</b>")
    lines.append(f"‚è≥ –û—á—ñ–∫—É—î –≤–∏–ø–ª–∞—Ç: <b>{fmt_money(stats['unpaid_sum'])} –≥—Ä–Ω</b>")
    lines.append("")
    lines.append("üíµ <b>–ó–∞–ø–∏—Ç–∏ –Ω–∞ –≤–∏–ø–ª–∞—Ç–∏</b>")
    lines.append(f"‚åõ –í —Ä–æ–±–æ—Ç—ñ: <b>{len(stats['pending_payouts'])}</b>")
    lines.append(f"üìó –ó–∞–≤–µ—Ä—à–µ–Ω–æ: <b>{len(stats['confirmed_payouts'])}</b>")
    if edit_mode:
        lines.append("")
        lines.append(tr(viewer_uid, "PROFILE_EDIT_HINT"))
    return "\n".join(lines)


def kb_admin_user(viewer_uid: int, profile: dict, *, show_photo: bool = False, edit_mode: bool = False) -> InlineKeyboardMarkup:
    kb = InlineKeyboardMarkup()
    if profile_has_photo(profile):
        label = "üìù –ü–æ–≤–µ—Ä–Ω—É—Ç–∏ —Ç–µ–∫—Å—Ç" if show_photo else "üëÅ –ü–æ–∫–∞–∑–∞—Ç–∏ —Ñ–æ—Ç–æ"
        kb.add(InlineKeyboardButton(label, callback_data="adm_user_photo_toggle"))
    if edit_mode:
        kb.row(
            InlineKeyboardButton(tr(viewer_uid, "BTN_PROFILE_FIELD_LAST"), callback_data="adm_edit_last"),
            InlineKeyboardButton(tr(viewer_uid, "BTN_PROFILE_FIELD_FIRST"), callback_data="adm_edit_first"),
        )
        kb.row(
            InlineKeyboardButton(tr(viewer_uid, "BTN_PROFILE_FIELD_MIDDLE"), callback_data="adm_edit_middle"),
            InlineKeyboardButton(tr(viewer_uid, "BTN_PROFILE_FIELD_BIRTHDATE"), callback_data="adm_edit_birthdate"),
        )
        kb.row(
            InlineKeyboardButton(tr(viewer_uid, "BTN_PROFILE_FIELD_REGION"), callback_data="adm_edit_region"),
            InlineKeyboardButton(tr(viewer_uid, "BTN_PROFILE_FIELD_PHONE"), callback_data="adm_edit_phone"),
        )
        kb.add(InlineKeyboardButton(tr(viewer_uid, "BTN_PROFILE_UPDATE_PHOTO"), callback_data="adm_edit_photo"))
        if profile_has_photo(profile):
            kb.add(InlineKeyboardButton(tr(viewer_uid, "BTN_PROFILE_REMOVE_PHOTO"), callback_data="adm_edit_remove_photo"))
        kb.add(InlineKeyboardButton(tr(viewer_uid, "BTN_PROFILE_DONE"), callback_data="adm_user_edit_done"))
    else:
        kb.add(InlineKeyboardButton(tr(viewer_uid, "BTN_PROFILE_EDIT"), callback_data="adm_user_edit"))
        kb.row(
            InlineKeyboardButton("üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞", callback_data="adm_stat_choose"),
            InlineKeyboardButton("üßæ –ß–µ–∫–∏", callback_data="adm_recs_choose"),
        )
        kb.add(InlineKeyboardButton("üíµ –§—ñ–Ω–∞–Ω—Å–∏", callback_data="adm_user_finance"))
    kb.add(InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="adm_users"))
    return kb


def kb_region_select() -> InlineKeyboardMarkup:
    kb = InlineKeyboardMarkup(row_width=2)
    for idx, region in enumerate(UKRAINE_REGIONS):
        kb.insert(InlineKeyboardButton(region, callback_data=f"proj_region_{idx}"))
    kb.add(InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="proj_create_cancel"))
    return kb


def kb_pdf_upload() -> InlineKeyboardMarkup:
    kb = InlineKeyboardMarkup()
    kb.add(InlineKeyboardButton("‚ûï –ï—â—ë —Ñ–∞–π–ª", callback_data="pdf_more"))
    kb.add(InlineKeyboardButton("‚úÖ –ó–∞–≤–µ—Ä—à–∏—Ç—å", callback_data="pdf_finish"))
    return kb


def kb_broadcast_close() -> InlineKeyboardMarkup:
    kb = InlineKeyboardMarkup()
    kb.add(InlineKeyboardButton("‚ùå –ó–∞–∫—Ä—ã—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ", callback_data="broadcast_close"))
    return kb


def kb_preview() -> InlineKeyboardMarkup:
    kb = InlineKeyboardMarkup()
    kb.add(InlineKeyboardButton("‚úèÔ∏è –ò–∑–º–µ–Ω–∏—Ç—å —Å—É–º–º—É", callback_data="edit_amount"))
    kb.add(InlineKeyboardButton("üñº –ó–∞–º–µ–Ω–∏—Ç—å —Ñ–æ—Ç–æ", callback_data="edit_photo"))
    kb.add(InlineKeyboardButton("üìù –ò–∑–º–µ–Ω–∏—Ç—å –æ–ø–∏—Å–∞–Ω–∏–µ", callback_data="edit_desc"))
    kb.add(InlineKeyboardButton("üîÅ –ò–∑–º–µ–Ω–∏—Ç—å —Å—Ç–∞—Ç—É—Å –æ–ø–ª–∞—Ç—ã", callback_data="edit_paid"))
    kb.add(InlineKeyboardButton("‚úÖ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å", callback_data="save_receipt"))
    kb.add(InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∏—Ç—å", callback_data="cancel_receipt"))
    return kb


def kb_receipt_cancel() -> InlineKeyboardMarkup:
    kb = InlineKeyboardMarkup()
    kb.add(InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∏—Ç—å", callback_data="cancel_receipt"))
    return kb


def kb_desc_prompt() -> InlineKeyboardMarkup:
    kb = InlineKeyboardMarkup()
    kb.add(InlineKeyboardButton("–ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å", callback_data="desc_skip"))
    kb.add(InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∏—Ç—å", callback_data="cancel_receipt"))
    return kb


def kb_choose_paid(ask_later: bool=True, allow_cancel: bool=False, flow_cancel: bool=False) -> InlineKeyboardMarkup:
    kb = InlineKeyboardMarkup()
    kb.row(
        InlineKeyboardButton("‚úÖ –û–ø–ª–∞—á–µ–Ω–æ", callback_data="paid_yes"),
        InlineKeyboardButton("‚ùå –ù–µ –æ–ø–ª–∞—á–µ–Ω–æ", callback_data="paid_no")
    )
    if ask_later:
        kb.add(InlineKeyboardButton("‚è≠ –£–∫–∞–∑–∞—Ç—å –ø–æ–∑–∂–µ", callback_data="paid_later"))
    if allow_cancel:
        kb.add(InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∏—Ç—å –∏–∑–º–µ–Ω–µ–Ω–∏–µ", callback_data="edit_cancel"))
    if flow_cancel:
        kb.add(InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∏—Ç—å", callback_data="cancel_receipt"))
    return kb


def kb_edit_cancel() -> InlineKeyboardMarkup:
    kb = InlineKeyboardMarkup()
    kb.add(InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∏—Ç—å –∏–∑–º–µ–Ω–µ–Ω–∏–µ", callback_data="edit_cancel"))
    return kb


def kb_saved_receipt() -> InlineKeyboardMarkup:
    kb = InlineKeyboardMarkup()
    kb.add(InlineKeyboardButton("‚ùå –ó–∞–∫—Ä—ã—Ç—å", callback_data="close_saved_receipt"))
    return kb


def kb_next_step(target: Any, callback_data: str) -> InlineKeyboardMarkup:
    kb = InlineKeyboardMarkup()
    kb.add(InlineKeyboardButton(tr(target, "BTN_NEXT"), callback_data=callback_data))
    return kb


def kb_settings(uid: int) -> InlineKeyboardMarkup:
    kb = InlineKeyboardMarkup()
    kb.add(InlineKeyboardButton(tr(uid, "SETTINGS_LANGUAGE"), callback_data="settings_language"))
    kb.add(InlineKeyboardButton(tr(uid, "BTN_BACK_ROOT"), callback_data="back_root"))
    return kb


def kb_language_settings(uid: int) -> InlineKeyboardMarkup:
    kb = kb_language_picker("settings_lang")
    kb.add(InlineKeyboardButton(tr(uid, "BTN_BACK_SETTINGS"), callback_data="settings_back"))
    return kb


def inline_kb_signature(kb: Optional[InlineKeyboardMarkup]) -> Any:
    if not kb or not kb.inline_keyboard: return None
    sign = []
    for row in kb.inline_keyboard:
        sign.append(tuple((btn.text, btn.callback_data or btn.url or "") for btn in row))
    return tuple(sign)


# ========================== ANCHOR ==========================
async def anchor_upsert(uid: int, chat_id: int, text: Optional[str] = None, kb: Optional[InlineKeyboardMarkup] = None):
    if text is None: text = project_status_text(uid)
    if kb is None: kb = kb_root(uid)
    text = str(text); kb_sign = inline_kb_signature(kb)

    ur = users_runtime.setdefault(uid, {})
    last_text = ur.get("last_anchor_text"); last_kb = ur.get("last_anchor_kb")
    anchor = ur.get("anchor")

    if anchor and last_text == text and last_kb == kb_sign:
        return

    if anchor:
        try:
            await bot.edit_message_text(text, chat_id, anchor, reply_markup=kb)
            ur["last_anchor_text"] = text; ur["last_anchor_kb"] = kb_sign
            ur["anchor_mode"] = "text"
            return
        except MessageNotModified:
            return
        except Exception:
            try:
                await bot.delete_message(chat_id, anchor)
            except Exception:
                pass

    msg = await bot.send_message(chat_id, text, reply_markup=kb)
    ur["anchor"] = msg.message_id
    ur["last_anchor_text"] = text; ur["last_anchor_kb"] = kb_sign
    ur["anchor_mode"] = "text"


async def anchor_show_root(uid: int):
    chat = users_runtime.get(uid, {}).get("tg", {}).get("chat_id")
    if chat: await anchor_upsert(uid, chat, project_status_text(uid), kb_root(uid))


async def anchor_replace_with_photo(uid: int, photo_path: str, caption: str, kb: InlineKeyboardMarkup):
    runtime = users_runtime.setdefault(uid, {})
    chat = runtime.get("tg", {}).get("chat_id")
    if not chat:
        return
    if not os.path.exists(photo_path):
        await anchor_upsert(uid, chat, caption, kb)
        return
    anchor = runtime.get("anchor")
    kb_sign = inline_kb_signature(kb)
    media = types.InputMediaPhoto(InputFile(photo_path), caption=caption, parse_mode="HTML")
    try:
        if anchor:
            await bot.edit_message_media(chat_id=chat, message_id=anchor, media=media, reply_markup=kb)
        else:
            msg = await bot.send_photo(chat, InputFile(photo_path), caption=caption, reply_markup=kb)
            runtime["anchor"] = msg.message_id
    except MessageNotModified:
        pass
    except Exception:
        try:
            if anchor:
                await bot.delete_message(chat, anchor)
        except Exception:
            pass
        msg = await bot.send_photo(chat, InputFile(photo_path), caption=caption, reply_markup=kb)
        runtime["anchor"] = msg.message_id
    runtime["last_anchor_text"] = caption
    runtime["last_anchor_kb"] = kb_sign
    runtime["anchor_mode"] = "photo"


async def anchor_show_text(uid: int, text: str, kb: InlineKeyboardMarkup):
    chat = users_runtime.get(uid, {}).get("tg", {}).get("chat_id")
    if chat: await anchor_upsert(uid, chat, text, kb)


async def update_all_anchors():
    for uid in list(users_runtime.keys()):
        await anchor_show_root(uid)


def profile_runtime(uid: int) -> dict:
    return users_runtime.setdefault(uid, {})


def profile_chat_id(uid: int) -> Optional[int]:
    return profile_runtime(uid).get("tg", {}).get("chat_id")


async def profile_clear_prompt(uid: int):
    runtime = profile_runtime(uid)
    prompt = runtime.pop("profile_prompt", None)
    if isinstance(prompt, (list, tuple)) and len(prompt) == 2:
        await _delete_message_safe(prompt[0], prompt[1])


async def profile_send_prompt(uid: int, text: str, reply_markup: Optional[Union[InlineKeyboardMarkup, ReplyKeyboardMarkup]] = None):
    chat = profile_chat_id(uid)
    if not chat:
        return None
    await profile_clear_prompt(uid)
    runtime = profile_runtime(uid)
    if isinstance(reply_markup, ReplyKeyboardMarkup):
        runtime["profile_reply_keyboard"] = True
    else:
        runtime.pop("profile_reply_keyboard", None)
    msg = await bot.send_message(chat, text, reply_markup=reply_markup)
    runtime["profile_prompt"] = (msg.chat.id, msg.message_id)
    flow_track(uid, msg)
    return msg


def admin_edit_runtime(uid: int) -> dict:
    runtime = users_runtime.setdefault(uid, {})
    return runtime.setdefault("admin_edit", {})


async def admin_edit_clear_prompt(uid: int):
    runtime = admin_edit_runtime(uid)
    prompt = runtime.pop("prompt", None)
    if isinstance(prompt, (list, tuple)) and len(prompt) == 2:
        await _delete_message_safe(prompt[0], prompt[1])


async def admin_edit_send_prompt(
    uid: int,
    text: str,
    reply_markup: Optional[Union[InlineKeyboardMarkup, ReplyKeyboardMarkup]] = None,
):
    chat = users_runtime.get(uid, {}).get("tg", {}).get("chat_id")
    if not chat:
        return None
    await admin_edit_clear_prompt(uid)
    runtime = admin_edit_runtime(uid)
    if isinstance(reply_markup, ReplyKeyboardMarkup):
        runtime["reply_keyboard"] = True
    else:
        runtime.pop("reply_keyboard", None)
    msg = await bot.send_message(chat, text, reply_markup=reply_markup)
    runtime["prompt"] = (msg.chat.id, msg.message_id)
    flow_track(uid, msg)
    return msg


async def admin_edit_notify(uid: int, text: str, *, remove_keyboard: bool = False):
    chat = users_runtime.get(uid, {}).get("tg", {}).get("chat_id")
    if not chat:
        return
    markup = ReplyKeyboardRemove() if remove_keyboard else None
    msg = await bot.send_message(chat, text, reply_markup=markup)
    flow_track(uid, msg)
    schedule_auto_delete(msg.chat.id, msg.message_id, delay=8)


async def profile_send_notification(uid: int, text: str, *, remove_keyboard: bool = False):
    chat = profile_chat_id(uid)
    if not chat:
        return
    markup = ReplyKeyboardRemove() if remove_keyboard else None
    msg = await bot.send_message(chat, text, reply_markup=markup)
    flow_track(uid, msg)
    schedule_auto_delete(msg.chat.id, msg.message_id, delay=8)


def profile_set_flags(uid: int, *, edit_mode: Optional[bool] = None, show_photo: Optional[bool] = None):
    runtime = profile_runtime(uid)
    if edit_mode is not None:
        runtime["profile_edit_mode"] = bool(edit_mode)
    if show_photo is not None:
        runtime["profile_show_photo"] = bool(show_photo)


def profile_get_flags(uid: int) -> Tuple[bool, bool]:
    runtime = profile_runtime(uid)
    return bool(runtime.get("profile_edit_mode")), bool(runtime.get("profile_show_photo"))


async def profile_abort(uid: int, state: FSMContext, *, remove_keyboard: bool = False):
    await profile_clear_prompt(uid)
    await flow_clear_warnings(uid)
    await state.finish()
    await profile_send_notification(uid, tr(uid, "PROFILE_CANCELLED"), remove_keyboard=remove_keyboard)
    await show_profile(uid, edit_mode=True, show_photo=False)


# ========================== FLOW CLEANER ==========================
def flow_track(uid: int, msg: Optional[types.Message], bucket: str = "flow_msgs"):
    if not msg:
        return
    runtime = users_runtime.setdefault(uid, {})
    runtime.setdefault(bucket, []).append((msg.chat.id, msg.message_id))


def flow_track_warning(uid: int, msg: Optional[types.Message]):
    flow_track(uid, msg, bucket="flow_warns")


async def _flow_clear_bucket(uid: int, bucket: str):
    runtime = users_runtime.setdefault(uid, {})
    tracked = list(runtime.get(bucket, []))
    runtime[bucket] = []
    if not tracked:
        return
    await asyncio.gather(*[
        _delete_message_safe(chat_id, mid)
        for chat_id, mid in tracked
        if chat_id and mid
    ], return_exceptions=True)


async def flow_clear_warnings(uid: int):
    await _flow_clear_bucket(uid, "flow_warns")


async def flow_clear(uid: int):
    runtime = users_runtime.setdefault(uid, {})
    await _flow_clear_bucket(uid, "flow_msgs")
    await _flow_clear_bucket(uid, "flow_warns")
    last_card = runtime.pop("np_last_card", None)
    if isinstance(last_card, (list, tuple)) and len(last_card) == 2:
        await _delete_message_safe(last_card[0], last_card[1])
    runtime.pop("alerts_cards", None)


async def flow_delete_message(uid: int, message: Optional[types.Message]):
    if not message:
        return
    if is_anchor_message(uid, message.message_id):
        return
    await _delete_message_safe(message.chat.id, message.message_id)


def schedule_auto_delete(chat_id: int, message_id: int, delay: int = 10):
    async def _delayed():
        try:
            await asyncio.sleep(delay)
        except Exception:
            return
        await _delete_message_safe(chat_id, message_id)

    asyncio.create_task(_delayed())


async def clear_then_anchor(uid: int, text: str, kb: InlineKeyboardMarkup):
    await flow_clear(uid)
    await anchor_show_text(uid, text, kb)



async def _delete_message_safe(chat_id: Optional[int], message_id: Optional[int]):
    if not chat_id or not message_id:
        return
    try:
        await bot.delete_message(chat_id, message_id)
    except Exception:
        pass


async def remove_preview_message(state: FSMContext):
    data = await state.get_data()
    info = data.get("preview_message")
    if not info:
        return
    chat_id = message_id = None
    if isinstance(info, (list, tuple)) and len(info) == 2:
        chat_id, message_id = info
    elif isinstance(info, dict):
        chat_id = info.get("chat_id")
        message_id = info.get("message_id")
    await _delete_message_safe(chat_id, message_id)
    await state.update_data(preview_message=None)


async def clear_edit_prompt(state: FSMContext):
    data = await state.get_data()
    info = data.get("edit_prompt")
    if not info:
        return
    chat_id = message_id = None
    if isinstance(info, (list, tuple)) and len(info) == 2:
        chat_id, message_id = info
    elif isinstance(info, dict):
        chat_id = info.get("chat_id")
        message_id = info.get("message_id")
    await _delete_message_safe(chat_id, message_id)
    await state.update_data(edit_prompt=None)


async def clear_step_prompt(state: FSMContext):
    if state is None:
        return
    data = await state.get_data()
    info = data.get("step_prompt")
    if not info:
        return
    chat_id = message_id = None
    if isinstance(info, (list, tuple)) and len(info) == 2:
        chat_id, message_id = info
    elif isinstance(info, dict):
        chat_id = info.get("chat_id")
        message_id = info.get("message_id")
    await _delete_message_safe(chat_id, message_id)
    await state.update_data(step_prompt=None)


async def remember_step_prompt(state: FSMContext, msg: types.Message):
    if state is None or msg is None:
        return msg
    await state.update_data(step_prompt=(msg.chat.id, msg.message_id))
    return msg


def is_anchor_message(uid: int, message_id: Optional[int]) -> bool:
    if message_id is None:
        return False
    return users_runtime.get(uid, {}).get("anchor") == message_id


async def delete_if_not_anchor(uid: int, chat_id: Optional[int], message_id: Optional[int]):
    if not chat_id or not message_id:
        return
    if is_anchor_message(uid, message_id):
        return
    await _delete_message_safe(chat_id, message_id)


async def send_receipt_preview(uid: int, chat_id: int, state: FSMContext):
    data = await state.get_data()
    tmp = data.get("tmp_img")
    amount = data.get("amount")
    if not tmp or amount is None:
        return None
    desc_raw = data.get("desc", "")
    desc_text = h(desc_raw) if desc_raw else "‚Äî"
    paid = data.get("paid")
    await clear_edit_prompt(state)
    await remove_preview_message(state)
    status_txt = "‚úÖ –û–ø–ª–∞—á–µ–Ω" if paid is True else ("‚ùå –ù–µ –æ–ø–ª–∞—á–µ–Ω" if paid is False else "‚è≥ –ù–µ —É–∫–∞–∑–∞–Ω")
    caption = (
        "üßæ <b>–ü—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä —á–µ–∫–∞</b>\n"
        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
        f"üí∞ –°—É–º–º–∞: {fmt_money(float(amount))} –≥—Ä–Ω\n"
        f"üìù –û–ø–∏—Å–∞–Ω–∏–µ: {desc_text}\n"
        f"üîñ –°—Ç–∞—Ç—É—Å: {status_txt}\n\n"
        "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫–∏ –ø–æ–¥ —Å–æ–æ–±—â–µ–Ω–∏–µ–º, —á—Ç–æ–±—ã —Å–∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∞—Ç—å –¥–∞–Ω–Ω—ã–µ –∏–ª–∏ —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å —á–µ–∫."
    )
    msg = await bot.send_photo(chat_id, InputFile(tmp), caption=caption, reply_markup=kb_preview())
    flow_track(uid, msg)
    await state.update_data(preview_message=(chat_id, msg.message_id))
    return msg


async def admin_send_receipt_photos(admin_uid: int, chat_id: int, target_uid: int, project: str, files: List[str]):
    recs = user_project_receipts(target_uid, project)
    by_file = {r.get("file"): r for r in recs}
    base_dir = proj_receipts_dir(project, target_uid)
    for fname in files:
        path = os.path.join(base_dir, fname)
        if not os.path.exists(path):
            continue
        r = by_file.get(fname)
        desc = r.get("desc") if r else None
        status = r.get("paid") if r else None
        status_txt = "‚úÖ –û–ø–ª–∞—á–µ–Ω" if status is True else ("‚ùå –ù–µ –æ–ø–ª–∞—á–µ–Ω" if status is False else "‚è≥ –ù–µ —É–∫–∞–∑–∞–Ω")
        caption_parts = []
        if r:
            caption_parts.append(f"üÜî –ù–æ–º–µ—Ä: <b>{h(r.get('receipt_no','‚Äî'))}</b>")
            caption_parts.append(f"üìÖ {h(r.get('date','‚Äî'))} {h(r.get('time',''))}")
            amount = float(r.get('sum') or 0.0)
            caption_parts.append(f"üí∞ {fmt_money(amount)} –≥—Ä–Ω")
            caption_parts.append(f"üìù {h(desc) if desc else '‚Äî'}")
            caption_parts.append(f"üîñ {status_txt}")
        caption_parts.append(f"üìÑ {h(fname)}")
        caption = "\n".join(caption_parts)
        kb = InlineKeyboardMarkup().add(InlineKeyboardButton("‚ùå –ó–∞–∫—Ä—ã—Ç—å", callback_data="broadcast_close"))
        try:
            msg = await bot.send_photo(chat_id, InputFile(path), caption=caption, reply_markup=kb)
            flow_track(admin_uid, msg)
        except Exception:
            continue


# ========================== START / ONBOARD ==========================
def kb_language_picker(prefix: str = "lang_select") -> InlineKeyboardMarkup:
    kb = InlineKeyboardMarkup()
    for code, label in LANG_ORDER:
        kb.add(InlineKeyboardButton(label, callback_data=f"{prefix}:{code}"))
    return kb


def registration_button_label(target: Any) -> str:
    lang = resolve_lang(target)
    labels = {
        "uk": "ü§ñ –î–∞–ª—ñ",
        "en": "ü§ñ DALL¬∑E",
        "de": "ü§ñ Weiter",
        "pl": "ü§ñ Dalej",
        "ru": "ü§ñ –î–∞–ª—å—à–µ",
    }
    return labels.get(lang, labels.get(DEFAULT_LANG, "‚ñ∂Ô∏è Next"))


def kb_registration_next(target: Any, callback_data: str) -> InlineKeyboardMarkup:
    kb = InlineKeyboardMarkup()
    kb.add(InlineKeyboardButton(registration_button_label(target), callback_data=callback_data))
    return kb


def kb_region_prompt(target: Any) -> InlineKeyboardMarkup:
    kb = InlineKeyboardMarkup()
    kb.add(InlineKeyboardButton(tr(target, "REGISTER_REGION_BUTTON"), callback_data="reg_region_open"))
    return kb


def kb_admin_edit_region_prompt(uid: int) -> InlineKeyboardMarkup:
    kb = InlineKeyboardMarkup()
    kb.add(InlineKeyboardButton(tr(uid, "REGISTER_REGION_BUTTON"), callback_data="adm_reg_open"))
    kb.add(InlineKeyboardButton(tr(uid, "BTN_PROFILE_CANCEL"), callback_data="adm_edit_cancel"))
    return kb


def kb_region_picker(target: Any) -> InlineKeyboardMarkup:
    kb = InlineKeyboardMarkup(row_width=2)
    for idx, region in enumerate(UKRAINE_REGIONS):
        kb.insert(InlineKeyboardButton(region, callback_data=f"reg_region_pick:{idx}"))
    return kb


def kb_admin_edit_region_picker(uid: int) -> InlineKeyboardMarkup:
    kb = InlineKeyboardMarkup(row_width=2)
    for idx, region in enumerate(UKRAINE_REGIONS):
        kb.insert(InlineKeyboardButton(region, callback_data=f"adm_reg_pick:{idx}"))
    kb.add(InlineKeyboardButton(tr(uid, "BTN_PROFILE_CANCEL"), callback_data="adm_edit_cancel"))
    return kb


def kb_phone_keyboard(target: Any) -> ReplyKeyboardMarkup:
    kb = ReplyKeyboardMarkup(resize_keyboard=True, one_time_keyboard=True)
    kb.add(KeyboardButton(tr(target, "BTN_SEND_PHONE"), request_contact=True))
    return kb


def kb_photo_keyboard(target: Any) -> InlineKeyboardMarkup:
    kb = InlineKeyboardMarkup()
    kb.add(InlineKeyboardButton(tr(target, "BTN_SKIP"), callback_data="reg_photo_skip"))
    return kb


def kb_admin_edit_next(uid: int, callback_data: str) -> InlineKeyboardMarkup:
    kb = InlineKeyboardMarkup()
    kb.add(InlineKeyboardButton(registration_button_label(uid), callback_data=callback_data))
    kb.add(InlineKeyboardButton(tr(uid, "BTN_PROFILE_CANCEL"), callback_data="adm_edit_cancel"))
    return kb


@dp.message_handler(commands=["start"], state="*")
async def start_cmd(m: types.Message, state: FSMContext):
    ensure_dirs()
    sync_state()
    uid = m.from_user.id
    runtime = users_runtime.setdefault(uid, {})

    await state.finish()
    await flow_clear(uid)

    runtime["tg"] = {
        "user_id": uid,
        "chat_id": m.chat.id,
        "username": m.from_user.username,
        "first_name": m.from_user.first_name,
        "last_name": m.from_user.last_name,
        "last_seen": datetime.now(timezone.utc).isoformat(),
    }

    ensure_user(uid, runtime["tg"], lang=m.from_user.language_code)
    profile = load_user(uid) or {}
    runtime["onboard_registered"] = bool(
        profile.get("profile_completed") or (
            profile.get("first_name") and profile.get("last_name") and profile.get("phone")
        )
    )

    try:
        await bot.delete_message(m.chat.id, m.message_id)
    except Exception:
        pass

    prompt = await bot.send_message(m.chat.id, tr(uid, "LANGUAGE_PROMPT"), reply_markup=kb_language_picker())
    runtime["language_prompt"] = (prompt.chat.id, prompt.message_id)
    await OnboardFSM.language.set()


@dp.callback_query_handler(lambda c: c.data.startswith("lang_select:"), state=OnboardFSM.language)
async def onboard_language_selected(c: types.CallbackQuery, state: FSMContext):
    uid = c.from_user.id
    code = c.data.split(":", 1)[1]
    if code not in LANG_CODES:
        await c.answer()
        return

    runtime = users_runtime.setdefault(uid, {})
    prompt = runtime.pop("language_prompt", None)
    if prompt:
        await _delete_message_safe(prompt[0], prompt[1])

    set_user_lang(uid, code, confirmed=True)
    profile = load_user(uid) or {}
    runtime["onboard_registered"] = bool(
        profile.get("profile_completed") or (
            profile.get("first_name") and profile.get("last_name") and profile.get("phone")
        )
    )

    chat_id = runtime.get("tg", {}).get("chat_id") or c.message.chat.id
    confirm = await bot.send_message(
        chat_id,
        tr(uid, "ONBOARD_LANGUAGE_CONFIRMED", language=LANG_LABELS.get(code, code)),
        reply_markup=kb_registration_next(uid, "onboard_stage:welcome"),
    )
    runtime["onboard_intro"] = {"chat_id": confirm.chat.id, "message_id": confirm.message_id}
    await state.set_state(OnboardFSM.welcome.state)
    await c.answer()


@dp.callback_query_handler(lambda c: c.data.startswith("onboard_stage:"), state=[OnboardFSM.welcome, OnboardFSM.briefing, OnboardFSM.instructions])
async def onboard_stage_step(c: types.CallbackQuery, state: FSMContext):
    uid = c.from_user.id
    runtime = users_runtime.setdefault(uid, {})
    info = runtime.get("onboard_intro") or {}
    chat_id = info.get("chat_id") or c.message.chat.id
    message_id = info.get("message_id") or c.message.message_id
    profile = load_user(uid) or {}
    stage = c.data.split(":", 1)[1]

    if stage == "welcome":
        display_name = profile.get("first_name") or runtime.get("tg", {}).get("first_name") or profile.get("fullname") or runtime.get("tg", {}).get("username") or f"ID {uid}"
        text = tr(uid, "ONBOARD_WELCOME", name=h(display_name), bot=h(BOT_NAME))
        kb = kb_registration_next(uid, "onboard_stage:briefing")
        try:
            await bot.edit_message_text(text, chat_id, message_id, reply_markup=kb)
            runtime["onboard_intro"] = {"chat_id": chat_id, "message_id": message_id}
        except MessageNotModified:
            pass
        except Exception:
            msg = await bot.send_message(chat_id, text, reply_markup=kb)
            runtime["onboard_intro"] = {"chat_id": msg.chat.id, "message_id": msg.message_id}
        await state.set_state(OnboardFSM.briefing.state)
        await c.answer()
        return

    if stage == "briefing":
        text = tr(uid, "ONBOARD_BRIEFING")
        if runtime.get("onboard_registered"):
            text = f"{text}\n\n{tr(uid, 'ONBOARD_RETURNING_SHORTCUT')}"
        kb = kb_registration_next(uid, "onboard_stage:instructions")
        try:
            await bot.edit_message_text(text, chat_id, message_id, reply_markup=kb)
            runtime["onboard_intro"] = {"chat_id": chat_id, "message_id": message_id}
        except MessageNotModified:
            pass
        except Exception:
            msg = await bot.send_message(chat_id, text, reply_markup=kb)
            runtime["onboard_intro"] = {"chat_id": msg.chat.id, "message_id": msg.message_id}
        await state.set_state(OnboardFSM.instructions.state)
        await c.answer()
        return

    if stage == "instructions":
        try:
            await bot.delete_message(chat_id, message_id)
        except Exception:
            pass
        runtime.pop("onboard_intro", None)
        await flow_clear(uid)
        intro = await bot.send_message(chat_id, tr(uid, "REGISTER_INTRO_PROMPT"))
        flow_track(uid, intro)
        await onboard_prompt_last_name(uid, chat_id, state)
        await c.answer()
        return

    await c.answer()


async def onboard_prompt_last_name(uid: int, chat_id: int, state: FSMContext):
    await flow_clear_warnings(uid)
    msg = await bot.send_message(chat_id, tr(uid, "REGISTER_LAST_NAME_PROMPT"))
    flow_track(uid, msg)
    await state.set_state(OnboardFSM.last_name.state)


async def onboard_prompt_first_name(uid: int, chat_id: int, state: FSMContext):
    await flow_clear_warnings(uid)
    msg = await bot.send_message(chat_id, tr(uid, "REGISTER_FIRST_NAME_PROMPT"))
    flow_track(uid, msg)
    await state.set_state(OnboardFSM.first_name.state)


async def onboard_prompt_middle_name(uid: int, chat_id: int, state: FSMContext):
    await flow_clear_warnings(uid)
    msg = await bot.send_message(chat_id, tr(uid, "REGISTER_MIDDLE_NAME_PROMPT"))
    flow_track(uid, msg)
    await state.set_state(OnboardFSM.middle_name.state)


async def onboard_prompt_birthdate(uid: int, chat_id: int, state: FSMContext):
    await flow_clear_warnings(uid)
    msg = await bot.send_message(chat_id, tr(uid, "REGISTER_BIRTHDATE_PROMPT"))
    flow_track(uid, msg)
    await state.set_state(OnboardFSM.birthdate.state)


async def onboard_prompt_region(uid: int, chat_id: int, state: FSMContext):
    await flow_clear_warnings(uid)
    msg = await bot.send_message(chat_id, tr(uid, "REGISTER_REGION_PROMPT"), reply_markup=kb_region_prompt(uid))
    flow_track(uid, msg)
    await state.set_state(OnboardFSM.region.state)


async def onboard_prompt_phone(uid: int, chat_id: int, state: FSMContext):
    await flow_clear_warnings(uid)
    msg = await bot.send_message(chat_id, tr(uid, "REGISTER_PHONE_PROMPT_NEW"), reply_markup=kb_phone_keyboard(uid))
    flow_track(uid, msg)
    await state.set_state(OnboardFSM.phone.state)


async def onboard_prompt_photo(uid: int, chat_id: int, state: FSMContext):
    await flow_clear_warnings(uid)
    msg = await bot.send_message(chat_id, tr(uid, "REGISTER_PHOTO_PROMPT"), reply_markup=kb_photo_keyboard(uid))
    flow_track(uid, msg)
    await state.set_state(OnboardFSM.photo.state)


@dp.message_handler(state=OnboardFSM.last_name, content_types=ContentType.TEXT)
async def onboard_last_name(m: types.Message, state: FSMContext):
    uid = m.from_user.id
    raw = normalize_person_name(m.text)
    await flow_delete_message(uid, m)
    if not validate_name(raw):
        warn = await bot.send_message(m.chat.id, tr(uid, "REGISTER_LAST_NAME_WARN"))
        flow_track_warning(uid, warn)
        return
    await flow_clear_warnings(uid)
    await state.update_data(last_name=beautify_name(raw))
    await onboard_prompt_first_name(uid, m.chat.id, state)


@dp.message_handler(state=OnboardFSM.first_name, content_types=ContentType.TEXT)
async def onboard_first_name(m: types.Message, state: FSMContext):
    uid = m.from_user.id
    raw = normalize_person_name(m.text)
    await flow_delete_message(uid, m)
    if not validate_name(raw):
        warn = await bot.send_message(m.chat.id, tr(uid, "REGISTER_FIRST_NAME_WARN"))
        flow_track_warning(uid, warn)
        return
    await flow_clear_warnings(uid)
    await state.update_data(first_name=beautify_name(raw))
    await onboard_prompt_middle_name(uid, m.chat.id, state)


@dp.message_handler(state=OnboardFSM.middle_name, content_types=ContentType.TEXT)
async def onboard_middle_name(m: types.Message, state: FSMContext):
    uid = m.from_user.id
    raw = normalize_person_name(m.text)
    await flow_delete_message(uid, m)
    if raw.lower() in SKIP_KEYWORDS:
        await flow_clear_warnings(uid)
        await state.update_data(middle_name="")
        await onboard_prompt_birthdate(uid, m.chat.id, state)
        return
    if not validate_name(raw):
        warn = await bot.send_message(m.chat.id, tr(uid, "REGISTER_MIDDLE_NAME_WARN"))
        flow_track_warning(uid, warn)
        return
    await flow_clear_warnings(uid)
    await state.update_data(middle_name=beautify_name(raw))
    await onboard_prompt_birthdate(uid, m.chat.id, state)


@dp.message_handler(state=OnboardFSM.birthdate, content_types=ContentType.TEXT)
async def onboard_birthdate(m: types.Message, state: FSMContext):
    uid = m.from_user.id
    await flow_delete_message(uid, m)
    parsed = parse_birthdate_text(m.text)
    if not parsed:
        warn = await bot.send_message(m.chat.id, tr(uid, "REGISTER_BIRTHDATE_WARN"))
        flow_track_warning(uid, warn)
        return
    await flow_clear_warnings(uid)
    await state.update_data(birthdate=parsed.strftime("%Y-%m-%d"))
    await onboard_prompt_region(uid, m.chat.id, state)


@dp.message_handler(state=OnboardFSM.region, content_types=ContentType.ANY)
async def onboard_region_text(m: types.Message, state: FSMContext):
    uid = m.from_user.id
    await flow_delete_message(uid, m)
    warn = await bot.send_message(m.chat.id, tr(uid, "REGISTER_REGION_REMIND"), reply_markup=kb_region_prompt(uid))
    flow_track_warning(uid, warn)


@dp.callback_query_handler(lambda c: c.data == "reg_region_open", state=OnboardFSM.region)
async def onboard_region_open(c: types.CallbackQuery, state: FSMContext):
    uid = c.from_user.id
    runtime = users_runtime.setdefault(uid, {})
    chat_id = runtime.get("tg", {}).get("chat_id") or c.message.chat.id
    picker = await bot.send_message(chat_id, tr(uid, "REGISTER_REGION_PICK"), reply_markup=kb_region_picker(uid))
    flow_track(uid, picker)
    await c.answer()


@dp.callback_query_handler(lambda c: c.data.startswith("reg_region_pick:"), state=OnboardFSM.region)
async def onboard_region_pick(c: types.CallbackQuery, state: FSMContext):
    uid = c.from_user.id
    parts = c.data.split(":", 1)
    try:
        idx = int(parts[1])
        region = UKRAINE_REGIONS[idx]
    except Exception:
        await c.answer()
        return
    await state.update_data(region=region)
    await flow_clear_warnings(uid)
    await delete_if_not_anchor(uid, c.message.chat.id, c.message.message_id)
    runtime = users_runtime.setdefault(uid, {})
    chat_id = runtime.get("tg", {}).get("chat_id") or c.message.chat.id
    confirm = await bot.send_message(chat_id, tr(uid, "REGISTER_REGION_SELECTED", region=h(region)), reply_markup=kb_registration_next(uid, "reg_region_confirm"))
    flow_track(uid, confirm)
    await state.set_state(OnboardFSM.region_confirm.state)
    await c.answer()


@dp.callback_query_handler(lambda c: c.data == "reg_region_confirm", state=OnboardFSM.region_confirm)
async def onboard_region_confirm(c: types.CallbackQuery, state: FSMContext):
    uid = c.from_user.id
    await delete_if_not_anchor(uid, c.message.chat.id, c.message.message_id)
    runtime = users_runtime.setdefault(uid, {})
    chat_id = runtime.get("tg", {}).get("chat_id") or c.message.chat.id
    await onboard_prompt_phone(uid, chat_id, state)
    await c.answer()


@dp.message_handler(content_types=ContentType.CONTACT, state=OnboardFSM.phone)
async def onboard_phone_contact(m: types.Message, state: FSMContext):
    uid = m.from_user.id
    phone = (m.contact.phone_number if m.contact else "").strip()
    await flow_delete_message(uid, m)
    if not phone:
        warn = await bot.send_message(m.chat.id, tr(uid, "REGISTER_PHONE_WARN"), reply_markup=kb_phone_keyboard(uid))
        flow_track_warning(uid, warn)
        return
    await flow_clear_warnings(uid)
    await state.update_data(phone=phone)
    ack = await bot.send_message(m.chat.id, tr(uid, "REGISTER_PHONE_OK"), reply_markup=ReplyKeyboardRemove())
    flow_track(uid, ack)
    await onboard_prompt_photo(uid, m.chat.id, state)


@dp.message_handler(state=OnboardFSM.phone, content_types=ContentType.TEXT)
async def onboard_phone_text(m: types.Message, state: FSMContext):
    uid = m.from_user.id
    await flow_delete_message(uid, m)
    warn = await bot.send_message(m.chat.id, tr(uid, "REGISTER_PHONE_TEXT_WARN"), reply_markup=kb_phone_keyboard(uid))
    flow_track_warning(uid, warn)


@dp.callback_query_handler(lambda c: c.data == "reg_photo_skip", state=OnboardFSM.photo)
async def onboard_photo_skip(c: types.CallbackQuery, state: FSMContext):
    uid = c.from_user.id
    runtime = users_runtime.setdefault(uid, {})
    chat_id = runtime.get("tg", {}).get("chat_id") or c.message.chat.id
    note = await bot.send_message(chat_id, tr(uid, "REGISTER_PHOTO_SKIP_CONFIRM"))
    flow_track(uid, note)
    await finalize_registration(uid, chat_id, state, photo_meta=None, skipped=True)
    await c.answer()


@dp.message_handler(content_types=ContentType.PHOTO, state=OnboardFSM.photo)
async def onboard_photo_received(m: types.Message, state: FSMContext):
    uid = m.from_user.id
    photo = m.photo[-1] if m.photo else None
    if not photo:
        await flow_delete_message(uid, m)
        warn = await bot.send_message(m.chat.id, tr(uid, "REGISTER_PHOTO_WARN"), reply_markup=kb_photo_keyboard(uid))
        flow_track_warning(uid, warn)
        return
    try:
        meta = await store_profile_photo(uid, photo)
    except Exception:
        await flow_delete_message(uid, m)
        warn = await bot.send_message(m.chat.id, tr(uid, "REGISTER_PHOTO_WARN"), reply_markup=kb_photo_keyboard(uid))
        flow_track_warning(uid, warn)
        return
    await flow_clear_warnings(uid)
    ack = await bot.send_message(m.chat.id, tr(uid, "REGISTER_PHOTO_RECEIVED"))
    flow_track(uid, ack)
    runtime = users_runtime.setdefault(uid, {})
    chat_id = runtime.get("tg", {}).get("chat_id") or m.chat.id
    await finalize_registration(uid, chat_id, state, photo_meta=meta, skipped=False)


@dp.message_handler(state=OnboardFSM.photo, content_types=ContentType.ANY)
async def onboard_photo_other(m: types.Message, state: FSMContext):
    uid = m.from_user.id
    if m.content_type == ContentType.PHOTO:
        return
    await flow_delete_message(uid, m)
    warn = await bot.send_message(m.chat.id, tr(uid, "REGISTER_PHOTO_WARN"), reply_markup=kb_photo_keyboard(uid))
    flow_track_warning(uid, warn)


async def finalize_registration(uid: int, chat_id: int, state: FSMContext, photo_meta: Optional[dict], skipped: bool):
    data = await state.get_data()
    last_name = data.get("last_name", "")
    first_name = data.get("first_name", "")
    middle_name = data.get("middle_name", "")
    birthdate = data.get("birthdate", "")
    region = data.get("region", "")
    phone = data.get("phone", "")

    profile = ensure_user(uid, users_runtime.get(uid, {}).get("tg", {}))
    profile["last_name"] = last_name
    profile["first_name"] = first_name
    profile["middle_name"] = middle_name
    profile["fullname"] = compose_fullname(last_name, first_name, middle_name) or profile.get("fullname")
    profile["birthdate"] = birthdate
    profile["region"] = region
    profile["phone"] = phone
    if photo_meta is not None:
        profile["photo"] = photo_meta
    elif skipped and not profile.get("photo"):
        profile["photo"] = {"status": "skipped", "updated_at": datetime.now(timezone.utc).isoformat()}
    profile["profile_completed"] = bool(last_name and first_name and phone and region)
    profile["updated_at"] = datetime.now(timezone.utc).isoformat()
    save_user(profile)

    await state.finish()
    await flow_clear(uid)
    runtime = users_runtime.setdefault(uid, {})
    runtime["onboard_registered"] = True
    runtime.pop("onboard_intro", None)

    confirm = await bot.send_message(chat_id, tr(uid, "REGISTER_FINISH_CONFIRM", code=h(profile.get("bsu", "‚Äî"))))
    schedule_auto_delete(confirm.chat.id, confirm.message_id, delay=20)
    await anchor_show_root(uid)


# ========================== PROFILE EDIT HANDLERS ==========================
@dp.message_handler(state=ProfileEditFSM.waiting_last_name, content_types=ContentType.TEXT)
async def profile_last_name_input(m: types.Message, state: FSMContext):
    uid = m.from_user.id
    raw = normalize_person_name(m.text)
    if not raw or not NAME_VALID_RE.match(raw):
        await flow_delete_message(uid, m)
        warn = await bot.send_message(m.chat.id, tr(uid, "REGISTER_LAST_NAME_WARN"))
        flow_track_warning(uid, warn)
        return
    await flow_delete_message(uid, m)
    profile = ensure_user(uid, users_runtime.get(uid, {}).get("tg", {}))
    profile["last_name"] = beautify_name(raw)
    profile["fullname"] = compose_fullname(profile["last_name"], profile.get("first_name", ""), profile.get("middle_name"))
    profile["updated_at"] = datetime.now(timezone.utc).isoformat()
    save_user(profile)
    await profile_clear_prompt(uid)
    await flow_clear_warnings(uid)
    await state.finish()
    await profile_send_notification(uid, tr(uid, "PROFILE_UPDATE_SUCCESS"))
    await show_profile(uid, edit_mode=True, show_photo=False)


@dp.message_handler(state=ProfileEditFSM.waiting_first_name, content_types=ContentType.TEXT)
async def profile_first_name_input(m: types.Message, state: FSMContext):
    uid = m.from_user.id
    raw = normalize_person_name(m.text)
    if not raw or not NAME_VALID_RE.match(raw):
        await flow_delete_message(uid, m)
        warn = await bot.send_message(m.chat.id, tr(uid, "REGISTER_FIRST_NAME_WARN"))
        flow_track_warning(uid, warn)
        return
    await flow_delete_message(uid, m)
    profile = ensure_user(uid, users_runtime.get(uid, {}).get("tg", {}))
    profile["first_name"] = beautify_name(raw)
    profile["fullname"] = compose_fullname(profile.get("last_name", ""), profile["first_name"], profile.get("middle_name"))
    profile["updated_at"] = datetime.now(timezone.utc).isoformat()
    save_user(profile)
    await profile_clear_prompt(uid)
    await flow_clear_warnings(uid)
    await state.finish()
    await profile_send_notification(uid, tr(uid, "PROFILE_UPDATE_SUCCESS"))
    await show_profile(uid, edit_mode=True, show_photo=False)


@dp.message_handler(state=ProfileEditFSM.waiting_middle_name, content_types=ContentType.TEXT)
async def profile_middle_name_input(m: types.Message, state: FSMContext):
    uid = m.from_user.id
    raw = normalize_person_name(m.text)
    if raw and raw.lower() in SKIP_KEYWORDS:
        cleaned = ""
    else:
        if raw and NAME_VALID_RE.match(raw):
            cleaned = beautify_name(raw)
        else:
            await flow_delete_message(uid, m)
            warn = await bot.send_message(m.chat.id, tr(uid, "REGISTER_MIDDLE_NAME_WARN"))
            flow_track_warning(uid, warn)
            return
    await flow_delete_message(uid, m)
    profile = ensure_user(uid, users_runtime.get(uid, {}).get("tg", {}))
    profile["middle_name"] = cleaned
    profile["fullname"] = compose_fullname(profile.get("last_name", ""), profile.get("first_name", ""), cleaned)
    profile["updated_at"] = datetime.now(timezone.utc).isoformat()
    save_user(profile)
    await profile_clear_prompt(uid)
    await flow_clear_warnings(uid)
    await state.finish()
    await profile_send_notification(uid, tr(uid, "PROFILE_UPDATE_SUCCESS"))
    await show_profile(uid, edit_mode=True, show_photo=False)


@dp.message_handler(state=ProfileEditFSM.waiting_birthdate, content_types=ContentType.TEXT)
async def profile_birthdate_input(m: types.Message, state: FSMContext):
    uid = m.from_user.id
    dt = parse_birthdate_text(m.text)
    if not dt:
        await flow_delete_message(uid, m)
        warn = await bot.send_message(m.chat.id, tr(uid, "REGISTER_BIRTHDATE_WARN"))
        flow_track_warning(uid, warn)
        return
    await flow_delete_message(uid, m)
    profile = ensure_user(uid, users_runtime.get(uid, {}).get("tg", {}))
    profile["birthdate"] = dt.strftime("%Y-%m-%d")
    profile["updated_at"] = datetime.now(timezone.utc).isoformat()
    save_user(profile)
    await profile_clear_prompt(uid)
    await flow_clear_warnings(uid)
    await state.finish()
    await profile_send_notification(uid, tr(uid, "PROFILE_UPDATE_SUCCESS"))
    await show_profile(uid, edit_mode=True, show_photo=False)


@dp.message_handler(state=ProfileEditFSM.waiting_region, content_types=ContentType.TEXT)
async def profile_region_text(m: types.Message, state: FSMContext):
    uid = m.from_user.id
    await flow_delete_message(uid, m)
    warn = await bot.send_message(m.chat.id, tr(uid, "REGISTER_REGION_REMIND"), reply_markup=kb_profile_region_prompt(uid))
    flow_track_warning(uid, warn)


@dp.callback_query_handler(lambda c: c.data == "profile_region_open", state=ProfileEditFSM.waiting_region)
async def profile_region_open(c: types.CallbackQuery, state: FSMContext):
    uid = c.from_user.id
    await profile_send_prompt(uid, tr(uid, "REGISTER_REGION_PICK"), reply_markup=kb_profile_region_picker(uid))
    await c.answer()


@dp.callback_query_handler(lambda c: c.data.startswith("profile_region_pick:"), state=ProfileEditFSM.waiting_region)
async def profile_region_pick(c: types.CallbackQuery, state: FSMContext):
    uid = c.from_user.id
    try:
        idx = int(c.data.split(":", 1)[1])
        region = UKRAINE_REGIONS[idx]
    except Exception:
        await c.answer(tr(uid, "REGISTER_REGION_REMIND"), show_alert=True)
        return
    await state.update_data(profile_region=region)
    await profile_send_prompt(uid, tr(uid, "REGISTER_REGION_SELECTED", region=h(region)), reply_markup=kb_registration_next(uid, "profile_region_confirm"))
    await ProfileEditFSM.region_confirm.set()
    await c.answer()


@dp.callback_query_handler(lambda c: c.data == "profile_region_confirm", state=ProfileEditFSM.region_confirm)
async def profile_region_confirm(c: types.CallbackQuery, state: FSMContext):
    uid = c.from_user.id
    data = await state.get_data()
    region = data.get("profile_region")
    if not region:
        await c.answer(tr(uid, "REGISTER_REGION_REMIND"), show_alert=True)
        return
    profile = ensure_user(uid, users_runtime.get(uid, {}).get("tg", {}))
    profile["region"] = region
    profile["updated_at"] = datetime.now(timezone.utc).isoformat()
    save_user(profile)
    await profile_clear_prompt(uid)
    await flow_clear_warnings(uid)
    await state.finish()
    await profile_send_notification(uid, tr(uid, "PROFILE_UPDATE_SUCCESS"))
    await show_profile(uid, edit_mode=True, show_photo=False)
    await c.answer()


@dp.message_handler(content_types=ContentType.CONTACT, state=ProfileEditFSM.waiting_phone)
async def profile_phone_contact(m: types.Message, state: FSMContext):
    uid = m.from_user.id
    contact = m.contact
    if not contact or not contact.phone_number:
        await flow_delete_message(uid, m)
        warn = await bot.send_message(m.chat.id, tr(uid, "REGISTER_PHONE_WARN"))
        flow_track_warning(uid, warn)
        return
    await flow_delete_message(uid, m)
    profile = ensure_user(uid, users_runtime.get(uid, {}).get("tg", {}))
    profile["phone"] = contact.phone_number
    profile.setdefault("tg", {})["contact_user_id"] = contact.user_id
    profile["updated_at"] = datetime.now(timezone.utc).isoformat()
    save_user(profile)
    runtime = profile_runtime(uid)
    runtime.pop("profile_reply_keyboard", None)
    await profile_clear_prompt(uid)
    await flow_clear_warnings(uid)
    await state.finish()
    await profile_send_notification(uid, tr(uid, "PROFILE_PHONE_SAVED"), remove_keyboard=True)
    await show_profile(uid, edit_mode=True, show_photo=False)


@dp.message_handler(state=ProfileEditFSM.waiting_phone, content_types=ContentType.TEXT)
async def profile_phone_text(m: types.Message, state: FSMContext):
    uid = m.from_user.id
    text = (m.text or "").strip()
    cancel_label = tr(uid, "BTN_PROFILE_CANCEL")
    if text == cancel_label:
        runtime = profile_runtime(uid)
        runtime.pop("profile_reply_keyboard", None)
        await flow_delete_message(uid, m)
        await profile_abort(uid, state, remove_keyboard=True)
        return
    await flow_delete_message(uid, m)
    warn = await bot.send_message(m.chat.id, tr(uid, "REGISTER_PHONE_TEXT_WARN"))
    flow_track_warning(uid, warn)


@dp.message_handler(state=ProfileEditFSM.waiting_photo, content_types=ContentType.PHOTO)
async def profile_photo_received(m: types.Message, state: FSMContext):
    uid = m.from_user.id
    await flow_delete_message(uid, m)
    try:
        meta = await store_profile_photo(uid, m.photo[-1])
    except Exception:
        warn = await bot.send_message(m.chat.id, tr(uid, "REGISTER_PHOTO_WARN"))
        flow_track_warning(uid, warn)
        return
    profile = ensure_user(uid, users_runtime.get(uid, {}).get("tg", {}))
    profile["photo"] = meta or {"status": "uploaded", "updated_at": datetime.now(timezone.utc).isoformat()}
    profile["updated_at"] = datetime.now(timezone.utc).isoformat()
    save_user(profile)
    await profile_clear_prompt(uid)
    await flow_clear_warnings(uid)
    await state.finish()
    await profile_send_notification(uid, tr(uid, "PROFILE_PHOTO_UPDATED"))
    await show_profile(uid, edit_mode=True, show_photo=False)


@dp.message_handler(state=ProfileEditFSM.waiting_photo, content_types=ContentType.ANY)
async def profile_photo_invalid(m: types.Message, state: FSMContext):
    uid = m.from_user.id
    await flow_delete_message(uid, m)
    warn = await bot.send_message(m.chat.id, tr(uid, "REGISTER_PHOTO_WARN"))
    flow_track_warning(uid, warn)


@dp.callback_query_handler(lambda c: c.data == "profile_remove_photo")
async def profile_remove_photo_cb(c: types.CallbackQuery, state: FSMContext):
    uid = c.from_user.id
    profile = ensure_user(uid, users_runtime.get(uid, {}).get("tg", {}))
    remove_profile_photo(uid)
    profile["photo"] = {}
    profile["updated_at"] = datetime.now(timezone.utc).isoformat()
    save_user(profile)
    await flow_clear_warnings(uid)
    await profile_send_notification(uid, tr(uid, "PROFILE_PHOTO_REMOVED"))
    await show_profile(uid, edit_mode=True, show_photo=False)
    await c.answer()


# ========================== ADMIN PROMOTE ==========================
# ========================== ADMIN PROMOTE ==========================
@dp.message_handler(lambda m: m.text and m.text.strip() == ADMIN_CODE)
async def become_admin(m: types.Message):
    uid = m.from_user.id
    try: await bot.delete_message(m.chat.id, m.message_id)
    except: pass
    admins.add(uid); persist_state()
    x = await m.answer(
        "‚úÖ –î–æ—Å—Ç—É–ø –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω.\n"
        "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫—É ¬´üßë‚Äçüíº –ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å¬ª –≤ –≥–ª–∞–≤–Ω–æ–º –º–µ–Ω—é, —á—Ç–æ–±—ã —É–ø—Ä–∞–≤–ª—è—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º–∏, –ø—Ä–æ–µ–∫—Ç–∞–º–∏ –∏ —Ñ–∏–Ω–∞–Ω—Å–∞–º–∏."
    )
    flow_track(uid, x)
    await anchor_show_root(uid)


@dp.message_handler(content_types=ContentType.ANY, state=None)
async def fallback_message(m: types.Message, state: FSMContext):
    uid = m.from_user.id
    text = m.text or ""
    if text.startswith("/"):
        return
    try:
        await bot.delete_message(m.chat.id, m.message_id)
    except Exception:
        pass
    warn = await bot.send_message(m.chat.id, tr(uid, "INVALID_COMMAND"))
    flow_track(uid, warn)


# ========================== NAVIGATION ==========================
@dp.callback_query_handler(lambda c: c.data == "menu_about")
async def menu_about(c: types.CallbackQuery):
    uid = c.from_user.id
    prof = load_user(uid) or {}
    about_text = (
        f"ü§ñ <b>{h(BOT_NAME)}</b>\n"
        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
        f"–í–µ—Ä—Å–∏—è: <code>{h(BOT_VERSION)}</code>\n"
        f"–†–µ–≤–∏–∑–∏—è: <code>{h(BOT_REVISION)}</code>\n"
        f"User ID: <code>{uid}</code>\n"
        f"BSU –∫–æ–¥: <b>{h(prof.get('bsu', '‚Äî'))}</b>\n\n"
        "üìå <b>–ß—Ç–æ —É–º–µ–µ—Ç –±–æ—Ç</b>\n"
        "‚Ä¢ —Ö—Ä–∞–Ω–∏—Ç—å –∏ —Å—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞—Ç—å —á–µ–∫–∏;\n"
        "‚Ä¢ –ø–æ–º–æ–≥–∞—Ç—å —Å –∑–∞–ø—Ä–æ—Å–∞–º–∏ –Ω–∞ –≤—ã–ø–ª–∞—Ç—ã;\n"
        "‚Ä¢ —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω—è—Ç—å –¥–æ–∫—É–º–µ–Ω—Ç—ã –∏ –Ω–æ–≤–æ—Å—Ç–∏ –ø–æ –ø—Ä–æ–µ–∫—Ç—É.\n\n"
        "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫–∏ –Ω–∏–∂–µ, —á—Ç–æ–±—ã –≤–µ—Ä–Ω—É—Ç—å—Å—è –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é –∏ –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å —Ä–∞–±–æ—Ç—É."
    )
    await clear_then_anchor(
        uid,
        about_text,
        kb=InlineKeyboardMarkup().add(InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞ –≥–ª–∞–≤–Ω—É—é", callback_data="back_root"))
    )
    await c.answer()


@dp.callback_query_handler(lambda c: c.data == "menu_alerts")
async def menu_alerts(c: types.CallbackQuery):
    uid = c.from_user.id
    intro = tr(uid, "ALERTS_MENU_INTRO")
    count = alerts_active_oblast_count()
    if count:
        intro = f"{intro}\n\n{alerts_active_summary_line(uid)}"
    await clear_then_anchor(uid, intro, kb_alerts(uid))
    await c.answer()


@dp.callback_query_handler(lambda c: c.data == "alerts_active")
async def alerts_active_view(c: types.CallbackQuery):
    uid = c.from_user.id
    regions = alerts_user_regions(uid)
    if not regions:
        await clear_then_anchor(uid, tr(uid, "ALERTS_NO_REGIONS"), kb_alerts(uid))
        await c.answer()
        return
    events = alerts_collect_active_for_user(uid)
    if not events:
        await clear_then_anchor(uid, tr(uid, "ALERTS_NO_ACTIVE"), kb_alerts(uid))
        await c.answer()
        return
    lang = resolve_lang(uid)
    labels = alerts_field_labels(lang)
    status_labels = ALERTS_STATUS_TEXT.get(lang) or ALERTS_STATUS_TEXT[DEFAULT_LANG]
    divider = tr(uid, "ALERTS_ACTIVE_DIVIDER")
    lines = [
        tr(uid, "ALERTS_ACTIVE_HEADER", count=len(events)),
        divider,
    ]
    for event in events[:10]:
        region_display = alerts_display_region_name(
            event.get("region") or event.get("region_display") or "",
            lang,
            short=True,
        )
        type_text = alerts_type_label(event, lang)
        severity_text = alerts_severity_label(event, lang)
        summary_text = type_text or status_labels.get("alert", "")
        if severity_text:
            summary_text = f"{summary_text} ‚Ä¢ {severity_text}" if summary_text else severity_text
        lines.append(f"üî¥ {h(region_display)} ‚Äî {h(summary_text)}")
        started_display = alerts_format_datetime_display(event.get("started_at"))
        if not started_display:
            started_display = alerts_format_timestamp(event.get("started_at")) or labels["status_unknown"]
        lines.append(f"‚è± {h(started_display)}")
    lines.append(divider)
    lines.append("")
    lines.append(tr(uid, "ALERTS_ACTIVE_SUMMARY_TOTAL", count=len(events)))
    lines.append(tr(uid, "ALERTS_ACTIVE_SUMMARY_USER"))
    lines.append(tr(uid, "ALERTS_ACTIVE_SUMMARY_PROJECT"))
    await clear_then_anchor(uid, "\n".join(lines), kb_alerts(uid))
    await alerts_send_card(uid, c.message.chat.id, events, "active", index=0)
    await c.answer()


@dp.callback_query_handler(lambda c: c.data == "alerts_overview")
async def alerts_overview_view(c: types.CallbackQuery):
    uid = c.from_user.id
    text = alerts_regions_overview_text(uid)
    await clear_then_anchor(uid, text, kb_alerts(uid))
    await c.answer()


@dp.callback_query_handler(lambda c: c.data == "alerts_history")
async def alerts_history_view(c: types.CallbackQuery):
    uid = c.from_user.id
    regions = alerts_user_regions(uid)
    if not regions:
        await clear_then_anchor(uid, tr(uid, "ALERTS_NO_REGIONS"), kb_alerts(uid))
        await c.answer()
        return
    events = alerts_collect_history_for_user(uid)
    if not events:
        await clear_then_anchor(uid, tr(uid, "ALERTS_NO_HISTORY"), kb_alerts(uid))
        await c.answer()
        return
    lang = resolve_lang(uid)
    status_labels = ALERTS_STATUS_TEXT.get(lang) or ALERTS_STATUS_TEXT[DEFAULT_LANG]
    labels = alerts_field_labels(lang)
    indent = "&nbsp;&nbsp;&nbsp;"
    lines = [tr(uid, "ALERTS_HISTORY_HEADER", count=len(events))]
    for idx, event in enumerate(events[:10], start=1):
        region_display = alerts_display_region_name(event.get("region") or event.get("region_display") or "", lang)
        start_text = alerts_format_timestamp(event.get("started_at")) or labels["status_unknown"]
        end_text = alerts_format_timestamp(event.get("ended_at")) if event.get("ended_at") else labels["status_active"]
        type_text = alerts_type_label(event, lang)
        severity_text = alerts_severity_label(event, lang)
        ended = bool(event.get("ended_at"))
        status_key = "standdown" if ended else "alert"
        status_icon = "üü°" if ended else "üî¥"
        summary_parts = [status_labels[status_key], type_text]
        if severity_text:
            summary_parts.append(severity_text)
        lines.append(f"{idx}. {status_icon} <b>{h(region_display)}</b> ‚Äî {h(' ‚Ä¢ '.join(summary_parts))}")
        lines.append(f"{indent}‚è± {h(labels['started'])}: {h(start_text)}")
        if ended:
            lines.append(f"{indent}üõë {h(labels['ended'])}: {h(end_text)}")
    await clear_then_anchor(uid, "\n".join(lines), kb_alerts(uid))
    await alerts_send_card(uid, c.message.chat.id, events, "history", index=0)
    await c.answer()


@dp.callback_query_handler(lambda c: c.data == "alerts_subscriptions")
async def alerts_subscriptions_menu(c: types.CallbackQuery):
    uid = c.from_user.id
    text, kb = alerts_subscription_view(uid, page=0)
    await clear_then_anchor(uid, text, kb)
    await c.answer()


@dp.callback_query_handler(lambda c: c.data.startswith("alerts_sub_page:"))
async def alerts_subscriptions_page(c: types.CallbackQuery):
    uid = c.from_user.id
    try:
        page = int(c.data.split(":", 1)[1])
    except ValueError:
        page = 0
    text, kb = alerts_subscription_view(uid, page=page)
    await anchor_show_text(uid, text, kb)
    await c.answer()


@dp.callback_query_handler(lambda c: c.data.startswith("alerts_toggle:"))
async def alerts_toggle_subscription(c: types.CallbackQuery):
    uid = c.from_user.id
    try:
        _, page_raw, idx_raw = c.data.split(":", 2)
        page = int(page_raw)
        region_index = int(idx_raw)
    except Exception:
        await c.answer("", show_alert=False)
        return
    profile = load_user(uid) or {"user_id": uid}
    alerts = alerts_profile_block(profile)
    region = alerts_canonical_region(UKRAINE_REGIONS[region_index]) or UKRAINE_REGIONS[region_index]
    items = alerts.get("regions", [])
    add = region not in items
    alerts_update_subscription(uid, region_index, add)
    text, kb = alerts_subscription_view(uid, page=page)
    await anchor_show_text(uid, text, kb)
    key = "ALERTS_SUBS_ADDED" if add else "ALERTS_SUBS_REMOVED"
    await c.answer(tr(uid, key, region=h(region)), show_alert=False)


@dp.callback_query_handler(lambda c: c.data == "alerts_locked")
async def alerts_locked_info(c: types.CallbackQuery):
    uid = c.from_user.id
    await c.answer(tr(uid, "ALERTS_SUBS_LOCKED"), show_alert=True)


@dp.callback_query_handler(lambda c: c.data.startswith("alerts_index:"))
async def alerts_card_index_stub(c: types.CallbackQuery):
    await c.answer()


@dp.callback_query_handler(lambda c: c.data.startswith("alerts_nav:"))
async def alerts_card_nav(c: types.CallbackQuery):
    uid = c.from_user.id
    parts = c.data.split(":", 2)
    if len(parts) != 3:
        await c.answer()
        return
    context = parts[1]
    try:
        target_index = int(parts[2])
    except ValueError:
        await c.answer()
        return
    runtime = users_runtime.setdefault(uid, {})
    cards = runtime.get("alerts_cards", {})
    card = cards.get(context)
    if not card:
        await c.answer()
        return
    event_ids: List[str] = card.get("events", [])
    events: List[Dict[str, Any]] = []
    for event_id in event_ids:
        event = _alerts_get_event(event_id)
        if event:
            events.append(event)
    if not events:
        await c.answer(tr(uid, "ALERTS_NO_ACTIVE"), show_alert=True)
        return
    target_index = max(0, min(target_index, len(events) - 1))
    current_index = max(0, min(int(card.get("index", 0)), len(events) - 1))
    if target_index == current_index:
        await c.answer()
        return
    card["index"] = target_index
    lang = resolve_lang(uid)
    text = alerts_format_card(events[target_index], lang, index=target_index, total=len(events))
    kb = alerts_card_keyboard(uid, context, len(events), target_index)
    try:
        await bot.edit_message_text(text, c.message.chat.id, c.message.message_id, reply_markup=kb, disable_web_page_preview=True)
    except MessageNotModified:
        pass
    await c.answer()


@dp.callback_query_handler(lambda c: c.data.startswith("alerts_close:"))
async def alerts_close_card(c: types.CallbackQuery):
    uid = c.from_user.id
    context = c.data.split(":", 1)[1]
    runtime = users_runtime.setdefault(uid, {})
    cards = runtime.setdefault("alerts_cards", {})
    cards.pop(context, None)
    try:
        await bot.delete_message(c.message.chat.id, c.message.message_id)
    except Exception:
        pass
    await c.answer()


@dp.callback_query_handler(lambda c: c.data.startswith("alerts_push:"))
async def alerts_push_actions(c: types.CallbackQuery):
    uid = c.from_user.id
    parts = c.data.split(":", 2)
    if len(parts) != 3:
        await c.answer()
        return
    action, token = parts[1], parts[2]
    entry = alerts_push_get(uid, token)
    if not entry:
        await c.answer(tr(uid, "ALERTS_NO_ACTIVE"), show_alert=True)
        return
    event_id = entry.get("event_id")
    event = _alerts_get_event(event_id) if event_id else None
    if action in {"expand", "collapse"}:
        if not event:
            await c.answer(tr(uid, "ALERTS_NO_ACTIVE"), show_alert=True)
            return
        expanded = action == "expand"
        kind = entry.get("kind") or ("end" if event.get("ended_at") else "start")
        entry["kind"] = kind
        entry["expanded"] = expanded
        text = alerts_push_render(uid, event, kind, expanded=expanded)
        kb = alerts_push_keyboard(uid, token, expanded)
        try:
            await bot.edit_message_text(
                text,
                c.message.chat.id,
                c.message.message_id,
                reply_markup=kb,
                disable_web_page_preview=True,
            )
        except MessageNotModified:
            pass
        except MessageCantBeEdited:
            pass
        alerts_push_store(uid, token, entry)
        await c.answer()
        return
    if action == "delete":
        alerts_push_remove(uid, token)
        try:
            await bot.delete_message(c.message.chat.id, c.message.message_id)
        except Exception:
            pass
        await c.answer()
        return
    await c.answer()


@dp.callback_query_handler(lambda c: c.data == "back_root")
async def back_root(c: types.CallbackQuery):
    uid = c.from_user.id
    await clear_then_anchor(uid, project_status_text(uid), kb_root(uid))
    await c.answer()


# ========================== ALERTS STORAGE ==========================
ALERTS_STORAGE_BASE = os.path.join("data", ALERTS_DIRNAME)
_alerts_state_cache: Dict[str, Dict[str, Any]] = {}
_alerts_user_cache: Dict[str, Dict[str, Any]] = {}


def _alerts_resolve_project(project: Optional[str] = None) -> Optional[str]:
    if project:
        return project
    return None


def _alerts_context_key(project: Optional[str] = None) -> str:
    resolved = _alerts_resolve_project(project)
    return resolved or "__global__"


def alerts_storage_root(project: Optional[str] = None) -> str:
    base = ALERTS_STORAGE_BASE
    os.makedirs(base, exist_ok=True)

    def _ensure_flattened() -> None:
        legacy_global = os.path.join(base, "__global__")
        if os.path.isdir(legacy_global):
            for name in (ALERTS_STATE_FILENAME, ALERTS_USERS_FILENAME):
                src = os.path.join(legacy_global, name)
                dst = os.path.join(base, name)
                if os.path.exists(src) and not os.path.exists(dst):
                    os.replace(src, dst)
            legacy_history = os.path.join(legacy_global, ALERTS_HISTORY_DIRNAME)
            if os.path.isdir(legacy_history):
                target_history = os.path.join(base, ALERTS_HISTORY_DIRNAME)
                os.makedirs(target_history, exist_ok=True)
                for entry in os.listdir(legacy_history):
                    src = os.path.join(legacy_history, entry)
                    dst = os.path.join(target_history, entry)
                    if os.path.exists(src) and not os.path.exists(dst):
                        os.replace(src, dst)
            try:
                if not os.listdir(legacy_global):
                    os.rmdir(legacy_global)
            except Exception:
                pass

    _ensure_flattened()

    if project and project not in {"", "__global__"}:
        legacy_path = os.path.join(base, project)
        if os.path.isdir(legacy_path):
            return legacy_path
    return base


def alerts_state_file(project: Optional[str] = None) -> str:
    return os.path.join(alerts_storage_root(project), ALERTS_STATE_FILENAME)


def alerts_history_dir(project: Optional[str] = None) -> str:
    path = os.path.join(alerts_storage_root(project), ALERTS_HISTORY_DIRNAME)
    os.makedirs(path, exist_ok=True)
    return path


def alerts_history_file(project: Optional[str] = None, day_key: Optional[str] = None) -> str:
    day = day_key or alerts_today_key()
    return os.path.join(alerts_history_dir(project), f"{day}.json")


def alerts_users_file(project: Optional[str] = None) -> str:
    return os.path.join(alerts_storage_root(project), ALERTS_USERS_FILENAME)


def _alerts_save_timeline(project: Optional[str], timeline: List[Dict[str, Any]], day_key: Optional[str] = None) -> None:
    path = alerts_history_file(project, day_key)
    tmp_file = f"{path}.tmp"
    with open(tmp_file, "w", encoding="utf-8") as fh:
        json.dump(timeline, fh, ensure_ascii=False, indent=2)
    os.replace(tmp_file, path)


def _alerts_load_timeline(project: Optional[str], day_key: Optional[str] = None) -> List[Dict[str, Any]]:
    path = alerts_history_file(project, day_key)
    if not os.path.exists(path):
        return []
    try:
        with open(path, "r", encoding="utf-8") as fh:
            payload = json.load(fh)
        if isinstance(payload, list):
            return payload
    except Exception:
        pass
    return []


def _alerts_write_state_payload(project: Optional[str], payload: Dict[str, Any]) -> None:
    timeline = list(payload.get(ALERTS_TIMELINE_KEY) or [])
    day_key = payload.get("_timeline_day") or alerts_today_key()
    state_copy = dict(payload)
    state_copy.pop(ALERTS_TIMELINE_KEY, None)
    state_copy.pop("_timeline_day", None)
    state_copy.pop("_context_project", None)
    path = alerts_state_file(project)
    tmp_file = f"{path}.tmp"
    with open(tmp_file, "w", encoding="utf-8") as fh:
        json.dump(state_copy, fh, ensure_ascii=False, indent=2)
    os.replace(tmp_file, path)
    _alerts_save_timeline(project, timeline, day_key)


def _alerts_migrate_legacy(project: Optional[str]) -> None:
    if not project:
        return
    legacy_root = os.path.join(proj_path(project), ALERTS_DIRNAME)
    if not os.path.isdir(legacy_root):
        return
    state_path = alerts_state_file(project)
    subs_path = alerts_users_file(project)
    migrated = False
    if not os.path.exists(state_path):
        legacy_history = os.path.join(legacy_root, ALERTS_LEGACY_HISTORY_FILENAME)
        if os.path.exists(legacy_history):
            try:
                with open(legacy_history, "r", encoding="utf-8") as fh:
                    legacy_payload = json.load(fh)
                if not isinstance(legacy_payload, dict):
                    raise ValueError("Invalid legacy alerts state")
            except Exception:
                legacy_payload = _alerts_blank_state()
            payload = _alerts_blank_state()
            payload.update({
                "events": legacy_payload.get("events", {}),
                "regions": legacy_payload.get("regions", {}),
                "last_fetch": legacy_payload.get("last_fetch"),
            })
            timeline = legacy_payload.get(ALERTS_TIMELINE_KEY)
            if isinstance(timeline, list):
                payload[ALERTS_TIMELINE_KEY] = timeline
            payload["_timeline_day"] = alerts_today_key()
            payload["_context_project"] = project
            _alerts_write_state_payload(project, payload)
            migrated = True
    if not os.path.exists(subs_path):
        legacy_subs = os.path.join(legacy_root, ALERTS_USERS_FILENAME)
        if os.path.exists(legacy_subs):
            try:
                with open(legacy_subs, "r", encoding="utf-8") as fh:
                    subs_payload = json.load(fh)
                if isinstance(subs_payload, dict):
                    tmp_file = f"{subs_path}.tmp"
                    with open(tmp_file, "w", encoding="utf-8") as fh:
                        json.dump(subs_payload, fh, ensure_ascii=False, indent=2)
                    os.replace(tmp_file, subs_path)
                    migrated = True
            except Exception:
                pass
    if migrated:
        try:
            legacy_marker = os.path.join(legacy_root, "migrated.txt")
            with open(legacy_marker, "w", encoding="utf-8") as fh:
                fh.write(alerts_now().isoformat())
        except Exception:
            pass


if ZoneInfo:
    try:
        ALERTS_TIMEZONE = ZoneInfo("Europe/Kiev")
    except Exception:
        ALERTS_TIMEZONE = timezone.utc
else:
    ALERTS_TIMEZONE = timezone.utc

ALERTS_REGION_EQUIVALENTS: Dict[str, List[str]] = {
    "–í–∏–Ω–Ω–∏—Ü–∫–∞—è –æ–±–ª–∞—Å—Ç—å": ["–í—ñ–Ω–Ω–∏—Ü—å–∫–∞ –æ–±–ª–∞—Å—Ç—å", "Vinnytska oblast", "Vinnytsia region"],
    "–í–æ–ª—ã–Ω—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å": ["–í–æ–ª–∏–Ω—Å—å–∫–∞ –æ–±–ª–∞—Å—Ç—å", "Volynska oblast", "Volyn region"],
    "–î–Ω–µ–ø—Ä–æ–ø–µ—Ç—Ä–æ–≤—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å": ["–î–Ω—ñ–ø—Ä–æ–ø–µ—Ç—Ä–æ–≤—Å—å–∫–∞ –æ–±–ª–∞—Å—Ç—å", "Dnipropetrovska oblast", "Dnipropetrovsk region"],
    "–î–æ–Ω–µ—Ü–∫–∞—è –æ–±–ª–∞—Å—Ç—å": ["–î–æ–Ω–µ—Ü—å–∫–∞ –æ–±–ª–∞—Å—Ç—å", "Donetska oblast", "Donetsk region"],
    "–ñ–∏—Ç–æ–º–∏—Ä—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å": ["–ñ–∏—Ç–æ–º–∏—Ä—Å—å–∫–∞ –æ–±–ª–∞—Å—Ç—å", "Zhytomyrska oblast", "Zhytomyr region"],
    "–ó–∞–∫–∞—Ä–ø–∞—Ç—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å": ["–ó–∞–∫–∞—Ä–ø–∞—Ç—Å—å–∫–∞ –æ–±–ª–∞—Å—Ç—å", "Zakarpatska oblast", "Zakarpattia region"],
    "–ó–∞–ø–æ—Ä–æ–∂—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å": ["–ó–∞–ø–æ—Ä—ñ–∑—å–∫–∞ –æ–±–ª–∞—Å—Ç—å", "Zaporizka oblast", "Zaporizhzhia region"],
    "–ò–≤–∞–Ω–æ-–§—Ä–∞–Ω–∫–æ–≤—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å": ["–Ü–≤–∞–Ω–æ-–§—Ä–∞–Ω–∫—ñ–≤—Å—å–∫–∞ –æ–±–ª–∞—Å—Ç—å", "Ivano-Frankivska oblast", "Ivano-Frankivsk region"],
    "–ö–∏–µ–≤—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å": [
        "–ö–∏—ó–≤—Å—å–∫–∞ –æ–±–ª–∞—Å—Ç—å",
        "Kyivska oblast",
        "Kyiv region",
        "–º. –ö–∏—ó–≤",
        "–ö–∏—ó–≤",
        "Kyiv",
        "Kiev",
        "Kyiv City",
    ],
    "–ö–∏—Ä–æ–≤–æ–≥—Ä–∞–¥—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å": ["–ö—ñ—Ä–æ–≤–æ–≥—Ä–∞–¥—Å—å–∫–∞ –æ–±–ª–∞—Å—Ç—å", "Kirovohradska oblast", "Kirovohrad region"],
    "–õ—É–≥–∞–Ω—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å": ["–õ—É–≥–∞–Ω—Å—å–∫–∞ –æ–±–ª–∞—Å—Ç—å", "Luhanska oblast", "Luhansk region"],
    "–õ—å–≤–æ–≤—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å": ["–õ—å–≤—ñ–≤—Å—å–∫–∞ –æ–±–ª–∞—Å—Ç—å", "Lvivska oblast", "Lviv region"],
    "–ù–∏–∫–æ–ª–∞–µ–≤—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å": ["–ú–∏–∫–æ–ª–∞—ó–≤—Å—å–∫–∞ –æ–±–ª–∞—Å—Ç—å", "Mykolaivska oblast", "Mykolaiv region"],
    "–û–¥–µ—Å—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å": ["–û–¥–µ—Å—å–∫–∞ –æ–±–ª–∞—Å—Ç—å", "Odeska oblast", "Odesa region"],
    "–ü–æ–ª—Ç–∞–≤—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å": ["–ü–æ–ª—Ç–∞–≤—Å—å–∫–∞ –æ–±–ª–∞—Å—Ç—å", "Poltavska oblast", "Poltava region"],
    "–†–æ–≤–µ–Ω—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å": ["–†—ñ–≤–Ω–µ–Ω—Å—å–∫–∞ –æ–±–ª–∞—Å—Ç—å", "Rivnenska oblast", "Rivne region"],
    "–°—É–º—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å": ["–°—É–º—Å—å–∫–∞ –æ–±–ª–∞—Å—Ç—å", "Sumska oblast", "Sumy region"],
    "–¢–µ—Ä–Ω–æ–ø–æ–ª—å—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å": ["–¢–µ—Ä–Ω–æ–ø—ñ–ª—å—Å—å–∫–∞ –æ–±–ª–∞—Å—Ç—å", "Ternopilska oblast", "Ternopil region"],
    "–•–∞—Ä—å–∫–æ–≤—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å": ["–•–∞—Ä–∫—ñ–≤—Å—å–∫–∞ –æ–±–ª–∞—Å—Ç—å", "Kharkivska oblast", "Kharkiv region"],
    "–•–µ—Ä—Å–æ–Ω—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å": ["–•–µ—Ä—Å–æ–Ω—Å—å–∫–∞ –æ–±–ª–∞—Å—Ç—å", "Khersonska oblast", "Kherson region"],
    "–•–º–µ–ª—å–Ω–∏—Ü–∫–∞—è –æ–±–ª–∞—Å—Ç—å": ["–•–º–µ–ª—å–Ω–∏—Ü—å–∫–∞ –æ–±–ª–∞—Å—Ç—å", "Khmelnytska oblast", "Khmelnytskyi region"],
    "–ß–µ—Ä–∫–∞—Å—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å": ["–ß–µ—Ä–∫–∞—Å—å–∫–∞ –æ–±–ª–∞—Å—Ç—å", "Cherkaska oblast", "Cherkasy region"],
    "–ß–µ—Ä–Ω–∏–≥–æ–≤—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å": ["–ß–µ—Ä–Ω—ñ–≥—ñ–≤—Å—å–∫–∞ –æ–±–ª–∞—Å—Ç—å", "Chernihivska oblast", "Chernihiv region"],
    "–ß–µ—Ä–Ω–æ–≤–∏—Ü–∫–∞—è –æ–±–ª–∞—Å—Ç—å": ["–ß–µ—Ä–Ω—ñ–≤–µ—Ü—å–∫–∞ –æ–±–ª–∞—Å—Ç—å", "Chernivetska oblast", "Chernivtsi region"],
}

ALERTS_REGION_SHORT_NAMES: Dict[str, Dict[str, str]] = {
    "–í–∏–Ω–Ω–∏—Ü–∫–∞—è –æ–±–ª–∞—Å—Ç—å": {
        "uk": "–í—ñ–Ω–Ω–∏—Ü—è",
        "ru": "–í–∏–Ω–Ω–∏—Ü–∞",
        "en": "Vinnytsia",
        "de": "Winnyzja",
        "pl": "Winnica",
    },
    "–í–æ–ª—ã–Ω—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å": {
        "uk": "–í–æ–ª–∏–Ω—å",
        "ru": "–í–æ–ª—ã–Ω—å",
        "en": "Volyn",
        "de": "Wolhynien",
        "pl": "Wo≈Çy≈Ñ",
    },
    "–î–Ω–µ–ø—Ä–æ–ø–µ—Ç—Ä–æ–≤—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å": {
        "uk": "–î–Ω—ñ–ø—Ä–æ",
        "ru": "–î–Ω–µ–ø—Ä",
        "en": "Dnipro",
        "de": "Dnipro",
        "pl": "Dnipro",
    },
    "–î–æ–Ω–µ—Ü–∫–∞—è –æ–±–ª–∞—Å—Ç—å": {
        "uk": "–î–æ–Ω–µ—Ü—å–∫",
        "ru": "–î–æ–Ω–µ—Ü–∫",
        "en": "Donetsk",
        "de": "Donezk",
        "pl": "Donieck",
    },
    "–ñ–∏—Ç–æ–º–∏—Ä—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å": {
        "uk": "–ñ–∏—Ç–æ–º–∏—Ä",
        "ru": "–ñ–∏—Ç–æ–º–∏—Ä",
        "en": "Zhytomyr",
        "de": "Schytomyr",
        "pl": "≈ªytomierz",
    },
    "–ó–∞–∫–∞—Ä–ø–∞—Ç—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å": {
        "uk": "–ó–∞–∫–∞—Ä–ø–∞—Ç—Ç—è",
        "ru": "–ó–∞–∫–∞—Ä–ø–∞—Ç—å–µ",
        "en": "Zakarpattia",
        "de": "Transkarpatien",
        "pl": "Zakarpacie",
    },
    "–ó–∞–ø–æ—Ä–æ–∂—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å": {
        "uk": "–ó–∞–ø–æ—Ä—ñ–∂–∂—è",
        "ru": "–ó–∞–ø–æ—Ä–æ–∂—å–µ",
        "en": "Zaporizhzhia",
        "de": "Saporischschja",
        "pl": "Zaporo≈ºe",
    },
    "–ò–≤–∞–Ω–æ-–§—Ä–∞–Ω–∫–æ–≤—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å": {
        "uk": "–Ü–≤–∞–Ω–æ-–§—Ä–∞–Ω–∫—ñ–≤—Å—å–∫",
        "ru": "–ò–≤–∞–Ω–æ-–§—Ä–∞–Ω–∫–æ–≤—Å–∫",
        "en": "Ivano-Frankivsk",
        "de": "Iwano-Frankiwsk",
        "pl": "Iwano-Frankiwsk",
    },
    "–ö–∏–µ–≤—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å": {
        "uk": "–ö–∏—ó–≤",
        "ru": "–ö–∏–µ–≤",
        "en": "Kyiv",
        "de": "Kyjiw",
        "pl": "Kij√≥w",
    },
    "–ö–∏—Ä–æ–≤–æ–≥—Ä–∞–¥—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å": {
        "uk": "–ö—Ä–æ–ø–∏–≤–Ω–∏—Ü—å–∫–∏–π",
        "ru": "–ö—Ä–æ–ø–∏–≤–Ω–∏—Ü–∫–∏–π",
        "en": "Kropyvnytskyi",
        "de": "Kropywnyzkyj",
        "pl": "Kropywnycki",
    },
    "–õ—É–≥–∞–Ω—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å": {
        "uk": "–õ—É–≥–∞–Ω—Å—å–∫",
        "ru": "–õ—É–≥–∞–Ω—Å–∫",
        "en": "Luhansk",
        "de": "Luhansk",
        "pl": "≈Åuga≈Ñsk",
    },
    "–õ—å–≤–æ–≤—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å": {
        "uk": "–õ—å–≤—ñ–≤",
        "ru": "–õ—å–≤–æ–≤",
        "en": "Lviv",
        "de": "Lwiw",
        "pl": "Lw√≥w",
    },
    "–ù–∏–∫–æ–ª–∞–µ–≤—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å": {
        "uk": "–ú–∏–∫–æ–ª–∞—ó–≤",
        "ru": "–ù–∏–∫–æ–ª–∞–µ–≤",
        "en": "Mykolaiv",
        "de": "Mykolajiw",
        "pl": "Miko≈Çaj√≥w",
    },
    "–û–¥–µ—Å—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å": {
        "uk": "–û–¥–µ—Å–∞",
        "ru": "–û–¥–µ—Å—Å–∞",
        "en": "Odesa",
        "de": "Odessa",
        "pl": "Odessa",
    },
    "–ü–æ–ª—Ç–∞–≤—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å": {
        "uk": "–ü–æ–ª—Ç–∞–≤–∞",
        "ru": "–ü–æ–ª—Ç–∞–≤–∞",
        "en": "Poltava",
        "de": "Poltawa",
        "pl": "Po≈Çtawa",
    },
    "–†–æ–≤–µ–Ω—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å": {
        "uk": "–†—ñ–≤–Ω–µ",
        "ru": "–†–æ–≤–Ω–æ",
        "en": "Rivne",
        "de": "Riwne",
        "pl": "R√≥wne",
    },
    "–°—É–º—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å": {
        "uk": "–°—É–º–∏",
        "ru": "–°—É–º—ã",
        "en": "Sumy",
        "de": "Sumy",
        "pl": "Sumy",
    },
    "–¢–µ—Ä–Ω–æ–ø–æ–ª—å—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å": {
        "uk": "–¢–µ—Ä–Ω–æ–ø—ñ–ª—å",
        "ru": "–¢–µ—Ä–Ω–æ–ø–æ–ª—å",
        "en": "Ternopil",
        "de": "Ternopil",
        "pl": "Tarnopol",
    },
    "–•–∞—Ä—å–∫–æ–≤—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å": {
        "uk": "–•–∞—Ä–∫—ñ–≤",
        "ru": "–•–∞—Ä—å–∫–æ–≤",
        "en": "Kharkiv",
        "de": "Charkiw",
        "pl": "Chark√≥w",
    },
    "–•–µ—Ä—Å–æ–Ω—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å": {
        "uk": "–•–µ—Ä—Å–æ–Ω",
        "ru": "–•–µ—Ä—Å–æ–Ω",
        "en": "Kherson",
        "de": "Cherson",
        "pl": "Cherso≈Ñ",
    },
    "–•–º–µ–ª—å–Ω–∏—Ü–∫–∞—è –æ–±–ª–∞—Å—Ç—å": {
        "uk": "–•–º–µ–ª—å–Ω–∏—Ü—å–∫–∏–π",
        "ru": "–•–º–µ–ª—å–Ω–∏—Ü–∫–∏–π",
        "en": "Khmelnytskyi",
        "de": "Chmelnyzkyj",
        "pl": "Chmielnicki",
    },
    "–ß–µ—Ä–∫–∞—Å—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å": {
        "uk": "–ß–µ—Ä–∫–∞—Å–∏",
        "ru": "–ß–µ—Ä–∫–∞—Å—Å—ã",
        "en": "Cherkasy",
        "de": "Tscherkassy",
        "pl": "Czerkasy",
    },
    "–ß–µ—Ä–Ω–∏–≥–æ–≤—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å": {
        "uk": "–ß–µ—Ä–Ω—ñ–≥—ñ–≤",
        "ru": "–ß–µ—Ä–Ω–∏–≥–æ–≤",
        "en": "Chernihiv",
        "de": "Tschernihiw",
        "pl": "Czernih√≥w",
    },
    "–ß–µ—Ä–Ω–æ–≤–∏—Ü–∫–∞—è –æ–±–ª–∞—Å—Ç—å": {
        "uk": "–ß–µ—Ä–Ω—ñ–≤—Ü—ñ",
        "ru": "–ß–µ—Ä–Ω–æ–≤—Ü—ã",
        "en": "Chernivtsi",
        "de": "Tscherniwzi",
        "pl": "Czerniowce",
    },
}

ALERTS_TYPE_ALIASES: Dict[str, str] = {
    "air_raid": "air_raid",
    "air-raid": "air_raid",
    "airalert": "air_raid",
    "air alert": "air_raid",
    "air_raid_alert": "air_raid",
    "artillery": "artillery_shelling",
    "artillery_shelling": "artillery_shelling",
    "shelling": "artillery_shelling",
    "missile": "missile_strike",
    "missile_attack": "missile_strike",
    "missile_strike": "missile_strike",
    "rocket": "missile_strike",
    "rocket_attack": "missile_strike",
    "ballistic": "missile_strike",
    "ballistic_missile": "missile_strike",
    "drone": "drone_attack",
    "drone_attack": "drone_attack",
    "uav": "drone_attack",
    "nuclear": "nuclear",
    "nuclear_threat": "nuclear",
    "chemical": "chemical",
    "chemical_threat": "chemical",
    "urban_fights": "urban_fights",
    "urban": "urban_fights",
    "ground_assault": "urban_fights",
    "unknown": "unknown",
}

ALERTS_DEFAULT_SEVERITY: Dict[str, str] = {
    "air_raid": "high",
    "artillery_shelling": "high",
    "missile_strike": "critical",
    "drone_attack": "medium",
    "nuclear": "critical",
    "chemical": "critical",
    "urban_fights": "high",
    "unknown": "high",
}

ALERTS_SEVERITY_KEYWORDS: Dict[str, str] = {
    "critical": "critical",
    "extreme": "critical",
    "highest": "critical",
    "max": "critical",
    "–º–∞–∫—Å–∏–º": "critical",
    "–∫—Ä–∏—Ç": "critical",
    "violet": "critical",
    "purple": "critical",
    "—Ñ—ñ–æ–ª–µ—Ç": "critical",
    "—á–µ—Ä–≤–æ–Ω": "high",
    "red": "high",
    "–≤–∏—Å–æ–∫": "high",
    "high": "high",
    "–ø–æ–≤—ñ—Ç—Ä—è–Ω–∞": "high",
    "–∂–æ–≤—Ç": "medium",
    "yellow": "medium",
    "orange": "medium",
    "–ø–æ–º–∞—Ä–∞–Ω": "medium",
    "—Å–µ—Ä–µ–¥–Ω": "medium",
    "medium": "medium",
    "elevated": "medium",
    "–∑–µ–ª": "low",
    "green": "low",
    "–Ω–∏–∑": "low",
    "low": "low",
    "–º—ñ–Ω—ñ–º": "low",
    "none": "low",
    "–≤—ñ–¥—Å—É—Ç": "low",
    "–±–µ–∑": "low",
}

ALERTS_TYPE_LABELS: Dict[str, Dict[str, str]] = {
    "air_raid": {
        "uk": "–ü–æ–≤—ñ—Ç—Ä—è–Ω–∞ —Ç—Ä–∏–≤–æ–≥–∞",
        "en": "Air raid alert",
        "de": "Luftalarm",
        "pl": "Alarm lotniczy",
        "ru": "–í–æ–∑–¥—É—à–Ω–∞—è —Ç—Ä–µ–≤–æ–≥–∞",
    },
    "artillery_shelling": {
        "uk": "–ê—Ä—Ç–∏–ª–µ—Ä—ñ–π—Å—å–∫–∏–π –æ–±—Å—Ç—Ä—ñ–ª",
        "en": "Artillery shelling",
        "de": "Artilleriebeschuss",
        "pl": "Ostrza≈Ç artyleryjski",
        "ru": "–ê—Ä—Ç–∏–ª–ª–µ—Ä–∏–π—Å–∫–∏–π –æ–±—Å—Ç—Ä–µ–ª",
    },
    "missile_strike": {
        "uk": "–†–∞–∫–µ—Ç–Ω–∞ –∑–∞–≥—Ä–æ–∑–∞",
        "en": "Missile threat",
        "de": "Raketenbedrohung",
        "pl": "Zagro≈ºenie rakietowe",
        "ru": "–†–∞–∫–µ—Ç–Ω–∞—è —É–≥—Ä–æ–∑–∞",
    },
    "drone_attack": {
        "uk": "–ê—Ç–∞–∫–∞ –¥—Ä–æ–Ω—ñ–≤",
        "en": "Drone attack",
        "de": "Drohnenangriff",
        "pl": "Atak dron√≥w",
        "ru": "–ê—Ç–∞–∫–∞ –¥—Ä–æ–Ω–æ–≤",
    },
    "nuclear": {
        "uk": "–Ø–¥–µ—Ä–Ω–∞ –∑–∞–≥—Ä–æ–∑–∞",
        "en": "Nuclear threat",
        "de": "Atomare Gefahr",
        "pl": "Zagro≈ºenie nuklearne",
        "ru": "–Ø–¥–µ—Ä–Ω–∞—è —É–≥—Ä–æ–∑–∞",
    },
    "chemical": {
        "uk": "–•—ñ–º—ñ—á–Ω–∞ –∑–∞–≥—Ä–æ–∑–∞",
        "en": "Chemical threat",
        "de": "Chemische Gefahr",
        "pl": "Zagro≈ºenie chemiczne",
        "ru": "–•–∏–º–∏—á–µ—Å–∫–∞—è —É–≥—Ä–æ–∑–∞",
    },
    "urban_fights": {
        "uk": "–ë–æ—ó –≤ –º—ñ—Å—Ç—ñ",
        "en": "Urban fights",
        "de": "Stra√üenk√§mpfe",
        "pl": "Walki w mie≈õcie",
        "ru": "–ë–æ–∏ –≤ –≥–æ—Ä–æ–¥–µ",
    },
    "unknown": {
        "uk": "–¢—Ä–∏–≤–æ–≥–∞",
        "en": "Alert",
        "de": "Alarm",
        "pl": "Alarm",
        "ru": "–¢—Ä–µ–≤–æ–≥–∞",
    },
}

ALERTS_TYPE_ICONS: Dict[str, str] = {
    "air_raid": "üì°",
    "missile_strike": "üöÄ",
    "drone_attack": "üõ©",
    "artillery_shelling": "üí•",
    "urban_fights": "‚öîÔ∏è",
    "nuclear": "‚ò¢",
    "chemical": "‚ò£",
    "unknown": "üö®",
}

ALERTS_SEVERITY_LABELS: Dict[str, Dict[str, str]] = {
    "low": {
        "icon": "üü¢",
        "uk": "–ù–∏–∑—å–∫–∏–π",
        "en": "Low",
        "de": "Niedrig",
        "pl": "Niski",
        "ru": "–ù–∏–∑–∫–∏–π",
    },
    "medium": {
        "icon": "üü°",
        "uk": "–°–µ—Ä–π–æ–∑–Ω–∏–π",
        "en": "Serious",
        "de": "Ernst",
        "pl": "Powa≈ºny",
        "ru": "–°–µ—Ä—å—ë–∑–Ω—ã–π",
    },
    "high": {
        "icon": "üü†",
        "uk": "–í–∏—Å–æ–∫–∏–π",
        "en": "High",
        "de": "Hoch",
        "pl": "Wysoki",
        "ru": "–í—ã—Å–æ–∫–∏–π",
    },
    "critical": {
        "icon": "üî¥",
        "uk": "–ù–µ–±–µ–∑–ø–µ—á–Ω–∏–π",
        "en": "Critical",
        "de": "Kritisch",
        "pl": "Krytyczny",
        "ru": "–û–ø–∞—Å–Ω—ã–π",
    },
}

ALERTS_STATUS_TEXT: Dict[str, Dict[str, str]] = {
    "uk": {
        "alert": "–¢—Ä–∏–≤–æ–≥–∞",
        "standdown": "–í—ñ–¥–±—ñ–π —Ç—Ä–∏–≤–æ–≥–∏",
        "calm": "–í—ñ–¥–±—ñ–π —Ç—Ä–∏–≤–æ–≥–∏",
    },
    "en": {
        "alert": "Alert",
        "standdown": "Alert cleared",
        "calm": "Alert cleared",
    },
    "de": {
        "alert": "Alarm",
        "standdown": "Alarm beendet",
        "calm": "Alarm aufgehoben",
    },
    "pl": {
        "alert": "Alarm",
        "standdown": "Alarm odwo≈Çano",
        "calm": "Alarm odwo≈Çano",
    },
    "ru": {
        "alert": "–¢—Ä–µ–≤–æ–≥–∞",
        "standdown": "–û—Ç–±–æ–π —Ç—Ä–µ–≤–æ–≥–∏",
        "calm": "–û—Ç–±–æ–π —Ç—Ä–µ–≤–æ–≥–∏",
    },
}

ALERTS_DURATION_FORMS: Dict[str, Dict[str, Tuple[str, ...]]] = {
    "uk": {
        "hour": ("–≥–æ–¥", "–≥–æ–¥", "–≥–æ–¥"),
        "minute": ("—Ö–≤", "—Ö–≤", "—Ö–≤"),
        "alarm": ("—Ç—Ä–∏–≤–æ–≥–∞", "—Ç—Ä–∏–≤–æ–≥–∏", "—Ç—Ä–∏–≤–æ–≥"),
    },
    "ru": {
        "hour": ("—á", "—á", "—á"),
        "minute": ("–º–∏–Ω", "–º–∏–Ω", "–º–∏–Ω"),
        "alarm": ("—Ç—Ä–µ–≤–æ–≥–∞", "—Ç—Ä–µ–≤–æ–≥–∏", "—Ç—Ä–µ–≤–æ–≥"),
    },
    "pl": {
        "hour": ("godz", "godz", "godz"),
        "minute": ("min", "min", "min"),
        "alarm": ("alarm", "alarmy", "alarm√≥w"),
    },
    "de": {
        "hour": ("Std", "Std"),
        "minute": ("Min", "Min"),
        "alarm": ("Alarm", "Alarme"),
    },
    "en": {
        "hour": ("hr", "hrs"),
        "minute": ("min", "min"),
        "alarm": ("alert", "alerts"),
    },
}

ALERTS_RECOMMENDATIONS: Dict[str, Dict[str, List[str]]] = {
    "default": {
        "uk": [
            "‚Äî –ü—Ä—è–º—É–π—Ç–µ –≤ —É–∫—Ä–∏—Ç—Ç—è",
            "‚Äî –ó–∞—á–∏–Ω—ñ—Ç—å –¥–≤–µ—Ä—ñ —Ç–∞ –≤—ñ–∫–Ω–∞",
            "‚Äî –¢—Ä–∏–º–∞–π—Ç–µ—Å—è –ø–æ–¥–∞–ª—ñ –≤—ñ–¥ –≤—ñ–∫–æ–Ω —ñ –≤—ñ—Ç—Ä–∏–Ω",
        ],
        "en": [
            "‚Äî Move to shelter",
            "‚Äî Close doors and windows",
            "‚Äî Stay away from windows and glass",
        ],
        "de": [
            "‚Äî Begeben Sie sich in einen Schutzraum",
            "‚Äî Schlie√üen Sie T√ºren und Fenster",
            "‚Äî Halten Sie Abstand von Fenstern und Glasfl√§chen",
        ],
        "pl": [
            "‚Äî Udaƒá siƒô do schronu",
            "‚Äî Zamknij drzwi i okna",
            "‚Äî Trzymaj siƒô z dala od okien i witryn",
        ],
        "ru": [
            "‚Äî –°–ª–µ–¥—É–π—Ç–µ –≤ —É–∫—Ä—ã—Ç–∏–µ",
            "‚Äî –ó–∞–∫—Ä–æ–π—Ç–µ –¥–≤–µ—Ä–∏ –∏ –æ–∫–Ω–∞",
            "‚Äî –ò–∑–±–µ–≥–∞–π—Ç–µ –æ–∫–æ–Ω –∏ –≤–∏—Ç—Ä–∏–Ω",
        ],
    }
}

ALERTS_OVERVIEW_STATUS_TEXT: Dict[str, Dict[str, str]] = {
    "uk": {
        "alert": "–¢—Ä–∏–≤–æ–≥–∞",
        "standdown": "–í—ñ–¥–±—ñ–π",
        "calm": "–í—ñ–¥–±—ñ–π",
    },
    "en": {
        "alert": "Alert",
        "standdown": "Cleared",
        "calm": "Cleared",
    },
    "de": {
        "alert": "Alarm",
        "standdown": "Entwarnung",
        "calm": "Entwarnung",
    },
    "pl": {
        "alert": "Alarm",
        "standdown": "Odwo≈Ç–∞–Ω–æ",
        "calm": "Odwo≈Ç–∞–Ω–æ",
    },
    "ru": {
        "alert": "–¢—Ä–µ–≤–æ–≥–∞",
        "standdown": "–û—Ç–±–æ–π",
        "calm": "–û—Ç–±–æ–π",
    },
}

ALERTS_LOCATION_TYPE_LABELS: Dict[str, Dict[str, str]] = {
    "oblast": {
        "uk": "–û–±–ª–∞—Å—Ç—å",
        "en": "Oblast",
        "de": "Oblast",
        "pl": "Obw√≥d",
        "ru": "–û–±–ª–∞—Å—Ç—å",
    },
    "raion": {
        "uk": "–†–∞–π–æ–Ω",
        "en": "District",
        "de": "Rajon",
        "pl": "Rejon",
        "ru": "–†–∞–π–æ–Ω",
    },
    "hromada": {
        "uk": "–ì—Ä–æ–º–∞–¥–∞",
        "en": "Community",
        "de": "Gemeinde",
        "pl": "Hromada",
        "ru": "–ì—Ä–æ–º–∞–¥–∞",
    },
    "community": {
        "uk": "–ì—Ä–æ–º–∞–¥–∞",
        "en": "Community",
        "de": "Gemeinschaft",
        "pl": "Wsp√≥lnota",
        "ru": "–°–æ–æ–±—â–µ—Å—Ç–≤–æ",
    },
    "city": {
        "uk": "–ú—ñ—Å—Ç–æ",
        "en": "City",
        "de": "Stadt",
        "pl": "Miasto",
        "ru": "–ì–æ—Ä–æ–¥",
    },
    "settlement": {
        "uk": "–ù–∞—Å–µ–ª–µ–Ω–∏–π –ø—É–Ω–∫—Ç",
        "en": "Settlement",
        "de": "Siedlung",
        "pl": "Osada",
        "ru": "–ù–∞—Å–µ–ª—ë–Ω–Ω—ã–π –ø—É–Ω–∫—Ç",
    },
    "village": {
        "uk": "–°–µ–ª–æ",
        "en": "Village",
        "de": "Dorf",
        "pl": "Wie≈õ",
        "ru": "–î–µ—Ä–µ–≤–Ω—è",
    },
}

ALERTS_FIELD_LABELS: Dict[str, Dict[str, str]] = {
    "uk": {
        "header_active": "üö® –£–í–ê–ì–ê! –¢–†–ò–í–û–ì–ê üö®",
        "header_ended": "üü¢ –í–Ü–î–ë–Ü–ô –¢–†–ò–í–û–ì–ò",
        "type": "–¢–∏–ø",
        "region": "–û–±–ª–∞—Å—Ç—å",
        "location": "–õ–æ–∫–∞—Ü—ñ—è",
        "location_type": "–¢–∏–ø –ª–æ–∫–∞—Ü—ñ—ó",
        "coordinates": "–ö–æ–æ—Ä–¥–∏–Ω–∞—Ç–∏",
        "severity": "–†—ñ–≤–µ–Ω—å",
        "cause": "–ü—Ä–∏—á–∏–Ω–∞",
        "details": "–î–µ—Ç–∞–ª—ñ",
        "started": "–ü–æ—á–∞—Ç–æ–∫",
        "ended": "–í—ñ–¥–±—ñ–π",
        "duration": "–¢—Ä–∏–≤–∞–ª—ñ—Å—Ç—å",
        "message": "–ü–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è",
        "source": "–î–∂–µ—Ä–µ–ª–æ",
        "status_active": "—â–µ —Ç—Ä–∏–≤–∞—î",
        "status_unknown": "‚Äî",
    },
    "en": {
        "header_active": "üö® ALERT IN PROGRESS üö®",
        "header_ended": "üü¢ ALERT ENDED",
        "type": "Type",
        "region": "Oblast",
        "location": "Location",
        "location_type": "Location type",
        "coordinates": "Coordinates",
        "severity": "Severity",
        "cause": "Cause",
        "details": "Details",
        "started": "Start",
        "ended": "End",
        "duration": "Duration",
        "message": "Message",
        "source": "Source",
        "status_active": "still active",
        "status_unknown": "‚Äî",
    },
    "de": {
        "header_active": "üö® ALARM AKTIV üö®",
        "header_ended": "üü¢ ALARM BEENDET",
        "type": "Art",
        "region": "Oblast",
        "location": "Ort",
        "location_type": "Ortstyp",
        "coordinates": "Koordinaten",
        "severity": "Stufe",
        "cause": "Ursache",
        "details": "Details",
        "started": "Beginn",
        "ended": "Ende",
        "duration": "Dauer",
        "message": "Meldung",
        "source": "Quelle",
        "status_active": "l√§uft noch",
        "status_unknown": "‚Äî",
    },
    "pl": {
        "header_active": "üö® TRWA ALARM üö®",
        "header_ended": "üü¢ ALARM ODWO≈ÅANY",
        "type": "Typ",
        "region": "Obw√≥d",
        "location": "Lokalizacja",
        "location_type": "Typ lokalizacji",
        "coordinates": "Wsp√≥≈Çrzƒôdne",
        "severity": "Poziom",
        "cause": "Przyczyna",
        "details": "Szczeg√≥≈Çy",
        "started": "PoczƒÖtek",
        "ended": "Zako≈Ñczenie",
        "duration": "Czas trwania",
        "message": "Komunikat",
        "source": "≈πr√≥d≈Ço",
        "status_active": "wciƒÖ≈º trwa",
        "status_unknown": "‚Äî",
    },
    "ru": {
        "header_active": "üö® –¢–†–ï–í–û–ì–ê! üö®",
        "header_ended": "üü¢ –û–¢–ë–û–ô –¢–†–ï–í–û–ì–ò",
        "type": "–¢–∏–ø",
        "region": "–û–±–ª–∞—Å—Ç—å",
        "location": "–õ–æ–∫–∞—Ü–∏—è",
        "location_type": "–¢–∏–ø –ª–æ–∫–∞—Ü–∏–∏",
        "coordinates": "–ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã",
        "severity": "–£—Ä–æ–≤–µ–Ω—å",
        "cause": "–ü—Ä–∏—á–∏–Ω–∞",
        "details": "–î–µ—Ç–∞–ª–∏",
        "started": "–ù–∞—á–∞–ª–æ",
        "ended": "–û—Ç–±–æ–π",
        "duration": "–î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å",
        "message": "–°–æ–æ–±—â–µ–Ω–∏–µ",
        "source": "–ò—Å—Ç–æ—á–Ω–∏–∫",
        "status_active": "–µ—â—ë –ø—Ä–æ–¥–æ–ª–∂–∞–µ—Ç—Å—è",
        "status_unknown": "‚Äî",
    },
}


def _alerts_ensure_storage(project: Optional[str] = None) -> None:
    alerts_storage_root(project)
    _alerts_migrate_legacy(project)


def _alerts_blank_state() -> Dict[str, Any]:
    return {
        "events": {},
        "regions": {},
        "last_fetch": None,
        ALERTS_TIMELINE_KEY: [],
        "_timeline_day": alerts_today_key(),
        "_context_project": None,
    }


def _alerts_refresh_timeline_day(state: Dict[str, Any], project: Optional[str]) -> None:
    expected_day = alerts_today_key()
    current_day = state.get("_timeline_day")
    if current_day == expected_day:
        return
    context_project = project if project is not None else state.get("_context_project")
    timeline = _alerts_load_timeline(context_project, expected_day)
    state[ALERTS_TIMELINE_KEY] = timeline
    state["_timeline_day"] = expected_day


def _alerts_load_state(project: Optional[str] = None) -> Dict[str, Any]:
    key = _alerts_context_key(project)
    cached = _alerts_state_cache.get(key)
    resolved = _alerts_resolve_project(project)
    if cached is not None:
        _alerts_refresh_timeline_day(cached, resolved)
        return cached
    _alerts_ensure_storage(resolved)
    path = alerts_state_file(resolved)
    if os.path.exists(path):
        try:
            with open(path, "r", encoding="utf-8") as fh:
                payload = json.load(fh)
            if not isinstance(payload, dict):
                raise ValueError("Invalid alerts state")
        except Exception:
            payload = _alerts_blank_state()
    else:
        payload = _alerts_blank_state()
    payload.setdefault("events", {})
    payload.setdefault("regions", {})
    payload.setdefault("last_fetch", None)
    payload.setdefault("_timeline_day", alerts_today_key())
    timeline_day = payload.get("_timeline_day") or alerts_today_key()
    payload[ALERTS_TIMELINE_KEY] = _alerts_load_timeline(resolved, timeline_day)
    _alerts_refresh_timeline_day(payload, resolved)
    payload["_context_project"] = resolved
    _alerts_state_cache[key] = payload
    return payload


def _alerts_save_state(project: Optional[str] = None) -> None:
    def _write(target_key: str, payload: Dict[str, Any]) -> None:
        if payload is None:
            return
        resolved = None if target_key == "__global__" else target_key
        _alerts_refresh_timeline_day(payload, resolved)
        _alerts_ensure_storage(resolved)
        _alerts_write_state_payload(resolved, payload)

    if project is None:
        for key, payload in list(_alerts_state_cache.items()):
            if payload is not None:
                _write(key, payload)
        return
    key = _alerts_context_key(project)
    payload = _alerts_state_cache.get(key)
    if payload is None:
        return
    _write(key, payload)


def _alerts_blank_user_state() -> Dict[str, Any]:
    return {}


def _alerts_load_users(project: Optional[str] = None) -> Dict[str, Any]:
    key = _alerts_context_key(project)
    cached = _alerts_user_cache.get(key)
    if cached is not None:
        return cached
    resolved = _alerts_resolve_project(project)
    _alerts_ensure_storage(resolved)
    path = alerts_users_file(resolved)
    if not os.path.exists(path):
        payload = _alerts_blank_user_state()
        _alerts_user_cache[key] = payload
        _alerts_save_users(project)
        return payload
    try:
        with open(path, "r", encoding="utf-8") as fh:
            payload = json.load(fh)
        if not isinstance(payload, dict):
            raise ValueError("Invalid alerts user state")
    except Exception:
        payload = _alerts_blank_user_state()
    _alerts_user_cache[key] = payload
    return payload


def _alerts_save_users(project: Optional[str] = None) -> None:
    def _write(target_key: str, payload: Dict[str, Any]) -> None:
        resolved = None if target_key == "__global__" else target_key
        _alerts_ensure_storage(resolved)
        path = alerts_users_file(resolved)
        tmp_file = f"{path}.tmp"
        with open(tmp_file, "w", encoding="utf-8") as fh:
            json.dump(payload, fh, ensure_ascii=False, indent=2)
        os.replace(tmp_file, path)

    if project is None:
        for key, payload in list(_alerts_user_cache.items()):
            if payload is not None:
                _write(key, payload)
        return
    key = _alerts_context_key(project)
    payload = _alerts_user_cache.get(key)
    if payload is None:
        return
    _write(key, payload)


def _alerts_user_entry(uid: int, project: Optional[str] = None) -> Dict[str, Any]:
    store = _alerts_load_users(project)
    key = str(uid)
    created = key not in store
    entry = store.setdefault(key, {"regions": [], "last_seen": {}})
    if not isinstance(entry.get("regions"), list):
        entry["regions"] = []
    if not isinstance(entry.get("last_seen"), dict):
        entry["last_seen"] = {}
    if created:
        _alerts_save_users(project)
    return entry


def _alerts_region_state(region: str) -> Dict[str, Any]:
    state = _alerts_load_state()
    bucket = state.setdefault("regions", {}).setdefault(region, {})
    bucket.setdefault("active", [])
    bucket.setdefault("history", [])
    return bucket


def alerts_canonical_region(name: Optional[str]) -> Optional[str]:
    if not name:
        return None
    cleaned = str(name).strip()
    if not cleaned:
        return None
    lower = cleaned.lower()
    for canonical, aliases in ALERTS_REGION_EQUIVALENTS.items():
        if lower == canonical.lower():
            return canonical
        for alias in aliases:
            if lower == alias.lower():
                return canonical
    return cleaned


def alerts_region_storage_keys(*candidates: Optional[str]) -> Set[str]:
    keys: Set[str] = set()
    for candidate in candidates:
        if not candidate:
            continue
        cleaned = str(candidate).strip()
        if not cleaned:
            continue
        keys.add(cleaned)
        canonical = alerts_canonical_region(cleaned)
        if canonical:
            keys.add(canonical)
    return keys


def alerts_sanitize_notes(notes: Any) -> List[Dict[str, str]]:
    sanitized: List[Dict[str, str]] = []
    if isinstance(notes, list):
        for entry in notes:
            if isinstance(entry, dict):
                note_type = str(entry.get("type") or "").strip()
                title = str(entry.get("title") or "").strip()
                text = str(entry.get("text") or entry.get("value") or entry.get("note") or "").strip()
                cleaned: Dict[str, str] = {}
                if note_type:
                    cleaned["type"] = note_type
                if title:
                    cleaned["title"] = title
                if text:
                    cleaned["text"] = text
                if cleaned:
                    sanitized.append(cleaned)
            elif isinstance(entry, str):
                text = entry.strip()
                if text:
                    sanitized.append({"text": text})
    return sanitized


def alerts_extract_note_fields(payload: Dict[str, Any]) -> Tuple[str, str, str, str, str]:
    severity_raw = ""
    cause = ""
    details_parts: List[str] = []
    message = ""
    source = ""

    for note in alerts_sanitize_notes(payload.get("notes")):
        text = str(note.get("text") or "").strip()
        if not text:
            continue
        note_type = str(note.get("type") or "").lower()
        title_lower = str(note.get("title") or "").lower()

        def matches(keyword: str) -> bool:
            return keyword in note_type or keyword in title_lower

        if not severity_raw and (matches("severity") or matches("level") or matches("—Ä—ñ–≤") or matches("—Å—Ç–∞—Ç—É—Å")):
            severity_raw = text
            continue
        if not cause and (matches("cause") or matches("reason") or matches("–ø—Ä–∏—á")):
            cause = text
            continue
        if not source and (matches("source") or matches("issuer") or matches("–¥–∂–µ—Ä–µ–ª")):
            source = text
            continue
        if not message and (matches("message") or matches("status") or matches("–æ–ø–∏—Å") or matches("–ø–æ–≤—ñ–¥–æ–º") or note_type in ("message", "status")):
            message = text
            continue
        if matches("detail") or matches("–¥–µ—Ç–∞–ª") or matches("info") or note_type in ("details", "description"):
            details_parts.append(text)
            continue
        if not message:
            message = text
        else:
            details_parts.append(text)

    details = " ‚Ä¢ ".join(part for part in details_parts if part)
    return severity_raw, cause, details, message, source


def alerts_normalize_type_code(raw_type: str) -> str:
    base = (raw_type or "").strip().lower()
    if not base:
        return "unknown"
    mapped = ALERTS_TYPE_ALIASES.get(base, base)
    if mapped not in ALERTS_TYPE_LABELS:
        return "unknown"
    return mapped


def alerts_normalize_severity(raw_severity: Optional[str], type_code: str) -> str:
    candidate = str(raw_severity or "").strip()
    lowered = candidate.lower()
    if lowered:
        for keyword, mapped in ALERTS_SEVERITY_KEYWORDS.items():
            if keyword in lowered:
                return mapped
        numeric_map = {"4": "critical", "3": "high", "2": "medium", "1": "low", "0": "low"}
        roman_map = {"iv": "critical", "iii": "high", "ii": "medium", "i": "low"}
        if lowered in numeric_map:
            return numeric_map[lowered]
        if lowered in roman_map:
            return roman_map[lowered]
    return ""


def alerts_normalize_event(raw: Dict[str, Any]) -> Optional[Dict[str, Any]]:
    if not isinstance(raw, dict):
        return None
    payload = dict(raw)
    event_id = payload.get("id") or payload.get("alert_id") or ""
    if not event_id:
        region_hint = str(
            payload.get("location_oblast")
            or payload.get("region")
            or payload.get("area")
            or payload.get("location_title")
            or ""
        ).strip()
        started_hint = str(payload.get("started_at") or payload.get("start") or payload.get("timestamp") or "")
        event_id = f"{region_hint}|{payload.get('alert_type') or payload.get('type') or 'alert'}|{started_hint}"
    event_id = str(event_id)

    raw_type = str(payload.get("alert_type") or payload.get("type") or "").strip()
    type_code = alerts_normalize_type_code(raw_type)

    oblast_title = str(payload.get("location_oblast") or payload.get("region") or payload.get("area") or "").strip()
    location_title = str(payload.get("location_title") or payload.get("location") or payload.get("city") or "").strip()
    if not oblast_title and location_title:
        oblast_title = location_title
    region_original = oblast_title or location_title or str(payload.get("region") or payload.get("area") or "").strip()
    region_canonical = alerts_canonical_region(region_original)

    started_at = payload.get("started_at") or payload.get("start") or payload.get("timestamp") or ""
    ended_at = payload.get("finished_at") or payload.get("ended_at") or payload.get("end") or ""
    updated_at = payload.get("updated_at") or payload.get("last_updated_at") or datetime.now(timezone.utc).isoformat()

    severity_note, cause, details, message_note, source_note = alerts_extract_note_fields(payload)
    message = str(payload.get("message") or payload.get("text") or message_note or cause or details or "").strip()
    source = str(payload.get("source") or payload.get("issuer") or source_note or "alerts.in.ua").strip()

    severity_code = alerts_normalize_severity(payload.get("severity") or severity_note, type_code)

    notes_clean = alerts_sanitize_notes(payload.get("notes"))
    extra_payload = {
        "severity": severity_code,
        "cause": cause,
        "details": details,
        "severity_note": severity_note,
        "type_raw": raw_type,
        "oblast_uid": payload.get("location_oblast_uid") or payload.get("oblast_uid"),
        "oblast_title": oblast_title or region_original,
        "notes": notes_clean,
    }

    clean_extra: Dict[str, Any] = {}
    for key, value in extra_payload.items():
        if key == "notes":
            if value:
                clean_extra[key] = value
            continue
        if isinstance(value, str):
            value = value.strip()
        if value in (None, "", []):
            continue
        clean_extra[key] = value
    if severity_code:
        clean_extra.setdefault("severity", severity_code)

    return {
        "id": event_id,
        "type": type_code or "unknown",
        "type_raw": raw_type or "unknown",
        "region": region_canonical or region_original,
        "region_display": region_original or region_canonical or "",
        "started_at": str(started_at) if started_at else "",
        "ended_at": str(ended_at) if ended_at else "",
        "message": message,
        "source": source or "alerts.in.ua",
        "extra": clean_extra,
        "updated_at": str(updated_at) if updated_at else datetime.now(timezone.utc).isoformat(),
    }


def _alerts_user_agent() -> str:
    base = "Bot.BSG-alerts/1.0 (+https://alerts.in.ua)"
    token = ALERTS_API_TOKEN or ""
    if len(token) >= 5:
        return f"{base} token:{token[:5]}"
    return base


def _alerts_request_headers() -> Dict[str, str]:
    if not ALERTS_API_TOKEN:
        return {}
    return {
        "Authorization": f"Bearer {ALERTS_API_TOKEN}",
        "X-API-Key": ALERTS_API_TOKEN,
        "Accept": "application/json",
        "Accept-Language": "uk-UA",
        "User-Agent": _alerts_user_agent(),
    }


def _alerts_api_get(endpoint: str, params: Optional[Dict[str, Any]] = None) -> Tuple[bool, str, Any]:
    if not ALERTS_API_TOKEN:
        return False, "API token is empty", None
    endpoint = endpoint if endpoint.startswith("/") else f"/{endpoint}"
    url = f"{ALERTS_API_BASE_URL}{endpoint}"
    headers = _alerts_request_headers()
    try:
        response = requests.get(url, headers=headers, params=params, timeout=ALERTS_API_TIMEOUT)
    except requests.RequestException as exc:
        return False, str(exc), None
    try:
        response.raise_for_status()
    except requests.RequestException as exc:
        return False, str(exc), None
    if response.status_code == 204:
        return True, "", {}
    try:
        data = response.json()
    except ValueError:
        return False, "–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –æ—Ç–≤–µ—Ç —Ç—Ä–µ–≤–æ–≥", None
    return True, "", data


def alerts_fetch_remote() -> Tuple[bool, str, List[Dict[str, Any]]]:
    ok, error, data = _alerts_api_get(ALERTS_API_ACTIVE_ENDPOINT)
    if not ok:
        return False, f"–ó–∞–ø—Ä–æ—Å —Ç—Ä–µ–≤–æ–≥ –Ω–µ —É–¥–∞–ª—Å—è: {error}", []
    if not isinstance(data, dict):
        return True, "", []
    items = data.get("alerts")
    if not isinstance(items, list):
        items = data.get("data") if isinstance(data.get("data"), list) else []
    events: List[Dict[str, Any]] = []
    for item in items:
        normalized = alerts_normalize_event(item)
        if normalized:
            events.append(normalized)
    return True, "", events


def alerts_fetch_history_by_oblast(oblast_uid: Union[int, str], period: str = ALERTS_DEFAULT_HISTORY_PERIOD) -> Tuple[bool, str, List[Dict[str, Any]]]:
    if not oblast_uid:
        return False, "–ü–æ—Ä–æ–∂–Ω—ñ–π —ñ–¥–µ–Ω—Ç–∏—Ñ—ñ–∫–∞—Ç–æ—Ä –æ–±–ª–∞—Å—Ç—ñ", []
    endpoint = ALERTS_API_HISTORY_TEMPLATE.format(uid=oblast_uid, period=period or ALERTS_DEFAULT_HISTORY_PERIOD)
    ok, error, data = _alerts_api_get(endpoint)
    if not ok:
        return False, error, []
    if isinstance(data, dict):
        items = data.get("alerts") or data.get("data") or []
    else:
        items = data if isinstance(data, list) else []
    events: List[Dict[str, Any]] = []
    for item in items:
        normalized = alerts_normalize_event(item)
        if normalized:
            events.append(normalized)
    return True, "", events


def alerts_history_events(oblast_uid: Union[int, str]) -> Tuple[bool, str, List[Dict[str, Any]]]:
    key = str(oblast_uid)
    now = datetime.now(timezone.utc)
    cached = alerts_history_cache.get(key)
    if cached:
        fetched_at = cached.get("fetched_at")
        if isinstance(fetched_at, datetime) and (now - fetched_at).total_seconds() < ALERTS_HISTORY_CACHE_TTL:
            return True, "", cached.get("events", [])
    ok, error, events = alerts_fetch_history_by_oblast(oblast_uid)
    if ok:
        alerts_history_cache[key] = {"fetched_at": now, "events": events}
    return ok, error, events


def alerts_merge_extra(base: Optional[Dict[str, Any]], update: Optional[Dict[str, Any]]) -> Dict[str, Any]:
    merged: Dict[str, Any] = dict(base or {})
    for key, value in (update or {}).items():
        if key == "notes":
            if value:
                merged[key] = value
            continue
        if isinstance(value, str):
            value = value.strip()
        if value in (None, "", []):
            continue
        merged[key] = value
    return merged


def alerts_enrich_from_history(event: Dict[str, Any]) -> Optional[Dict[str, Any]]:
    extra = event.get("extra") or {}
    oblast_uid = extra.get("oblast_uid")
    if not oblast_uid:
        return None
    ok, error, history_events = alerts_history_events(oblast_uid)
    if not ok:
        if error:
            print(f"[alerts] history fetch failed for oblast {oblast_uid}: {error}")
        return None
    event_id = str(event.get("id"))
    for hist_event in history_events:
        if str(hist_event.get("id")) != event_id:
            continue
        merged_extra = alerts_merge_extra(event.get("extra"), hist_event.get("extra"))
        return {
            "ended_at": hist_event.get("ended_at") or event.get("ended_at"),
            "message": hist_event.get("message") or event.get("message"),
            "source": hist_event.get("source") or event.get("source"),
            "extra": merged_extra,
            "region": hist_event.get("region") or event.get("region"),
            "region_display": hist_event.get("region_display") or event.get("region_display"),
            "started_at": hist_event.get("started_at") or event.get("started_at"),
            "updated_at": hist_event.get("updated_at") or event.get("updated_at"),
        }
    return None


def alerts_refresh_once() -> Tuple[List[str], List[str]]:
    ok, error, events = alerts_fetch_remote()
    if not ok:
        print(f"[alerts] {error}")
        return [], []
    state = _alerts_load_state()
    events_map = state.setdefault("events", {})
    regions_map = state.setdefault("regions", {})

    previous_active_ids: Set[str] = {str(eid) for eid, payload in events_map.items() if not payload.get("ended_at")}
    start_notify: List[str] = []
    end_notify: List[str] = []
    seen_ids: Set[str] = set()

    for event in events:
        event_id = str(event["id"])
        seen_ids.add(event_id)
        stored = events_map.get(event_id)
        ended_now = bool(event.get("ended_at"))
        if stored:
            previously_ended = bool(stored.get("ended_at"))
            merged_extra = alerts_merge_extra(stored.get("extra"), event.get("extra"))
            stored.update(event)
            if merged_extra:
                stored["extra"] = merged_extra
            if not previously_ended and ended_now:
                stored.setdefault("notified_end", False)
                if event_id not in end_notify:
                    end_notify.append(event_id)
        else:
            event["notified_start"] = bool(ended_now)
            event["notified_end"] = False
            events_map[event_id] = event
            if ended_now:
                if event_id not in end_notify:
                    end_notify.append(event_id)
            else:
                if event_id not in start_notify:
                    start_notify.append(event_id)

        region_keys = alerts_region_storage_keys(event.get("region"), event.get("region_display"))
        if not region_keys:
            region_keys = {""}
        for region_key in region_keys:
            bucket = regions_map.setdefault(region_key, {"active": [], "history": []})
            history = bucket.setdefault("history", [])
            active = bucket.setdefault("active", [])
            if event_id not in history:
                history.insert(0, event_id)
            if ended_now:
                if event_id in active:
                    active.remove(event_id)
            else:
                if event_id not in active:
                    active.append(event_id)

    missing_active = previous_active_ids - seen_ids
    if missing_active:
        now_iso = datetime.now(timezone.utc).isoformat()
        for event_id in list(missing_active):
            stored = events_map.get(event_id)
            if not stored or stored.get("ended_at"):
                continue
            enriched = alerts_enrich_from_history(stored)
            if enriched:
                merged_extra = alerts_merge_extra(stored.get("extra"), enriched.get("extra"))
                stored.update({k: v for k, v in enriched.items() if k != "extra"})
                if merged_extra:
                    stored["extra"] = merged_extra
            else:
                stored["ended_at"] = now_iso
            stored.setdefault("notified_end", False)
            if event_id not in end_notify:
                end_notify.append(event_id)
            region_keys = alerts_region_storage_keys(stored.get("region"), stored.get("region_display")) or {""}
            for region_key in region_keys:
                bucket = regions_map.setdefault(region_key, {"active": [], "history": []})
                active = bucket.setdefault("active", [])
                if event_id in active:
                    active.remove(event_id)

    for region_key, bucket in regions_map.items():
        active = bucket.get("active", [])
        bucket["active"] = [eid for eid in active if not events_map.get(eid, {}).get("ended_at")]

    alerts_record_timeline(state, start_notify, "start")
    alerts_record_timeline(state, end_notify, "end")
    state["last_fetch"] = datetime.now(timezone.utc).isoformat()
    _alerts_save_state()
    return start_notify, end_notify


def _alerts_get_event(event_id: str) -> Optional[Dict[str, Any]]:
    state = _alerts_load_state()
    payload = state.get("events", {}).get(event_id)
    if payload:
        return dict(payload)
    return None


def _alerts_mark_notified(event_id: str, kind: str) -> None:
    state = _alerts_load_state()
    payload = state.get("events", {}).get(event_id)
    if not payload:
        return
    if kind == "start":
        payload["notified_start"] = True
    elif kind == "end":
        payload["notified_end"] = True
    _alerts_save_state()


def _alerts_timeline_bucket(state: Dict[str, Any]) -> List[Dict[str, Any]]:
    timeline = state.setdefault(ALERTS_TIMELINE_KEY, [])
    if isinstance(timeline, list):
        return timeline
    timeline = []
    state[ALERTS_TIMELINE_KEY] = timeline
    return timeline


def alerts_record_timeline(state: Dict[str, Any], event_ids: List[str], kind: str) -> None:
    if not event_ids:
        return
    _alerts_refresh_timeline_day(state, state.get("_context_project"))
    events_map = state.get("events", {})
    timeline = _alerts_timeline_bucket(state)
    recorded_at = alerts_now().isoformat()
    for event_id in event_ids:
        event = events_map.get(event_id)
        if not event:
            continue
        started_at = event.get("started_at")
        ended_at = event.get("ended_at")
        if kind == "start" and not started_at:
            started_at = recorded_at
            event["started_at"] = started_at
        if kind == "end":
            if not started_at:
                started_at = recorded_at
                event.setdefault("started_at", started_at)
            if not ended_at:
                ended_at = recorded_at
                event["ended_at"] = ended_at
        canonical = alerts_canonical_region(event.get("region") or event.get("region_display"))
        region_value = canonical or event.get("region") or event.get("region_display") or ""
        extra = event.get("extra") or {}
        entry = {
            "event_id": event_id,
            "kind": kind,
            "region": region_value,
            "type": event.get("type") or "",
            "severity": extra.get("severity") or "",
            "started_at": started_at,
            "ended_at": ended_at,
            "cause": extra.get("cause") or "",
            "details": extra.get("details") or "",
            "message": event.get("message") or "",
            "recorded_at": recorded_at,
        }
        timeline.append(entry)


def alerts_parse_datetime(value: Optional[str]) -> Optional[datetime]:
    if not value:
        return None
    raw = str(value).strip()
    if not raw:
        return None
    if raw.endswith("Z"):
        raw = raw[:-1] + "+00:00"
    try:
        dt = datetime.fromisoformat(raw)
    except ValueError:
        for fmt in ("%Y-%m-%d %H:%M:%S", "%Y-%m-%d %H:%M"):
            try:
                dt = datetime.strptime(raw, fmt)
                dt = dt.replace(tzinfo=timezone.utc)
                break
            except ValueError:
                continue
        else:
            return None
    if dt.tzinfo is None:
        dt = dt.replace(tzinfo=timezone.utc)
    try:
        return dt.astimezone(ALERTS_TIMEZONE)
    except Exception:
        return dt


def alerts_now() -> datetime:
    try:
        tz = ALERTS_TIMEZONE  # type: ignore[name-defined]
    except Exception:
        tz = timezone.utc
    return datetime.now(tz)


def alerts_today_key() -> str:
    return alerts_now().strftime("%Y-%m-%d")


def alerts_format_timestamp(value: Optional[str]) -> str:
    dt = alerts_parse_datetime(value)
    if not dt:
        return value or ""
    return dt.strftime("%Y-%m-%d %H:%M")


def alerts_format_datetime_display(value: Optional[str]) -> str:
    date, clock = alerts_format_push_date_pair(value)
    if date and clock:
        return f"{date} ‚Ä¢ {clock}"
    if date:
        return date
    if clock:
        return clock
    return ""


def alerts_format_clock(value: Optional[str]) -> str:
    dt = alerts_parse_datetime(value)
    if not dt:
        return ""
    return dt.strftime("%H:%M")


def alerts_type_icon(event: Dict[str, Any]) -> str:
    type_code = event.get("type") or ""
    return ALERTS_TYPE_ICONS.get(type_code, ALERTS_TYPE_ICONS["unknown"])


def alerts_select_form(value: int, forms: Tuple[str, ...]) -> str:
    if len(forms) == 2:
        return forms[0] if abs(value) == 1 else forms[1]
    n = abs(value) % 100
    if 11 <= n <= 14:
        return forms[2]
    n = abs(value) % 10
    if n == 1:
        return forms[0]
    if 2 <= n <= 4:
        return forms[1]
    return forms[2]


def alerts_unit_form(lang: str, unit: str, value: int) -> str:
    forms_map = ALERTS_DURATION_FORMS.get(lang) or ALERTS_DURATION_FORMS.get(DEFAULT_LANG) or {}
    forms = forms_map.get(unit)
    if not forms:
        # fallback to english plural rules
        forms = (unit, f"{unit}s")
    return alerts_select_form(value, forms)


def alerts_format_duration_value(seconds: int, lang: str) -> str:
    if seconds <= 0:
        return tr(lang, "ALERTS_DURATION_LESS_MINUTE")
    total_minutes = max(1, seconds // 60)
    hours = total_minutes // 60
    minutes = total_minutes % 60
    parts: List[str] = []
    if hours:
        unit = alerts_unit_form(lang, "hour", hours)
        parts.append(f"{hours} {unit}")
    if minutes:
        unit = alerts_unit_form(lang, "minute", minutes)
        parts.append(f"{minutes} {unit}")
    if not parts:
        unit = alerts_unit_form(lang, "minute", 1)
        parts.append(f"1 {unit}")
    return " ".join(parts)


def alerts_duration_seconds(start: Optional[str], end: Optional[str] = None) -> int:
    start_dt = alerts_parse_datetime(start)
    if not start_dt:
        return 0
    end_dt = alerts_parse_datetime(end) if end else alerts_now()
    if not end_dt:
        end_dt = alerts_now()
    delta = end_dt - start_dt
    return max(0, int(delta.total_seconds()))


def alerts_duration_phrase(start: Optional[str], end: Optional[str], lang: str, ongoing: bool) -> str:
    seconds = alerts_duration_seconds(start, end)
    value = alerts_format_duration_value(seconds, lang)
    key = "ALERTS_DURATION_RUNNING" if ongoing else "ALERTS_DURATION_COMPLETED"
    return tr(lang, key, duration=value)


def alerts_format_push_timestamp(value: Optional[str]) -> str:
    dt = alerts_parse_datetime(value)
    if not dt:
        return ""
    return dt.strftime("%d.%m.%Y %H:%M")


def alerts_format_push_date_pair(value: Optional[str]) -> Tuple[str, str]:
    dt = alerts_parse_datetime(value)
    if not dt:
        return "", ""
    return dt.strftime("%d.%m.%Y"), dt.strftime("%H:%M")


def alerts_country_count_label(count: int, lang: str) -> str:
    unit = alerts_unit_form(lang, "alarm", count)
    return f"{count} {unit}"


def alerts_region_active_value(count: int, lang: str) -> str:
    if count <= 0:
        return ""
    if lang == "uk":
        return f"–∞–∫—Ç–∏–≤–Ω–∞ {count}" if count == 1 else f"–∞–∫—Ç–∏–≤–Ω—ñ {count}"
    if lang == "ru":
        return f"–∞–∫—Ç–∏–≤–Ω–∞ {count}" if count == 1 else f"–∞–∫—Ç–∏–≤–Ω—ã {count}"
    if lang == "pl":
        return f"aktywna {count}" if count == 1 else f"aktywne {count}"
    if lang == "de":
        return f"aktiv {count}"
    return f"active {count}"


def alerts_recommendation_block(event: Dict[str, Any], lang: str) -> str:
    mapping = ALERTS_RECOMMENDATIONS.get(event.get("type"))
    if not mapping:
        mapping = ALERTS_RECOMMENDATIONS.get("default", {})
    lines = mapping.get(lang) or mapping.get(DEFAULT_LANG) or []
    return "\n".join(lines)


def alerts_type_label(event: Dict[str, Any], lang: str) -> str:
    mapping = ALERTS_TYPE_LABELS.get(event.get("type")) or ALERTS_TYPE_LABELS.get("unknown")
    return mapping.get(lang) or mapping.get(DEFAULT_LANG) or event.get("type") or "Alert"


def alerts_severity_label(event: Dict[str, Any], lang: str) -> str:
    severity = (event.get("extra") or {}).get("severity") or ""
    if not severity:
        return ""
    mapping = ALERTS_SEVERITY_LABELS.get(severity)
    if not mapping:
        return severity.capitalize()
    icon = mapping.get("icon", "")
    text = mapping.get(lang) or mapping.get(DEFAULT_LANG) or severity
    return f"{icon} {text}" if icon else text


def alerts_field_labels(lang: str) -> Dict[str, str]:
    return ALERTS_FIELD_LABELS.get(lang) or ALERTS_FIELD_LABELS[DEFAULT_LANG]


def alerts_format_row(icon: str, label: str, value: str) -> List[str]:
    if not value:
        return []
    text = str(value)
    prefix = f"{icon} {label}: "
    indent = " " * len(prefix)
    rows = [prefix + text.splitlines()[0]]
    for part in text.splitlines()[1:]:
        rows.append(indent + part)
    return rows


def alerts_format_card(event: Dict[str, Any], lang: str, index: Optional[int] = None, total: Optional[int] = None) -> str:
    labels = alerts_field_labels(lang)
    status_labels = ALERTS_STATUS_TEXT.get(lang) or ALERTS_STATUS_TEXT[DEFAULT_LANG]
    ended = bool(event.get("ended_at"))
    region_display = alerts_display_region_name(event.get("region_display") or event.get("region") or "", lang)
    status_label = status_labels["standdown" if ended else "alert"].upper()
    header_icon = "üü¢" if ended else "üö®"
    lines: List[str] = [f"{header_icon} {status_label} ‚Äî {region_display}", "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"]
    type_label = alerts_type_label(event, lang)
    type_icon = alerts_type_icon(event)
    lines.extend(alerts_format_row(type_icon, labels["type"], type_label))
    severity_value = alerts_severity_label(event, lang)
    if severity_value:
        lines.extend(alerts_format_row("‚ö†Ô∏è", labels["severity"], severity_value))
    extra = event.get("extra") or {}
    cause = extra.get("cause") or ""
    lines.extend(alerts_format_row("üéØ", labels["cause"], cause))
    details = extra.get("details") or ""
    lines.extend(alerts_format_row("üîé", labels["details"], details))
    started_display = alerts_format_datetime_display(event.get("started_at")) or labels["status_unknown"]
    lines.extend(alerts_format_row("üïí", labels["started"], started_display))
    if ended:
        end_display = alerts_format_datetime_display(event.get("ended_at")) or labels["status_unknown"]
    else:
        end_display = labels["status_active"]
    lines.extend(alerts_format_row("‚úÖ", labels["ended"], end_display))
    duration_seconds = alerts_duration_seconds(event.get("started_at"), event.get("ended_at") if ended else None)
    duration_value = alerts_format_duration_value(duration_seconds, lang)
    lines.extend(alerts_format_row("‚è±Ô∏è", labels["duration"], duration_value))
    lines.extend(alerts_format_row("üì¢", labels["message"], event.get("message") or ""))
    if index is not None and total:
        lines.append("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ")
        lines.append(tr(lang, "ALERTS_CARD_INDEX", index=index + 1, total=total))
    return "\n".join(line for line in lines if line)


def alerts_profile_block(profile: dict) -> dict:
    uid = profile.get("user_id")
    if not uid:
        return {"regions": [], "last_seen": {}}
    entry = _alerts_user_entry(uid)
    legacy = profile.get("alerts")
    migrated = False
    if isinstance(legacy, dict):
        legacy_regions = legacy.get("regions", [])
        if isinstance(legacy_regions, list):
            for region in legacy_regions:
                canonical = alerts_canonical_region(region) or region
                if canonical and canonical not in entry["regions"]:
                    entry["regions"].append(canonical)
                    migrated = True
        legacy_seen = legacy.get("last_seen")
        if isinstance(legacy_seen, dict):
            entry["last_seen"].update({str(k): v for k, v in legacy_seen.items()})
            migrated = True
        if migrated:
            _alerts_save_users()
        profile.pop("alerts", None)
        try:
            save_user(profile)
        except Exception:
            pass
    return entry


def alerts_user_regions(uid: int) -> List[str]:
    regions: List[str] = []
    if active_project.get("name"):
        info = load_project_info(active_project["name"])
        project_region = info.get("region")
        canonical = alerts_canonical_region(project_region)
        if canonical:
            regions.append(canonical)
        elif project_region:
            regions.append(project_region)
    profile = load_user(uid) or {"user_id": uid}
    alerts = alerts_profile_block(profile)
    for region in alerts.get("regions", []):
        canonical = alerts_canonical_region(region)
        if canonical and canonical not in regions:
            regions.append(canonical)
        elif region not in regions:
            regions.append(region)
    return regions


def alerts_shorten_region_label(name: str, lang: str) -> str:
    text = str(name or "").strip()
    lowered = text.lower()
    suffix_map = [
        ("–æ–±–ª–∞—Å—Ç—å", "–æ–±–ª."),
        ("oblast", "obl."),
        ("region", "reg."),
        ("obw√≥d", "obw."),
        ("obwod", "obw."),
    ]
    for suffix, replacement in suffix_map:
        if lowered.endswith(suffix):
            base = text[: -len(suffix)].rstrip(" -")
            if not base:
                return text
            return f"{base} {replacement}".strip()
    return text


def alerts_display_region_name(region: str, lang: str, short: bool = False) -> str:
    canonical = alerts_canonical_region(region) or region
    aliases = ALERTS_REGION_EQUIVALENTS.get(canonical)
    if not aliases:
        result = canonical
    elif lang == "ru":
        result = canonical
    elif lang == "en":
        for alias in aliases:
            if re.search(r"[A-Za-z]", alias):
                result = alias
                break
        else:
            result = aliases[-1]
    else:
        result = aliases[0]
    if short:
        return alerts_shorten_region_label(result, lang)
    return result


def alerts_trim_region_suffix(name: str) -> str:
    text = str(name or "").strip()
    if not text:
        return ""
    lowered = text.lower()
    suffixes = (
        " –æ–±–ª–∞—Å—Ç—å",
        "–æ–±–ª–∞—Å—Ç—å",
        " –æ–±–ª.",
        " oblast",
        " region",
        " obw√≥d",
        " obwod",
        " obw.",
        " reg.",
    )
    for suffix in suffixes:
        suffix_clean = suffix.strip()
        if not suffix_clean:
            continue
        if lowered.endswith(suffix_clean):
            candidate = text[: -len(suffix_clean)].rstrip(" -‚Äì‚Äî,.;:")
            if candidate:
                return candidate
    return text


def alerts_overview_region_label(region: str, lang: str) -> str:
    canonical = alerts_canonical_region(region) or region
    mapping = ALERTS_REGION_SHORT_NAMES.get(canonical)
    if mapping:
        label = mapping.get(lang) or mapping.get(DEFAULT_LANG)
        if label:
            return label
    display = alerts_display_region_name(canonical, lang)
    trimmed = alerts_trim_region_suffix(display)
    return trimmed or display


def alerts_display_width(text: str) -> int:
    """Estimate visual column width for aligning overview rows."""
    if not text:
        return 0
    width = 0
    for char in str(text):
        if unicodedata.combining(char):
            continue
        if char in ("\u00A0", "\u202F", "\u2007"):
            width += 1
            continue
        east_asian = unicodedata.east_asian_width(char)
        if east_asian in ("F", "W"):
            width += 2
        else:
            width += 1
    return width


def alerts_regions_overview_text(uid: int) -> str:
    lang = resolve_lang(uid)
    status_labels = ALERTS_OVERVIEW_STATUS_TEXT.get(lang) or {}
    default_status_labels = ALERTS_OVERVIEW_STATUS_TEXT.get(DEFAULT_LANG) or {}

    def get_status_label(key: str) -> str:
        return status_labels.get(key) or default_status_labels.get(key) or ""

    header = tr(uid, "ALERTS_OVERVIEW_HEADER")
    entries: List[Dict[str, Any]] = []
    max_name_width = 0
    for index, raw_region in enumerate(UKRAINE_REGIONS, start=1):
        canonical, active_event, last_event = alerts_region_snapshot(raw_region)
        display_name = alerts_overview_region_label(canonical, lang)
        name_width = alerts_display_width(display_name)
        max_name_width = max(max_name_width, name_width)
        if active_event:
            status_text = get_status_label("alert")
            time_text = alerts_format_clock(active_event.get("started_at")) or "--:--"
            icon = "üî¥"
        else:
            icon = "üü¢"
            status_text = get_status_label("standdown") or get_status_label("calm")
            end_clock = ""
            if last_event and last_event.get("ended_at"):
                end_clock = alerts_format_clock(last_event.get("ended_at"))
            time_text = end_clock or "--:--"
        entries.append(
            {
                "index": index,
                "icon": icon,
                "name": display_name,
                "name_width": name_width,
                "status": status_text,
                "time": time_text,
            }
        )

    lines: List[str] = [h(header), ""]
    for entry in entries:
        stored_width = entry.get("name_width")
        if stored_width is None:
            stored_width = alerts_display_width(entry["name"])
        name_padding = max_name_width - stored_width
        padded_name = f"{entry['name']}{' ' * max(name_padding, 0)}"
        number = f"{entry['index']:2d}"
        status_text = h(entry["status"])
        time_text = h(entry["time"])
        lines.append(
            f"{number}. {entry['icon']} {h(padded_name)} ‚Äî {status_text} ‚Ä¢ {time_text}"
        )
        lines.append("")

    while len(lines) > 2 and lines[-1] == "":
        lines.pop()

    updated_clock = alerts_now().strftime("%H:%M")
    lines.append("")
    lines.append("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ")
    updated_line = tr(uid, "ALERTS_OVERVIEW_UPDATED").format(time=updated_clock)
    lines.append(h(updated_line))
    lines.append("")
    lines.append(h(tr(uid, "ALERTS_OVERVIEW_GUIDE")))
    body = "\n".join(lines)
    return f"<pre>{body}</pre>"


def alerts_collect_active_for_user(uid: int) -> List[Dict[str, Any]]:
    state = _alerts_load_state()
    events_map = state.get("events", {})
    lang = resolve_lang(uid)
    aggregated: Dict[str, Dict[str, Any]] = {}
    for region in alerts_user_regions(uid):
        bucket = state.get("regions", {}).get(region) or {}
        for event_id in bucket.get("active", []):
            event = events_map.get(event_id)
            if not event or event.get("ended_at"):
                continue
            canonical = alerts_canonical_region(event.get("region") or event.get("region_display") or region) or region
            stored = aggregated.get(canonical)
            started_at = event.get("started_at") or ""
            if not stored or (started_at > (stored.get("started_at") or "")):
                copy = dict(event)
                copy["region"] = canonical
                copy["region_display"] = alerts_display_region_name(canonical, lang)
                aggregated[canonical] = copy
    events = list(aggregated.values())
    events.sort(key=lambda item: alerts_display_region_name(item.get("region") or item.get("region_display") or "", lang))
    return events


def alerts_collect_history_for_user(uid: int, limit: int = 40) -> List[Dict[str, Any]]:
    state = _alerts_load_state()
    events_map = state.get("events", {})
    regions_selected = {alerts_canonical_region(r) or r for r in alerts_user_regions(uid)}
    seen: Set[str] = set()
    collected: List[Dict[str, Any]] = []
    timeline = list(_alerts_timeline_bucket(state))
    if timeline:
        for entry in reversed(timeline):
            event_id = str(entry.get("event_id") or "")
            if not event_id or event_id in seen:
                continue
            region_value = alerts_canonical_region(entry.get("region")) or entry.get("region") or ""
            if regions_selected and region_value and region_value not in regions_selected:
                continue
            event = events_map.get(event_id)
            if not event:
                continue
            copy = dict(event)
            if region_value:
                copy.setdefault("region", region_value)
            collected.append(copy)
            seen.add(event_id)
            if len(collected) >= limit:
                break
    if not collected:
        fallback_regions = alerts_user_regions(uid)
        for region in fallback_regions:
            canonical = alerts_canonical_region(region) or region
            bucket = state.get("regions", {}).get(canonical) or state.get("regions", {}).get(region) or {}
            for event_id in bucket.get("history", []):
                if event_id in seen:
                    continue
                event = events_map.get(event_id)
                if event:
                    collected.append(dict(event))
                    seen.add(event_id)
                if len(collected) >= limit:
                    break
            if len(collected) >= limit:
                break
    collected.sort(key=lambda item: item.get("started_at") or "", reverse=True)
    return collected[:limit]


def alerts_subscription_view(uid: int, page: int = 0) -> Tuple[str, InlineKeyboardMarkup]:
    profile = load_user(uid) or {}
    alerts = alerts_profile_block(profile)
    project_region = None
    if active_project.get("name"):
        info = load_project_info(active_project["name"])
        project_region = info.get("region") or ""
    canonical_project = alerts_canonical_region(project_region)
    selected = alerts_user_regions(uid)
    lang = resolve_lang(uid)
    lines = [tr(uid, "ALERTS_SUBS_HEADER"), tr(uid, "ALERTS_SUBS_DIVIDER")]
    if canonical_project:
        project_label = alerts_display_region_name(canonical_project, lang, short=False)
        lines.append(tr(uid, "ALERTS_SUBS_NOTE_HAS_PROJECT", region=h(project_label)))
    else:
        lines.append(tr(uid, "ALERTS_SUBS_NOTE_NO_PROJECT"))
    lines.append("")
    lines.append(tr(uid, "ALERTS_SUBS_LIST_TITLE"))
    if selected:
        labels = []
        for name in selected:
            full_label = alerts_display_region_name(name, lang, short=False)
            trimmed = alerts_trim_region_suffix(full_label)
            labels.append(h(trimmed or full_label))
        chunk_size = 4
        for idx in range(0, len(labels), chunk_size):
            lines.append(" ‚Ä¢ ".join(labels[idx:idx + chunk_size]))
    else:
        lines.append(tr(uid, "ALERTS_SUBS_LIST_EMPTY"))
    lines.append("")
    lines.append(tr(uid, "ALERTS_SUBS_DIVIDER"))
    lines.append(tr(uid, "ALERTS_SUBS_MANAGE"))
    kb = alerts_build_subscription_keyboard(uid, page, canonical_project, alerts)
    return "\n".join(lines), kb


def alerts_build_subscription_keyboard(uid: int, page: int, project_region: Optional[str], alerts: dict) -> InlineKeyboardMarkup:
    per_page = 6
    total = len(UKRAINE_REGIONS)
    total_pages = max(1, (total + per_page - 1) // per_page)
    page = max(0, min(page, total_pages - 1))
    start = page * per_page
    chunk = UKRAINE_REGIONS[start:start + per_page]
    selected = {alerts_canonical_region(x) or x for x in alerts.get("regions", [])}
    kb = InlineKeyboardMarkup(row_width=2)
    lang = resolve_lang(uid)
    for idx, region in enumerate(chunk):
        canonical = alerts_canonical_region(region) or region
        label_text = alerts_display_region_name(canonical, lang, short=True)
        if project_region and canonical == alerts_canonical_region(project_region):
            label = f"üîí {label_text}"
            callback = "alerts_locked"
        else:
            is_selected = canonical in selected
            prefix = "‚úÖ" if is_selected else "‚ûï"
            label = f"{prefix} {label_text}"
            callback = f"alerts_toggle:{page}:{start + idx}"
        kb.insert(InlineKeyboardButton(label, callback_data=callback))
    if total_pages > 1:
        nav: List[InlineKeyboardButton] = []
        if page > 0:
            nav.append(InlineKeyboardButton("‚óÄÔ∏è", callback_data=f"alerts_sub_page:{page - 1}"))
        nav.append(InlineKeyboardButton(tr(uid, "ALERTS_SUBS_PAGE", current=page + 1, total=total_pages), callback_data=f"alerts_sub_page:{page}"))
        if page < total_pages - 1:
            nav.append(InlineKeyboardButton("‚ñ∂Ô∏è", callback_data=f"alerts_sub_page:{page + 1}"))
        kb.row(*nav)
    kb.add(InlineKeyboardButton(tr(uid, "ALERTS_BACK_TO_MENU"), callback_data="menu_alerts"))
    kb.add(InlineKeyboardButton(tr(uid, "BTN_BACK_ROOT"), callback_data="back_root"))
    return kb


def alerts_update_subscription(uid: int, region_index: int, add: bool) -> bool:
    if region_index < 0 or region_index >= len(UKRAINE_REGIONS):
        return False
    region = alerts_canonical_region(UKRAINE_REGIONS[region_index]) or UKRAINE_REGIONS[region_index]
    profile = load_user(uid) or {"user_id": uid}
    alerts = alerts_profile_block(profile)
    items = alerts.setdefault("regions", [])
    changed = False
    if add:
        if region not in items:
            items.append(region)
            changed = True
    else:
        if region in items:
            items.remove(region)
            changed = True
    if changed:
        _alerts_save_users()
    return changed


def alerts_card_keyboard(uid: int, context: str, total: int, index: int) -> InlineKeyboardMarkup:
    kb = InlineKeyboardMarkup()
    if total > 1:
        row: List[InlineKeyboardButton] = []
        if index > 0:
            row.append(InlineKeyboardButton("‚óÄÔ∏è", callback_data=f"alerts_nav:{context}:{index - 1}"))
        row.append(
            InlineKeyboardButton(
                tr(uid, "ALERTS_CARD_INDEX", index=index + 1, total=total),
                callback_data=f"alerts_index:{context}:{index}",
            )
        )
        if index < total - 1:
            row.append(InlineKeyboardButton("‚ñ∂Ô∏è", callback_data=f"alerts_nav:{context}:{index + 1}"))
        kb.row(*row)
    kb.add(InlineKeyboardButton(tr(uid, "ALERTS_CLOSE_CARD"), callback_data=f"alerts_close:{context}"))
    kb.add(InlineKeyboardButton(tr(uid, "ALERTS_BACK_TO_MENU"), callback_data="menu_alerts"))
    return kb


def alerts_push_keyboard(uid: int, token: str, expanded: bool) -> InlineKeyboardMarkup:
    kb = InlineKeyboardMarkup(row_width=1)
    if expanded:
        kb.add(InlineKeyboardButton(tr(uid, "ALERTS_PUSH_COLLAPSE"), callback_data=f"alerts_push:collapse:{token}"))
    else:
        kb.add(InlineKeyboardButton(tr(uid, "ALERTS_PUSH_OPEN"), callback_data=f"alerts_push:expand:{token}"))
    kb.add(InlineKeyboardButton(tr(uid, "ALERTS_PUSH_DELETE"), callback_data=f"alerts_push:delete:{token}"))
    return kb


async def alerts_send_card(uid: int, chat_id: int, events: List[Dict[str, Any]], context: str, index: int = 0) -> Optional[types.Message]:
    if not events:
        return None
    runtime = users_runtime.setdefault(uid, {})
    cards = runtime.setdefault("alerts_cards", {})
    previous = cards.get(context, {}).get("message")
    if isinstance(previous, (list, tuple)) and len(previous) == 2:
        await _delete_message_safe(previous[0], previous[1])
    index = max(0, min(index, len(events) - 1))
    lang = resolve_lang(uid)
    text = alerts_format_card(events[index], lang, index=index, total=len(events))
    kb = alerts_card_keyboard(uid, context, len(events), index)
    msg = await bot.send_message(chat_id, text, reply_markup=kb, disable_web_page_preview=True)
    flow_track(uid, msg)
    cards[context] = {
        "events": [event["id"] for event in events],
        "index": index,
        "message": (msg.chat.id, msg.message_id),
    }
    return msg


def alerts_active_oblast_count() -> int:
    state = _alerts_load_state()
    events_map = state.get("events", {})
    oblasts: Set[str] = set()
    for payload in events_map.values():
        if not isinstance(payload, dict):
            continue
        if payload.get("ended_at"):
            continue
        region_name = payload.get("region") or payload.get("region_display") or ""
        canonical = alerts_canonical_region(region_name)
        normalized = (canonical or region_name or "").strip()
        if not normalized:
            continue
        lower = normalized.lower()
        if any(token in lower for token in ("–æ–±–ª–∞—Å—Ç", "oblast")):
            oblasts.add(normalized)
    return len(oblasts)


def alerts_active_summary_line(uid: int) -> str:
    count = alerts_active_oblast_count()
    return tr(uid, "ANCHOR_ALERT_SUMMARY", count=count)


def alerts_region_snapshot(region_key: str) -> Tuple[str, Optional[Dict[str, Any]], Optional[Dict[str, Any]]]:
    state = _alerts_load_state()
    events_map = state.get("events", {})
    regions_map = state.get("regions", {})
    canonical = alerts_canonical_region(region_key) or region_key
    bucket = regions_map.get(canonical) or regions_map.get(region_key) or {}
    active_event: Optional[Dict[str, Any]] = None
    for event_id in bucket.get("active", []):
        payload = events_map.get(event_id)
        if payload and not payload.get("ended_at"):
            if not active_event or (payload.get("started_at") or "") > (active_event.get("started_at") or ""):
                active_event = payload
    last_event: Optional[Dict[str, Any]] = None
    for event_id in bucket.get("history", []):
        payload = events_map.get(event_id)
        if payload:
            if not last_event or (payload.get("ended_at") or "") > (last_event.get("ended_at") or ""):
                last_event = payload
    if not last_event or not last_event.get("ended_at"):
        timeline = list(_alerts_timeline_bucket(state))
        if timeline:
            for entry in reversed(timeline):
                region_value = alerts_canonical_region(entry.get("region")) or entry.get("region") or ""
                if (region_value or "") != canonical:
                    continue
                if entry.get("kind") != "end":
                    continue
                event_id = str(entry.get("event_id") or "")
                payload = dict(events_map.get(event_id) or {})
                if not payload:
                    payload = {"id": event_id or f"timeline|{canonical}|{entry.get('recorded_at') or ''}"}
                payload.setdefault("region", canonical)
                payload.setdefault("region_display", entry.get("region") or canonical)
                if entry.get("started_at") and not payload.get("started_at"):
                    payload["started_at"] = entry["started_at"]
                end_value = entry.get("ended_at") or entry.get("recorded_at")
                if end_value:
                    payload["ended_at"] = end_value
                last_event = payload
                break
    return canonical, active_event, last_event


def alerts_region_active_total(region_key: str) -> int:
    state = _alerts_load_state()
    events_map = state.get("events", {})
    regions_map = state.get("regions", {})
    canonical = alerts_canonical_region(region_key) or region_key
    bucket = regions_map.get(canonical) or {}
    count = 0
    for event_id in bucket.get("active", []):
        payload = events_map.get(event_id)
        if payload and not payload.get("ended_at"):
            count += 1
    return count


def alerts_anchor_region_block(uid: int, region_key: str) -> Optional[str]:
    lang = resolve_lang(uid)
    canonical, active_event, last_event = alerts_region_snapshot(region_key)
    display_region = alerts_display_region_name(canonical, lang)
    status_labels = ALERTS_STATUS_TEXT.get(lang) or ALERTS_STATUS_TEXT[DEFAULT_LANG]
    if active_event:
        type_text = alerts_type_label(active_event, lang)
        severity_text = alerts_severity_label(active_event, lang)
        start_clock = alerts_format_clock(active_event.get("started_at"))
        extra = active_event.get("extra") or {}
        cause_text = extra.get("cause") or ""
        details: List[str] = []
        if type_text:
            details.append(type_text)
        if cause_text:
            details.append(cause_text)
        if severity_text:
            details.append(severity_text)
        if start_clock:
            details.append(start_clock)
        line = f"üî¥ <b>{h(display_region)}</b> ‚Äî {h(status_labels['alert'])}"
        if details:
            line += " ‚Ä¢ " + " ‚Ä¢ ".join(h(part) for part in details if part)
        return line
    if last_event and last_event.get("ended_at"):
        ended_dt = alerts_parse_datetime(last_event.get("ended_at"))
        now_dt = alerts_now()
        if ended_dt and (now_dt - ended_dt) <= timedelta(seconds=ALERTS_STANDDOWN_DISPLAY_WINDOW):
            type_text = alerts_type_label(last_event, lang)
            severity_text = alerts_severity_label(last_event, lang)
            start_clock = alerts_format_clock(last_event.get("started_at"))
            end_clock = alerts_format_clock(last_event.get("ended_at"))
            extra = last_event.get("extra") or {}
            cause_text = extra.get("cause") or ""
            details: List[str] = []
            if type_text:
                details.append(type_text)
            if cause_text:
                details.append(cause_text)
            if severity_text:
                details.append(severity_text)
            time_segment = ""
            if start_clock and end_clock:
                time_segment = f"{start_clock} ‚Üí {end_clock}"
            elif start_clock:
                time_segment = start_clock
            elif end_clock:
                time_segment = end_clock
            if time_segment:
                details.append(time_segment)
            line = f"üü° <b>{h(display_region)}</b> ‚Äî {h(status_labels['standdown'])}"
            if details:
                line += " ‚Ä¢ " + " ‚Ä¢ ".join(h(part) for part in details if part)
            return line
    return ""


def alerts_anchor_section(uid: int) -> str:
    summary = alerts_active_summary_line(uid)
    regions: List[str] = []
    for region in alerts_user_regions(uid):
        canonical = alerts_canonical_region(region) or region
        if canonical and canonical not in regions:
            regions.append(canonical)
    lines: List[str] = [summary] if summary else []
    for region in regions:
        block = alerts_anchor_region_block(uid, region)
        if block:
            lines.append(block)
    if not lines:
        return ""
    head = lines[0]
    tail = lines[1:4]
    return "\n".join([head] + tail)


def alerts_recipients_for_event(event: Dict[str, Any]) -> List[Tuple[int, Dict[str, Any]]]:
    recipients: List[Tuple[int, Dict[str, Any]]] = []
    target_region = alerts_canonical_region(event.get("region") or event.get("region_display")) or event.get("region")
    if not target_region:
        return recipients
    for profile in load_all_users():
        uid = profile.get("user_id")
        if not uid:
            continue
        regions = alerts_user_regions(uid)
        canonical_regions = {alerts_canonical_region(r) or r for r in regions}
        if target_region not in canonical_regions:
            continue
        recipients.append((uid, profile))
    return recipients


def alerts_push_summary_text(uid: int, event: Dict[str, Any], kind: str) -> str:
    lang = resolve_lang(uid)
    ended = kind == "end" or bool(event.get("ended_at"))
    region_display = alerts_display_region_name(event.get("region_display") or event.get("region") or "", lang)
    header_key = "ALERTS_PUSH_HEADER_STANDDOWN" if ended else "ALERTS_PUSH_HEADER_ALERT"
    header = tr(uid, header_key, region=region_display)
    lead_key = "ALERTS_PUSH_SUMMARY_LEAD_STANDDOWN" if ended else "ALERTS_PUSH_SUMMARY_LEAD_ALERT"
    lead_line = tr(uid, lead_key)
    type_label = alerts_type_label(event, lang)
    type_icon = alerts_type_icon(event)
    start_display = alerts_format_push_timestamp(event.get("started_at")) or "--:--"
    if ended:
        end_source = event.get("ended_at") or event.get("updated_at")
        end_display = alerts_format_push_timestamp(end_source) or "‚Äî"
        body = tr(
            uid,
            "ALERTS_PUSH_SUMMARY_ENDED",
            icon=type_icon,
            type=type_label,
            start=start_display,
            ended=end_display,
        )
    else:
        progress = alerts_duration_phrase(event.get("started_at"), None, lang, True)
        body = tr(
            uid,
            "ALERTS_PUSH_SUMMARY_RUNNING",
            icon=type_icon,
            type=type_label,
            start=start_display,
            progress=progress,
        )
    lines: List[str] = []
    if ended and lead_line:
        lines.append(lead_line)
        lines.append("")
    lines.append(header)
    lines.append(body)
    return "\n".join(lines).strip()


def alerts_push_detail_text(uid: int, event: Dict[str, Any], kind: str) -> str:
    lang = resolve_lang(uid)
    ended = kind == "end" or bool(event.get("ended_at"))
    region_display = alerts_display_region_name(event.get("region_display") or event.get("region") or "", lang)
    title_key = "ALERTS_PUSH_DETAIL_TITLE_STANDDOWN" if ended else "ALERTS_PUSH_DETAIL_TITLE_ALERT"
    title = tr(uid, title_key, region=region_display)
    type_label = alerts_type_label(event, lang)
    type_icon = alerts_type_icon(event)
    start_date, start_time = alerts_format_push_date_pair(event.get("started_at"))
    end_source = event.get("ended_at") or event.get("updated_at")
    end_date, end_time = alerts_format_push_date_pair(end_source) if ended else ("", "")
    duration_seconds = alerts_duration_seconds(event.get("started_at"), end_source if ended else None)
    duration_value = alerts_format_duration_value(duration_seconds, lang)
    stats_country = alerts_country_count_label(alerts_active_oblast_count(), lang)
    region_key = alerts_canonical_region(event.get("region") or event.get("region_display") or "") or event.get("region") or ""
    region_active = alerts_region_active_total(region_key) if region_key else 0
    if region_active:
        value = alerts_region_active_value(region_active, lang)
        stats_region = tr(uid, "ALERTS_PUSH_DETAIL_STATS_REGION_ACTIVE", value=value)
    else:
        stats_region = tr(uid, "ALERTS_PUSH_DETAIL_STATS_REGION_CLEAR")
    recommendations = alerts_recommendation_block(event, lang)

    lines: List[str] = [
        title,
        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ",
        "",
        tr(uid, "ALERTS_PUSH_DETAIL_TYPE", icon=type_icon, value=type_label),
        "",
        tr(uid, "ALERTS_PUSH_DETAIL_START", date=start_date or "‚Äî", time=start_time or "--:--"),
    ]
    if ended:
        lines.append(tr(uid, "ALERTS_PUSH_DETAIL_END_STANDDOWN", date=end_date or "‚Äî", time=end_time or "--:--"))
    lines.append(tr(uid, "ALERTS_PUSH_DETAIL_DURATION", duration=duration_value))
    lines.extend(
        [
            "",
            "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ",
            tr(uid, "ALERTS_PUSH_DETAIL_STATS_HEADER"),
            tr(uid, "ALERTS_PUSH_DETAIL_STATS_COUNTRY", value=stats_country),
            stats_region,
        ]
    )
    if ended:
        lines.extend(
            [
                "",
                "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ",
                tr(uid, "ALERTS_PUSH_DETAIL_STANDDOWN_HEADER"),
                tr(uid, "ALERTS_PUSH_DETAIL_STANDDOWN_NOTE"),
            ]
        )
    else:
        lines.extend(
            [
                "",
                "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ",
                tr(uid, "ALERTS_PUSH_DETAIL_RECOMMENDATIONS_HEADER"),
            ]
        )
        if recommendations:
            lines.append(recommendations)
        lines.extend([
            "",
            "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ",
            tr(uid, "ALERTS_PUSH_DETAIL_FOOTER"),
        ])
    return "\n".join(lines)


def alerts_push_render(uid: int, event: Dict[str, Any], kind: str, expanded: bool = False) -> str:
    if expanded:
        return alerts_push_detail_text(uid, event, kind)
    return alerts_push_summary_text(uid, event, kind)


def alerts_push_store(uid: int, token: str, payload: Dict[str, Any]) -> None:
    runtime = users_runtime.setdefault(uid, {})
    registry = runtime.setdefault("alerts_pushes", {})
    registry[token] = payload


def alerts_push_get(uid: int, token: str) -> Optional[Dict[str, Any]]:
    runtime = users_runtime.get(uid, {})
    registry = runtime.get("alerts_pushes", {})
    entry = registry.get(token)
    if not isinstance(entry, dict):
        return None
    return entry


def alerts_push_remove(uid: int, token: str) -> Optional[Dict[str, Any]]:
    runtime = users_runtime.get(uid, {})
    registry = runtime.get("alerts_pushes")
    if isinstance(registry, dict):
        return registry.pop(token, None)
    return None


def alerts_notification_text(uid: int, event: Dict[str, Any], kind: str) -> str:
    return alerts_push_summary_text(uid, event, kind)


async def alerts_broadcast(event_id: str, kind: str) -> None:
    event = _alerts_get_event(event_id)
    if not event:
        return
    if kind == "start" and event.get("notified_start"):
        return
    if kind == "end" and event.get("notified_end"):
        return
    recipients = alerts_recipients_for_event(event)
    if not recipients:
        _alerts_mark_notified(event_id, kind)
        return
    for uid, profile in recipients:
        chat_id = users_runtime.get(uid, {}).get("tg", {}).get("chat_id")
        if not chat_id:
            chat_id = (profile.get("tg") or {}).get("chat_id")
        if not chat_id:
            continue
        try:
            text = alerts_push_summary_text(uid, event, kind)
            token = secrets.token_hex(4)
            while alerts_push_get(uid, token):
                token = secrets.token_hex(4)
            kb = alerts_push_keyboard(uid, token, expanded=False)
            message = await bot.send_message(chat_id, text, reply_markup=kb, disable_web_page_preview=True)
            alerts_push_store(
                uid,
                token,
                {
                    "event_id": event_id,
                    "kind": kind,
                    "message_id": message.message_id,
                    "chat_id": message.chat.id,
                    "expanded": False,
                },
            )
        except Exception:
            continue
    _alerts_mark_notified(event_id, kind)


async def alerts_dispatch_updates(start_ids: List[str], end_ids: List[str]) -> None:
    changed = False
    for event_id in start_ids:
        event = _alerts_get_event(event_id)
        if not event:
            continue
        await alerts_broadcast(event_id, "start")
        changed = True
    for event_id in end_ids:
        event = _alerts_get_event(event_id)
        if not event:
            continue
        await alerts_broadcast(event_id, "end")
        changed = True
    if changed:
        await update_all_anchors()


async def alerts_poll_loop() -> None:
    global alerts_poll_task
    try:
        await asyncio.sleep(ALERTS_POLL_INTERVAL)
        while True:
            try:
                start_ids, end_ids = await asyncio.to_thread(alerts_refresh_once)
            except asyncio.CancelledError:
                raise
            except Exception as exc:
                print(f"[alerts] refresh error: {exc}")
                start_ids, end_ids = [], []
            if start_ids or end_ids:
                await alerts_dispatch_updates(start_ids, end_ids)
            await asyncio.sleep(ALERTS_POLL_INTERVAL)
    except asyncio.CancelledError:
        pass
    finally:
        alerts_poll_task = None


async def alerts_bootstrap() -> None:
    try:
        start_ids, end_ids = await asyncio.to_thread(alerts_refresh_once)
    except Exception as exc:
        print(f"[alerts] initial refresh error: {exc}")
        await update_all_anchors()
        return
    if start_ids or end_ids:
        await alerts_dispatch_updates(start_ids, end_ids)
    else:
        await update_all_anchors()


async def alerts_start_polling() -> None:
    global alerts_poll_task
    if alerts_poll_task and not alerts_poll_task.done():
        return
    alerts_poll_task = asyncio.create_task(alerts_poll_loop())


# ========================== NOVA POSHTA STORAGE ==========================

NP_API_URL = "https://api.novaposhta.ua/v2.0/json/"
NOVA_POSHTA_API_KEY = "2b7d39d126d56e60cfc61d00cd0b452c"
NP_DATA_FILE = os.path.join("data", "nova_poshta.json")

_np_state_cache: Optional[Dict[str, Any]] = None


def _np_utcnow() -> str:
    return datetime.now(timezone.utc).isoformat()


def _np_ensure_storage() -> None:
    os.makedirs(os.path.dirname(NP_DATA_FILE), exist_ok=True)


def _np_blank_state() -> Dict[str, Any]:
    return {"users": {}, "assignments": {}}


def _np_load_state() -> Dict[str, Any]:
    global _np_state_cache
    if _np_state_cache is not None:
        return _np_state_cache
    _np_ensure_storage()
    if not os.path.exists(NP_DATA_FILE):
        _np_state_cache = _np_blank_state()
        _np_save_state()
        return _np_state_cache
    try:
        with open(NP_DATA_FILE, "r", encoding="utf-8") as fh:
            payload = json.load(fh)
        if not isinstance(payload, dict):
            raise ValueError("Invalid payload")
        payload.setdefault("users", {})
        payload.setdefault("assignments", {})
        _np_state_cache = payload
    except Exception:
        _np_state_cache = _np_blank_state()
        _np_save_state()
    return _np_state_cache


def _np_save_state() -> None:
    if _np_state_cache is None:
        return
    _np_ensure_storage()
    tmp_file = f"{NP_DATA_FILE}.tmp"
    with open(tmp_file, "w", encoding="utf-8") as fh:
        json.dump(_np_state_cache, fh, ensure_ascii=False, indent=2)
    os.replace(tmp_file, NP_DATA_FILE)


def _np_user_bucket(uid: int) -> Dict[str, Any]:
    state = _np_load_state()
    user = state["users"].setdefault(str(uid), {})
    user.setdefault("history", [])
    user.setdefault("bookmarks", {})
    user.setdefault("notes", {})
    user.setdefault("assigned", {})
    return user


def np_fetch_tracking(ttn: str) -> Tuple[bool, Optional[Dict[str, Any]], str]:
    number = (ttn or "").strip()
    if not number:
        return False, None, "–ü—É—Å—Ç–æ–π –Ω–æ–º–µ—Ä –¢–¢–ù"
    if not re.fullmatch(r"[0-9A-Za-z-]{5,40}", number):
        return False, None, "–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¢–¢–ù"

    payload = {
        "apiKey": NOVA_POSHTA_API_KEY,
        "modelName": "TrackingDocument",
        "calledMethod": "getStatusDocuments",
        "methodProperties": {
            "Documents": [{"DocumentNumber": number}],
        },
    }
    try:
        response = requests.post(NP_API_URL, json=payload, timeout=15)
        response.raise_for_status()
    except requests.RequestException as exc:
        return False, None, f"–û—à–∏–±–∫–∞ –∑–∞–ø—Ä–æ—Å–∞: {exc}"

    try:
        data = response.json()
    except ValueError:
        return False, None, "–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞–∑–æ–±—Ä–∞—Ç—å –æ—Ç–≤–µ—Ç API"

    docs = data.get("data") or []
    if docs:
        doc = docs[0]
        if isinstance(doc, dict):
            doc = dict(doc)
            doc.setdefault("Number", number)
            doc.setdefault("DocumentNumber", number)
            return True, doc, ""

    errors = data.get("errors") or data.get("message") or data.get("error")
    if isinstance(errors, list):
        msg = "; ".join(str(e) for e in errors if e)
    else:
        msg = str(errors or "–ù–æ–º–µ—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω")
    if not msg:
        msg = "–ù–æ–º–µ—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω"
    return False, None, msg


def np_remember_search(uid: int, ttn: str, status_payload: Optional[Dict[str, Any]]) -> None:
    user = _np_user_bucket(uid)
    status_payload = status_payload or {}
    history = [entry for entry in user["history"] if entry.get("ttn") != ttn]
    history.insert(0, {
        "ttn": ttn,
        "timestamp": _np_utcnow(),
        "status_payload": status_payload,
    })
    user["history"] = history[:25]
    _np_save_state()


def np_get_history(uid: int) -> List[Dict[str, Any]]:
    user = _np_user_bucket(uid)
    return list(user["history"])


def np_get_cached_status(uid: int, ttn: str) -> Optional[Dict[str, Any]]:
    user = _np_user_bucket(uid)
    for entry in user["history"]:
        if entry.get("ttn") == ttn:
            return entry.get("status_payload")
    bookmark = user["bookmarks"].get(ttn)
    if isinstance(bookmark, dict):
        return bookmark.get("status_payload")
    assignment = _np_load_state()["assignments"].get(ttn)
    if isinstance(assignment, dict) and (
        assignment.get("assigned_to") == uid or assignment.get("assigned_by") == uid
    ):
        return assignment.get("status_payload")
    return None


def _np_set_bookmark(uid: int, ttn: str, status_payload: Optional[Dict[str, Any]]) -> None:
    user = _np_user_bucket(uid)
    user["bookmarks"][ttn] = {
        "added_at": _np_utcnow(),
        "status_payload": status_payload or {},
    }
    _np_save_state()


def np_remove_bookmark(uid: int, ttn: str) -> None:
    user = _np_user_bucket(uid)
    user["bookmarks"].pop(ttn, None)
    _np_save_state()


def np_toggle_bookmark(uid: int, ttn: str, status_payload: Optional[Dict[str, Any]] = None) -> bool:
    user = _np_user_bucket(uid)
    if ttn in user["bookmarks"]:
        np_remove_bookmark(uid, ttn)
        return False
    if status_payload is None:
        status_payload = np_get_cached_status(uid, ttn) or {}
    _np_set_bookmark(uid, ttn, status_payload)
    return True


def np_list_bookmarks(uid: int) -> List[Tuple[str, Dict[str, Any]]]:
    user = _np_user_bucket(uid)
    items = []
    for ttn, payload in user["bookmarks"].items():
        entry = dict(payload)
        entry["ttn"] = ttn
        items.append((ttn, entry))
    items.sort(key=lambda x: x[1].get("added_at", ""), reverse=True)
    return items


def np_has_bookmark(uid: int, ttn: str) -> bool:
    return ttn in _np_user_bucket(uid)["bookmarks"]


def np_add_note(uid: int, ttn: str, text: str) -> Dict[str, Any]:
    user = _np_user_bucket(uid)
    bucket = user["notes"].setdefault(ttn, [])
    note = {
        "note_id": secrets.token_hex(6),
        "ttn": ttn,
        "text": text,
        "timestamp": _np_utcnow(),
    }
    bucket.insert(0, note)
    user["notes"][ttn] = bucket[:20]
    _np_save_state()
    return note


def np_list_notes(uid: int, ttn: Optional[str] = None) -> Dict[str, List[Dict[str, Any]]]:
    user = _np_user_bucket(uid)
    notes = user["notes"]
    if ttn is not None:
        return {ttn: list(notes.get(ttn, []))}
    return {key: list(value) for key, value in notes.items() if value}


def np_assign_parcel(admin_uid: int, target_uid: int, ttn: str,
                     status_payload: Optional[Dict[str, Any]], note: Optional[str] = None) -> Dict[str, Any]:
    state = _np_load_state()
    now = _np_utcnow()
    assignment = state["assignments"].get(ttn, {})
    assignment.update({
        "ttn": ttn,
        "assigned_to": target_uid,
        "assigned_by": admin_uid,
        "note": note or "",
        "created_at": assignment.get("created_at") or now,
        "updated_at": now,
        "status_payload": status_payload or assignment.get("status_payload") or {},
        "delivered_at": assignment.get("delivered_at"),
        "delivery_note": assignment.get("delivery_note", ""),
    })
    state["assignments"][ttn] = assignment
    user = _np_user_bucket(target_uid)
    user["assigned"][ttn] = {
        "assigned_at": assignment.get("created_at") or now,
        "assigned_by": admin_uid,
    }
    _np_save_state()
    return dict(assignment)


def np_get_assignment(ttn: str) -> Optional[Dict[str, Any]]:
    state = _np_load_state()
    assignment = state["assignments"].get(ttn)
    if assignment:
        return dict(assignment)
    return None


def np_list_assignments(uid: int) -> List[Dict[str, Any]]:
    state = _np_load_state()
    result: List[Dict[str, Any]] = []
    for ttn, assignment in state["assignments"].items():
        if assignment.get("assigned_to") == uid:
            entry = dict(assignment)
            entry["ttn"] = ttn
            result.append(entry)
    result.sort(key=lambda x: x.get("created_at", ""), reverse=True)
    return result


def np_list_admin_assignments(admin_uid: int) -> List[Dict[str, Any]]:
    state = _np_load_state()
    result: List[Dict[str, Any]] = []
    for ttn, assignment in state["assignments"].items():
        if assignment.get("assigned_by") == admin_uid:
            entry = dict(assignment)
            entry["ttn"] = ttn
            result.append(entry)
    result.sort(key=lambda x: x.get("created_at", ""), reverse=True)
    return result


def np_mark_assignment_received(uid: int, ttn: str, delivery_note: str = "") -> Optional[Dict[str, Any]]:
    state = _np_load_state()
    assignment = state["assignments"].get(ttn)
    if not assignment or assignment.get("assigned_to") != uid:
        return None
    assignment["delivered_at"] = _np_utcnow()
    assignment["delivery_note"] = delivery_note or ""
    assignment["updated_at"] = assignment["delivered_at"]
    user = _np_user_bucket(uid)
    bucket = user["assigned"].setdefault(ttn, {})
    bucket["delivered_at"] = assignment["delivered_at"]
    _np_save_state()
    return dict(assignment)


def np_refresh_assignment_status(ttn: str, status_payload: Optional[Dict[str, Any]]) -> None:
    state = _np_load_state()
    assignment = state["assignments"].get(ttn)
    if not assignment:
        return
    assignment["status_payload"] = status_payload or {}
    assignment["updated_at"] = _np_utcnow()
    _np_save_state()


# ========================== NOVA POSHTA ==========================

def _np_clean_ttn(raw: str) -> str:
    return re.sub(r"[^0-9A-Za-z-]", "", (raw or "").strip())


def _np_trim_label(text: str, limit: int = 48) -> str:
    text = (text or "").strip()
    if len(text) <= limit:
        return text
    return text[: max(1, limit - 1)] + "‚Ä¶"


@dp.callback_query_handler(lambda c: c.data == "menu_np")
async def menu_np(c: types.CallbackQuery):
    uid = c.from_user.id
    await clear_then_anchor(uid, tr(uid, "NP_MENU_TITLE"), kb_novaposhta(uid))
    await c.answer()


@dp.callback_query_handler(lambda c: c.data == "np_interface")
async def np_interface_menu(c: types.CallbackQuery):
    uid = c.from_user.id
    await clear_then_anchor(uid, tr(uid, "NP_INTERFACE_TEXT"), kb_novaposhta(uid))
    await c.answer()


@dp.callback_query_handler(lambda c: c.data == "np_search")
async def np_search_start(c: types.CallbackQuery, state: FSMContext):
    uid = c.from_user.id
    await flow_clear(uid)
    await state.set_state(NovaPoshtaFSM.waiting_ttn.state)
    prompt = await bot.send_message(c.message.chat.id, tr(uid, "NP_PROMPT_TTN"), reply_markup=kb_np_cancel(uid))
    flow_track(uid, prompt)
    await c.answer()


@dp.message_handler(state=NovaPoshtaFSM.waiting_ttn, content_types=ContentType.TEXT)
async def np_receive_ttn(m: types.Message, state: FSMContext):
    uid = m.from_user.id
    text = (m.text or "").strip()
    if not text:
        return
    if text.lower() in NP_CANCEL_WORDS:
        await state.finish()
        await flow_clear(uid)
        await anchor_show_text(uid, tr(uid, "NP_MENU_TITLE"), kb_novaposhta(uid))
        try:
            await bot.delete_message(m.chat.id, m.message_id)
        except Exception:
            pass
        return

    ttn = _np_clean_ttn(text) or text
    try:
        await bot.delete_message(m.chat.id, m.message_id)
    except Exception:
        pass

    progress = await bot.send_message(m.chat.id, tr(uid, "NP_SEARCH_PROGRESS"))
    flow_track(uid, progress)

    text_body, kb, payload, assignment_display, error_message = np_prepare_view(uid, ttn, force_fetch=True)
    await flow_clear(uid)

    if not text_body:
        warn_text = tr(uid, "NP_SEARCH_ERROR", error=error_message or "‚Äî")
        lowered = (error_message or "").lower()
        if any(token in lowered for token in ("–Ω–µ –Ω–∞–π–¥–µ–Ω", "–Ω–µ –∑–Ω–∞–π–¥–µ–Ω", "not found", "–Ω–µ–≤—ñ—Ä–Ω", "–Ω–µ–≤–µ—Ä–Ω")):
            warn_text = tr(uid, "NP_SEARCH_NOT_FOUND", ttn=h(ttn))
        warn = await bot.send_message(m.chat.id, warn_text)
        flow_track(uid, warn)
        prompt = await bot.send_message(m.chat.id, tr(uid, "NP_PROMPT_TTN"), reply_markup=kb_np_cancel(uid))
        flow_track(uid, prompt)
        return

    await state.finish()
    await np_send_card(uid, m.chat.id, text_body, kb)


@dp.callback_query_handler(lambda c: c.data.startswith("np_refresh:"))
async def np_refresh_detail(c: types.CallbackQuery):
    uid = c.from_user.id
    ttn = c.data.split(":", 1)[1]
    text_body, kb, _, _, error_message = np_prepare_view(uid, ttn, force_fetch=True)
    if not text_body:
        await c.answer(tr(uid, "NP_SEARCH_ERROR", error=error_message or "‚Äî"), show_alert=True)
        return
    try:
        await bot.edit_message_text(
            text_body,
            c.message.chat.id,
            c.message.message_id,
            reply_markup=kb,
            disable_web_page_preview=True,
        )
    except MessageNotModified:
        pass
    except MessageCantBeEdited:
        await c.answer(tr(uid, "NP_REFRESH_NOT_POSSIBLE"), show_alert=True)
        return
    except Exception:
        await c.answer(tr(uid, "NP_REFRESH_NOT_POSSIBLE"), show_alert=True)
        return
    await c.answer()


@dp.callback_query_handler(lambda c: c.data.startswith("np_bookmark:"))
async def np_toggle_bookmark_cb(c: types.CallbackQuery):
    uid = c.from_user.id
    ttn = c.data.split(":", 1)[1]
    payload = np_get_cached_status(uid, ttn)
    if payload is None:
        success, payload, error_message = np_fetch_tracking(ttn)
        if not success:
            await c.answer(tr(uid, "NP_SEARCH_ERROR", error=error_message or "‚Äî"), show_alert=True)
            return
        np_remember_search(uid, ttn, payload)
    added = np_toggle_bookmark(uid, ttn, status_payload=payload)
    text_body, kb, _, _, _ = np_prepare_view(uid, ttn, payload=payload)
    if text_body and kb:
        try:
            await bot.edit_message_text(text_body, c.message.chat.id, c.message.message_id, reply_markup=kb)
        except Exception:
            pass
    await c.answer(tr(uid, "NP_BOOKMARK_ADDED" if added else "NP_BOOKMARK_REMOVED"))


@dp.callback_query_handler(lambda c: c.data.startswith("np_note:"))
async def np_note_prompt(c: types.CallbackQuery, state: FSMContext):
    uid = c.from_user.id
    ttn = c.data.split(":", 1)[1]
    await state.set_state(NovaPoshtaFSM.waiting_note.state)
    await state.update_data(note_ttn=ttn, note_message=(c.message.chat.id, c.message.message_id))
    prompt = await bot.send_message(c.message.chat.id, tr(uid, "NP_NOTE_PROMPT", ttn=h(ttn)), reply_markup=kb_np_cancel(uid))
    flow_track(uid, prompt)
    await c.answer()


@dp.message_handler(state=NovaPoshtaFSM.waiting_note, content_types=ContentType.TEXT)
async def np_note_receive(m: types.Message, state: FSMContext):
    uid = m.from_user.id
    data = await state.get_data()
    ttn = data.get("note_ttn")
    if not ttn:
        await state.finish()
        return
    text = (m.text or "").strip()
    if not text:
        return
    if text.lower() in NP_CANCEL_WORDS:
        await state.finish()
        await flow_clear(uid)
        notice = await bot.send_message(m.chat.id, tr(uid, "NP_NOTE_CANCELLED"))
        flow_track(uid, notice)
        return
    try:
        await bot.delete_message(m.chat.id, m.message_id)
    except Exception:
        pass
    np_add_note(uid, ttn, text)
    await state.finish()
    await flow_clear(uid)
    chat_id, message_id = data.get("note_message", (None, None))
    text_body, kb, _, _, _ = np_prepare_view(uid, ttn)
    if text_body and kb and chat_id and message_id:
        try:
            await bot.edit_message_text(text_body, chat_id, message_id, reply_markup=kb)
        except Exception:
            await bot.send_message(chat_id, text_body, reply_markup=kb)
    ack = await bot.send_message(m.chat.id, tr(uid, "NP_NOTE_SAVED"))
    flow_track(uid, ack)


@dp.callback_query_handler(lambda c: c.data == "np_history")
async def np_history_menu(c: types.CallbackQuery):
    uid = c.from_user.id
    history = np_get_history(uid)
    if not history:
        await clear_then_anchor(uid, tr(uid, "NP_HISTORY_EMPTY"), kb_novaposhta(uid))
        await c.answer()
        return
    lines = [tr(uid, "NP_HISTORY_HEADER")]
    options: List[Tuple[str, str]] = []
    for idx, entry in enumerate(history[:10], start=1):
        ttn = entry.get("ttn")
        if not ttn:
            continue
        timestamp = format_datetime_short(entry.get("timestamp")) or entry.get("timestamp") or ""
        summary = format_np_short_entry(entry.get("status_payload"))
        line = f"{idx}. <b>{h(ttn)}</b>"
        if summary:
            line += f" ‚Äî {h(summary)}"
        if timestamp:
            line += f" ({h(timestamp)})"
        lines.append(line)
        label_parts = [ttn]
        if timestamp:
            label_parts.append(timestamp)
        options.append((ttn, _np_trim_label(" ‚Ä¢ ".join(label_parts))))
    if not options:
        await clear_then_anchor(uid, tr(uid, "NP_HISTORY_EMPTY"), kb_novaposhta(uid))
    else:
        kb = np_build_list_keyboard(uid, options, "np_history_show")
        await clear_then_anchor(uid, "\n".join(lines), kb)
    await c.answer()


@dp.callback_query_handler(lambda c: c.data.startswith("np_history_show:"))
async def np_history_show_cb(c: types.CallbackQuery):
    uid = c.from_user.id
    ttn = c.data.split(":", 1)[1]
    text_body, kb, _, _, error_message = np_prepare_view(uid, ttn)
    if not text_body:
        await c.answer(tr(uid, "NP_SEARCH_ERROR", error=error_message or "‚Äî"), show_alert=True)
        return
    await np_send_card(uid, c.message.chat.id, text_body, kb)
    await c.answer()


@dp.callback_query_handler(lambda c: c.data == "np_bookmarks")
async def np_bookmarks_menu(c: types.CallbackQuery):
    uid = c.from_user.id
    bookmarks = np_list_bookmarks(uid)
    if not bookmarks:
        await clear_then_anchor(uid, tr(uid, "NP_BOOKMARKS_EMPTY"), kb_novaposhta(uid))
        await c.answer()
        return
    lines = [tr(uid, "NP_BOOKMARKS_HEADER")]
    options: List[Tuple[str, str]] = []
    for idx, (ttn, entry) in enumerate(bookmarks[:10], start=1):
        timestamp = format_datetime_short(entry.get("added_at")) or entry.get("added_at") or ""
        summary = format_np_short_entry(entry.get("status_payload"))
        line = f"{idx}. <b>{h(ttn)}</b>"
        if summary:
            line += f" ‚Äî {h(summary)}"
        if timestamp:
            line += f" ({h(timestamp)})"
        lines.append(line)
        label_parts = [ttn]
        if timestamp:
            label_parts.append(timestamp)
        options.append((ttn, _np_trim_label(" ‚Ä¢ ".join(label_parts))))
    kb = np_build_list_keyboard(uid, options, "np_bookmark_show")
    await clear_then_anchor(uid, "\n".join(lines), kb)
    await c.answer()


@dp.callback_query_handler(lambda c: c.data.startswith("np_bookmark_show:"))
async def np_bookmark_show_cb(c: types.CallbackQuery):
    uid = c.from_user.id
    ttn = c.data.split(":", 1)[1]
    text_body, kb, _, _, error_message = np_prepare_view(uid, ttn)
    if not text_body:
        await c.answer(tr(uid, "NP_SEARCH_ERROR", error=error_message or "‚Äî"), show_alert=True)
        return
    await np_send_card(uid, c.message.chat.id, text_body, kb)
    await c.answer()


@dp.callback_query_handler(lambda c: c.data == "np_assigned")
async def np_assigned_menu(c: types.CallbackQuery):
    uid = c.from_user.id
    assignments = np_list_assignments(uid)
    if not assignments:
        await clear_then_anchor(uid, tr(uid, "NP_ASSIGNED_EMPTY"), kb_novaposhta(uid))
        await c.answer()
        return
    lines = [tr(uid, "NP_ASSIGNED_HEADER")]
    options: List[Tuple[str, str]] = []
    for idx, assignment in enumerate(assignments[:10], start=1):
        ttn = assignment.get("ttn")
        status_short = format_np_short_entry(assignment.get("status_payload"))
        assigned_time = format_datetime_short(assignment.get("created_at")) or assignment.get("created_at") or ""
        delivered_time = format_datetime_short(assignment.get("delivered_at")) if assignment.get("delivered_at") else ""
        line = f"{idx}. <b>{h(ttn)}</b>"
        if status_short:
            line += f" ‚Äî {h(status_short)}"
        if assigned_time:
            line += f" ({h(assigned_time)})"
        if delivered_time:
            line += f" ‚úîÔ∏è {h(delivered_time)}"
        lines.append(line)
        label_parts = [ttn]
        if delivered_time:
            label_parts.append("‚úî")
        elif assigned_time:
            label_parts.append(assigned_time)
        options.append((ttn, _np_trim_label(" ‚Ä¢ ".join(label_parts))))
    kb = np_build_list_keyboard(uid, options, "np_assigned_detail")
    await clear_then_anchor(uid, "\n".join(lines), kb)
    await c.answer()


@dp.callback_query_handler(lambda c: c.data == "np_received")
async def np_received_menu(c: types.CallbackQuery):
    uid = c.from_user.id
    assignments = [a for a in np_list_assignments(uid) if a.get("delivered_at")]
    if not assignments:
        await clear_then_anchor(uid, tr(uid, "NP_RECEIVED_EMPTY"), kb_novaposhta(uid))
        await c.answer()
        return
    lines = [tr(uid, "NP_RECEIVED_HEADER")]
    options: List[Tuple[str, str]] = []
    for idx, assignment in enumerate(assignments[:10], start=1):
        ttn = assignment.get("ttn")
        status_short = format_np_short_entry(assignment.get("status_payload"))
        delivered_time = format_datetime_short(assignment.get("delivered_at")) or assignment.get("delivered_at") or ""
        line = f"{idx}. <b>{h(ttn)}</b>"
        if status_short:
            line += f" ‚Äî {h(status_short)}"
        if delivered_time:
            line += f" ‚úîÔ∏è {h(delivered_time)}"
        lines.append(line)
        label_parts = [ttn]
        if delivered_time:
            label_parts.append(delivered_time)
        options.append((ttn, _np_trim_label(" ‚Ä¢ ".join(label_parts))))
    kb = np_build_list_keyboard(uid, options, "np_assigned_detail")
    await clear_then_anchor(uid, "\n".join(lines), kb)
    await c.answer()


@dp.callback_query_handler(lambda c: c.data.startswith("np_assigned_detail:"))
async def np_assigned_detail_cb(c: types.CallbackQuery):
    uid = c.from_user.id
    ttn = c.data.split(":", 1)[1]
    assignment = np_get_assignment(ttn)
    payload = assignment.get("status_payload") if assignment else None
    text_body, kb, _, _, error_message = np_prepare_view(uid, ttn, payload=payload)
    if not text_body:
        await c.answer(tr(uid, "NP_SEARCH_ERROR", error=error_message or "‚Äî"), show_alert=True)
        return
    await np_send_card(uid, c.message.chat.id, text_body, kb)
    await c.answer()


@dp.callback_query_handler(lambda c: c.data.startswith("np_assigned_received:"))
async def np_assigned_received_cb(c: types.CallbackQuery):
    uid = c.from_user.id
    ttn = c.data.split(":", 1)[1]
    assignment = np_mark_assignment_received(uid, ttn)
    if not assignment:
        await c.answer(tr(uid, "NP_ASSIGNMENT_ALREADY_DONE"), show_alert=True)
        return
    text_body, kb, _, _, error_message = np_prepare_view(uid, ttn, payload=assignment.get("status_payload"))
    if text_body and kb:
        try:
            await bot.edit_message_text(text_body, c.message.chat.id, c.message.message_id, reply_markup=kb)
        except Exception:
            pass
    await c.answer(tr(uid, "NP_DELIVERY_ACK_RECORDED"))

    user_profile = load_user(uid) or {"user_id": uid}
    user_name = user_profile.get("fullname") or (user_profile.get("tg") or {}).get("first_name") or f"User {uid}"
    delivered_at = assignment.get("delivered_at")

    await anchor_show_root(uid)
    assigned_by = assignment.get("assigned_by")
    if assigned_by and assigned_by != uid:
        await anchor_show_root(assigned_by)

    user_lang = resolve_lang(uid)
    user_receipt = np_render_delivery_receipt(user_lang, ttn, user_name, delivered_at)
    user_kb = InlineKeyboardMarkup().add(
        InlineKeyboardButton(_np_pick(user_lang, NP_CLOSE_BUTTON_LABEL), callback_data="np_close")
    )
    try:
        receipt_msg = await bot.send_message(
            c.message.chat.id,
            user_receipt,
            reply_markup=user_kb,
            disable_web_page_preview=True,
        )
        flow_track(uid, receipt_msg)
    except Exception:
        pass

    for admin_id in admins:
        chat_id = users_runtime.get(admin_id, {}).get("tg", {}).get("chat_id") or (load_user(admin_id) or {}).get("tg", {}).get("chat_id")
        if not chat_id:
            continue
        admin_lang = resolve_lang(admin_id)
        alert = np_render_delivery_receipt(admin_lang, ttn, user_name, delivered_at)
        kb_admin = InlineKeyboardMarkup().add(
            InlineKeyboardButton(_np_pick(admin_lang, NP_CLOSE_BUTTON_LABEL), callback_data="np_close")
        )
        try:
            await bot.send_message(chat_id, alert, reply_markup=kb_admin, disable_web_page_preview=True)
        except Exception:
            continue


def np_assign_candidate_profiles() -> List[dict]:
    profiles = load_all_users()
    def sort_key(profile: dict) -> Tuple[str, int]:
        name = (profile.get("fullname") or (profile.get("tg") or {}).get("first_name") or "").strip().lower()
        return name, profile.get("user_id", 0)
    return sorted(profiles, key=sort_key)


def np_assign_format_label(profile: dict) -> str:
    name = profile.get("fullname") or (profile.get("tg") or {}).get("first_name") or f"ID {profile.get('user_id')}"
    bsu = profile.get("bsu") or f"ID {profile.get('user_id')}"
    label = f"{name} ‚Ä¢ {bsu}"
    return _np_trim_label(label, 36)


async def np_assign_show_picker(uid: int, state: FSMContext, chat_id: int, page: int = 0) -> None:
    profiles = np_assign_candidate_profiles()
    per_page = 6
    total = len(profiles)
    if total == 0:
        warn = await bot.send_message(chat_id, tr(uid, "NP_ASSIGN_USER_NOT_FOUND"))
        flow_track(uid, warn)
        return
    max_page = max(0, (total - 1) // per_page)
    page = max(0, min(page, max_page))
    start = page * per_page
    chunk = profiles[start:start + per_page]
    kb = InlineKeyboardMarkup()
    for profile in chunk:
        user_id = profile.get("user_id")
        if user_id is None:
            continue
        kb.add(InlineKeyboardButton(np_assign_format_label(profile), callback_data=f"np_assign_pick:{user_id}"))
    nav_buttons: List[InlineKeyboardButton] = []
    if page > 0:
        nav_buttons.append(InlineKeyboardButton("‚¨ÖÔ∏è", callback_data=f"np_assign_page:{page-1}"))
    if page < max_page:
        nav_buttons.append(InlineKeyboardButton("‚û°Ô∏è", callback_data=f"np_assign_page:{page+1}"))
    if nav_buttons:
        kb.row(*nav_buttons)
    kb.add(InlineKeyboardButton(_np_pick(resolve_lang(uid), NP_CANCEL_BUTTON_LABEL), callback_data="np_cancel"))
    text = tr(uid, "NP_ASSIGN_PROMPT_USER")
    if max_page:
        text += f"\n\n{page + 1}/{max_page + 1}"
    data = await state.get_data()
    picker_info = data.get("assign_picker")
    message_id = None
    if isinstance(picker_info, (list, tuple)) and len(picker_info) >= 2:
        stored_chat, stored_mid = picker_info[0], picker_info[1]
        if stored_chat == chat_id:
            message_id = stored_mid
    if message_id:
        try:
            await bot.edit_message_text(text, chat_id, message_id, reply_markup=kb)
        except Exception:
            msg = await bot.send_message(chat_id, text, reply_markup=kb)
            flow_track(uid, msg)
            await state.update_data(assign_picker=(msg.chat.id, msg.message_id, page))
        else:
            await state.update_data(assign_picker=(chat_id, message_id, page))
    else:
        msg = await bot.send_message(chat_id, text, reply_markup=kb)
        flow_track(uid, msg)
        await state.update_data(assign_picker=(msg.chat.id, msg.message_id, page))


async def np_assign_clear_picker(state: FSMContext):
    data = await state.get_data()
    picker_info = data.get("assign_picker")
    if isinstance(picker_info, (list, tuple)) and len(picker_info) >= 2:
        chat_id, message_id = picker_info[0], picker_info[1]
        try:
            await bot.delete_message(chat_id, message_id)
        except Exception:
            pass
    await state.update_data(assign_picker=None)


async def np_assign_user_selected(uid: int, profile: dict, state: FSMContext, chat_id: int):
    await np_assign_clear_picker(state)
    await flow_clear(uid)
    fullname = profile.get("fullname") or (profile.get("tg") or {}).get("first_name") or f"User {profile.get('user_id')}"
    bsu = profile.get("bsu", "‚Äî")
    summary = await bot.send_message(chat_id, f"üë§ <b>{h(fullname)}</b> ‚Äî BSU {h(bsu)}")
    flow_track(uid, summary)
    prompt = await bot.send_message(chat_id, tr(uid, "NP_ASSIGN_PROMPT_NOTE"), reply_markup=kb_np_assign_note(uid))
    flow_track(uid, prompt)
    await state.set_state(NovaPoshtaFSM.waiting_assign_note.state)


async def np_assign_finalize(uid: int, state: FSMContext, chat_id: int, note_text: str) -> None:
    data = await state.get_data()
    ttn = data.get("assign_ttn")
    payload = data.get("assign_payload")
    target_id = data.get("assign_user_id")
    note_text = (note_text or "").strip()

    await np_assign_clear_picker(state)
    await state.finish()
    await flow_clear(uid)

    if not target_id or not ttn or not payload:
        warn = await bot.send_message(chat_id, tr(uid, "NP_ASSIGN_CANCELLED"))
        flow_track(uid, warn)
        await anchor_show_text(uid, tr(uid, "NP_MENU_TITLE"), kb_novaposhta(uid))
        return

    target_profile = load_user(target_id) or {"user_id": target_id}
    assignment = np_assign_parcel(uid, target_id, ttn, payload, note=note_text)
    await anchor_show_root(target_id)
    admin_profile = load_user(uid) or {"user_id": uid}
    admin_name = admin_profile.get("fullname") or (admin_profile.get("tg") or {}).get("first_name") or f"ID {uid}"
    target_name = target_profile.get("fullname") or (target_profile.get("tg") or {}).get("first_name") or f"User {target_id}"
    lang = resolve_lang(uid)
    assigned_time = format_datetime_short(assignment.get("updated_at")) or assignment.get("updated_at") or "‚Äî"

    confirm_text = tr(uid, "NP_ASSIGN_DONE", ttn=h(ttn), user=h(target_name), time=h(assigned_time))
    note_display = (assignment.get("note") or "").strip()
    if note_display:
        confirm_text = f"{confirm_text}\n\n{_np_pick(lang, NP_ASSIGN_DONE_NOTE_LABEL).format(note=h(note_display))}"

    confirm_kb = InlineKeyboardMarkup().add(
        InlineKeyboardButton(_np_pick(lang, NP_CLOSE_BUTTON_LABEL), callback_data="np_close")
    )
    confirm = await bot.send_message(chat_id, confirm_text, reply_markup=confirm_kb)
    flow_track(uid, confirm)
    await anchor_show_text(uid, tr(uid, "NP_MENU_TITLE"), kb_novaposhta(uid))

    target_chat = users_runtime.get(target_id, {}).get("tg", {}).get("chat_id") or (target_profile.get("tg") or {}).get("chat_id")
    if target_chat:
        target_text, target_kb, _, _, _ = np_prepare_view(target_id, ttn, payload=payload)
        notify_prefix = tr(target_id, "NP_ASSIGN_NOTIFY_USER", admin=h(admin_name), ttn=h(ttn))
        body = f"{notify_prefix}\n\n{target_text}" if target_text else notify_prefix
        try:
            await bot.send_message(target_chat, body, reply_markup=target_kb)
        except Exception:
            pass


@dp.callback_query_handler(lambda c: c.data == "np_assign_start")
async def np_assign_start_cb(c: types.CallbackQuery, state: FSMContext):
    uid = c.from_user.id
    if uid not in admins:
        await c.answer("‚õî", show_alert=True)
        return
    await flow_clear(uid)
    await state.set_state(NovaPoshtaFSM.waiting_assign_ttn.state)
    prompt = await bot.send_message(c.message.chat.id, tr(uid, "NP_ASSIGN_PROMPT_TTN"), reply_markup=kb_np_cancel(uid))
    flow_track(uid, prompt)
    await c.answer()


@dp.callback_query_handler(lambda c: c.data.startswith("np_assign_quick:"), state="*")
async def np_assign_quick_cb(c: types.CallbackQuery, state: FSMContext):
    uid = c.from_user.id
    if uid not in admins:
        await c.answer("‚õî", show_alert=True)
        return
    ttn = c.data.split(":", 1)[1]
    payload = np_get_cached_status(uid, ttn)
    if payload is None:
        success, payload, error_message = np_fetch_tracking(ttn)
        if not success:
            await c.answer(tr(uid, "NP_SEARCH_ERROR", error=error_message or "‚Äî"), show_alert=True)
            return
        np_remember_search(uid, ttn, payload)
    await flow_clear(uid)
    await state.set_state(NovaPoshtaFSM.waiting_assign_user.state)
    await state.update_data(assign_ttn=ttn, assign_payload=payload)
    await np_assign_show_picker(uid, state, c.message.chat.id, page=0)
    await c.answer()


@dp.callback_query_handler(lambda c: c.data.startswith("np_assign_page:"), state="*")
async def np_assign_page_cb(c: types.CallbackQuery, state: FSMContext):
    uid = c.from_user.id
    if uid not in admins:
        await c.answer("‚õî", show_alert=True)
        return
    current = await state.get_state()
    if current != NovaPoshtaFSM.waiting_assign_user.state:
        await c.answer()
        return
    try:
        page = int(c.data.split(":", 1)[1])
    except ValueError:
        await c.answer()
        return
    await np_assign_show_picker(uid, state, c.message.chat.id, page=page)
    await c.answer()


@dp.callback_query_handler(lambda c: c.data.startswith("np_assign_pick:"), state="*")
async def np_assign_pick_cb(c: types.CallbackQuery, state: FSMContext):
    uid = c.from_user.id
    if uid not in admins:
        await c.answer("‚õî", show_alert=True)
        return
    current = await state.get_state()
    if current != NovaPoshtaFSM.waiting_assign_user.state:
        await c.answer()
        return
    try:
        target_id = int(c.data.split(":", 1)[1])
    except ValueError:
        await c.answer()
        return
    profile = load_user(target_id)
    if not profile:
        await c.answer(tr(uid, "NP_ASSIGN_USER_NOT_FOUND"), show_alert=True)
        return
    await state.update_data(assign_user_id=target_id)
    await np_assign_user_selected(uid, profile, state, c.message.chat.id)
    await c.answer()


@dp.message_handler(state=NovaPoshtaFSM.waiting_assign_ttn, content_types=ContentType.TEXT)
async def np_assign_receive_ttn(m: types.Message, state: FSMContext):
    uid = m.from_user.id
    if uid not in admins:
        await state.finish()
        return
    text = (m.text or "").strip()
    if not text:
        return
    if text.lower() in NP_CANCEL_WORDS:
        await np_assign_clear_picker(state)
        await state.finish()
        await flow_clear(uid)
        try:
            await bot.delete_message(m.chat.id, m.message_id)
        except Exception:
            pass
        await anchor_show_text(uid, tr(uid, "NP_MENU_TITLE"), kb_novaposhta(uid))
        return
    ttn = _np_clean_ttn(text) or text
    try:
        await bot.delete_message(m.chat.id, m.message_id)
    except Exception:
        pass
    text_body, kb, payload, _, error_message = np_prepare_view(uid, ttn, force_fetch=True)
    await flow_clear(uid)
    if not text_body:
        warn = await bot.send_message(m.chat.id, tr(uid, "NP_SEARCH_ERROR", error=error_message or "‚Äî"))
        flow_track(uid, warn)
        prompt = await bot.send_message(m.chat.id, tr(uid, "NP_ASSIGN_PROMPT_TTN"), reply_markup=kb_np_cancel(uid))
        flow_track(uid, prompt)
        return
    await state.set_state(NovaPoshtaFSM.waiting_assign_user.state)
    await state.update_data(assign_ttn=ttn, assign_payload=payload)
    preview = await bot.send_message(m.chat.id, text_body, reply_markup=kb)
    flow_track(uid, preview)
    await np_assign_show_picker(uid, state, m.chat.id, page=0)


@dp.message_handler(state=NovaPoshtaFSM.waiting_assign_user, content_types=ContentType.ANY)
async def np_assign_receive_user(m: types.Message, state: FSMContext):
    uid = m.from_user.id
    if uid not in admins:
        await state.finish()
        return
    if m.text and m.text.strip().lower() in NP_CANCEL_WORDS:
        await np_assign_clear_picker(state)
        await state.finish()
        await flow_clear(uid)
        try:
            await bot.delete_message(m.chat.id, m.message_id)
        except Exception:
            pass
        await anchor_show_text(uid, tr(uid, "NP_MENU_TITLE"), kb_novaposhta(uid))
        return
    profile = resolve_user_reference(m)
    if not profile:
        warn = await bot.send_message(m.chat.id, tr(uid, "NP_ASSIGN_USER_NOT_FOUND"))
        flow_track(uid, warn)
        return
    try:
        await bot.delete_message(m.chat.id, m.message_id)
    except Exception:
        pass
    await state.update_data(assign_user_id=profile.get("user_id"))
    await np_assign_user_selected(uid, profile, state, m.chat.id)


@dp.message_handler(state=NovaPoshtaFSM.waiting_assign_note, content_types=ContentType.TEXT)
async def np_assign_receive_note(m: types.Message, state: FSMContext):
    uid = m.from_user.id
    if uid not in admins:
        await state.finish()
        return
    note_text = (m.text or "").strip()
    if note_text.lower() in NP_CANCEL_WORDS:
        await np_assign_clear_picker(state)
        await state.finish()
        await flow_clear(uid)
        try:
            await bot.delete_message(m.chat.id, m.message_id)
        except Exception:
            pass
        await anchor_show_text(uid, tr(uid, "NP_MENU_TITLE"), kb_novaposhta(uid))
        return
    if note_text == "-":
        note_text = ""
    try:
        await bot.delete_message(m.chat.id, m.message_id)
    except Exception:
        pass
    await np_assign_finalize(uid, state, m.chat.id, note_text)


@dp.callback_query_handler(lambda c: c.data == "np_assign_skip", state="*")
async def np_assign_skip_cb(c: types.CallbackQuery, state: FSMContext):
    uid = c.from_user.id
    if uid not in admins:
        await c.answer("‚õî", show_alert=True)
        return
    current = await state.get_state()
    if current != NovaPoshtaFSM.waiting_assign_note.state:
        await c.answer()
        return
    await np_assign_finalize(uid, state, c.message.chat.id, "")
    await c.answer(tr(uid, "NP_ASSIGN_SKIP_TOAST"))


@dp.callback_query_handler(lambda c: c.data == "np_close", state="*")
async def np_close_message(c: types.CallbackQuery):
    try:
        await bot.delete_message(c.message.chat.id, c.message.message_id)
    except Exception:
        pass
    await c.answer()


@dp.callback_query_handler(lambda c: c.data == "np_cancel", state="*")
async def np_cancel_flow(c: types.CallbackQuery, state: FSMContext):
    uid = c.from_user.id
    current = await state.get_state()
    if current and current.startswith("NovaPoshtaFSM"):
        await np_assign_clear_picker(state)
        await state.finish()
    await flow_clear(uid)
    try:
        await bot.delete_message(c.message.chat.id, c.message.message_id)
    except Exception:
        pass
    await anchor_show_text(uid, tr(uid, "NP_MENU_TITLE"), kb_novaposhta(uid))
    await c.answer(tr(uid, "NP_CANCELLED_TOAST"))

# ========================== CHECKS ==========================
@dp.callback_query_handler(lambda c: c.data == "menu_profile")
async def menu_profile(c: types.CallbackQuery, state: FSMContext):
    uid = c.from_user.id
    await state.finish()
    await flow_clear(uid)
    profile_set_flags(uid, edit_mode=False, show_photo=False)
    await show_profile(uid, edit_mode=False, show_photo=False)
    await c.answer()


@dp.callback_query_handler(lambda c: c.data == "profile_edit")
async def profile_enter_edit(c: types.CallbackQuery, state: FSMContext):
    uid = c.from_user.id
    await state.finish()
    await flow_clear(uid)
    profile_set_flags(uid, edit_mode=True, show_photo=False)
    await show_profile(uid, edit_mode=True, show_photo=False)
    await c.answer()


@dp.callback_query_handler(lambda c: c.data == "profile_done", state="*")
async def profile_exit_edit(c: types.CallbackQuery, state: FSMContext):
    uid = c.from_user.id
    await profile_clear_prompt(uid)
    await flow_clear_warnings(uid)
    runtime = profile_runtime(uid)
    remove_keyboard = bool(runtime.pop("profile_reply_keyboard", False))
    await state.finish()
    profile_set_flags(uid, edit_mode=False, show_photo=False)
    if remove_keyboard:
        await profile_send_notification(uid, tr(uid, "PROFILE_CANCELLED"), remove_keyboard=True)
    await show_profile(uid, edit_mode=False, show_photo=False)
    await c.answer()


@dp.callback_query_handler(lambda c: c.data == "profile_view_photo")
async def profile_view_photo(c: types.CallbackQuery):
    uid = c.from_user.id
    profile_set_flags(uid, show_photo=True)
    await show_profile(uid, show_photo=True)
    await c.answer()


@dp.callback_query_handler(lambda c: c.data == "profile_hide_photo")
async def profile_hide_photo(c: types.CallbackQuery):
    uid = c.from_user.id
    profile_set_flags(uid, show_photo=False)
    await show_profile(uid, show_photo=False)
    await c.answer()


@dp.callback_query_handler(
    lambda c: c.data == "profile_cancel",
    state=[
        ProfileEditFSM.waiting_last_name,
        ProfileEditFSM.waiting_first_name,
        ProfileEditFSM.waiting_middle_name,
        ProfileEditFSM.waiting_birthdate,
        ProfileEditFSM.waiting_region,
        ProfileEditFSM.region_confirm,
        ProfileEditFSM.waiting_phone,
        ProfileEditFSM.waiting_photo,
    ]
)
async def profile_cancel_edit(c: types.CallbackQuery, state: FSMContext):
    uid = c.from_user.id
    runtime = profile_runtime(uid)
    remove_keyboard = bool(runtime.pop("profile_reply_keyboard", False))
    await profile_abort(uid, state, remove_keyboard=remove_keyboard)
    await c.answer()


@dp.callback_query_handler(lambda c: c.data == "profile_edit_last")
async def profile_prompt_last(c: types.CallbackQuery, state: FSMContext):
    uid = c.from_user.id
    await flow_clear_warnings(uid)
    await profile_send_prompt(uid, tr(uid, "PROFILE_PROMPT_LAST_NAME"), reply_markup=kb_profile_cancel(uid))
    await ProfileEditFSM.waiting_last_name.set()
    await c.answer()


@dp.callback_query_handler(lambda c: c.data == "profile_edit_first")
async def profile_prompt_first(c: types.CallbackQuery, state: FSMContext):
    uid = c.from_user.id
    await flow_clear_warnings(uid)
    await profile_send_prompt(uid, tr(uid, "PROFILE_PROMPT_FIRST_NAME"), reply_markup=kb_profile_cancel(uid))
    await ProfileEditFSM.waiting_first_name.set()
    await c.answer()


@dp.callback_query_handler(lambda c: c.data == "profile_edit_middle")
async def profile_prompt_middle(c: types.CallbackQuery, state: FSMContext):
    uid = c.from_user.id
    await flow_clear_warnings(uid)
    await profile_send_prompt(uid, tr(uid, "PROFILE_PROMPT_MIDDLE_NAME"), reply_markup=kb_profile_cancel(uid))
    await ProfileEditFSM.waiting_middle_name.set()
    await c.answer()


@dp.callback_query_handler(lambda c: c.data == "profile_edit_birthdate")
async def profile_prompt_birthdate(c: types.CallbackQuery, state: FSMContext):
    uid = c.from_user.id
    await flow_clear_warnings(uid)
    await profile_send_prompt(uid, tr(uid, "PROFILE_PROMPT_BIRTHDATE"), reply_markup=kb_profile_cancel(uid))
    await ProfileEditFSM.waiting_birthdate.set()
    await c.answer()


@dp.callback_query_handler(lambda c: c.data == "profile_edit_region")
async def profile_prompt_region(c: types.CallbackQuery, state: FSMContext):
    uid = c.from_user.id
    await flow_clear_warnings(uid)
    await profile_send_prompt(uid, tr(uid, "PROFILE_PROMPT_REGION"), reply_markup=kb_profile_region_prompt(uid))
    await ProfileEditFSM.waiting_region.set()
    await c.answer()


@dp.callback_query_handler(lambda c: c.data == "profile_edit_phone")
async def profile_prompt_phone(c: types.CallbackQuery, state: FSMContext):
    uid = c.from_user.id
    await flow_clear_warnings(uid)
    kb = kb_profile_phone_keyboard(uid)
    await profile_send_prompt(uid, tr(uid, "PROFILE_PROMPT_PHONE"), reply_markup=kb)
    await ProfileEditFSM.waiting_phone.set()
    await c.answer()


@dp.callback_query_handler(lambda c: c.data == "profile_edit_photo")
async def profile_prompt_photo(c: types.CallbackQuery, state: FSMContext):
    uid = c.from_user.id
    await flow_clear_warnings(uid)
    await profile_send_prompt(uid, tr(uid, "PROFILE_PROMPT_PHOTO"), reply_markup=kb_profile_cancel(uid))
    await ProfileEditFSM.waiting_photo.set()
    await c.answer()


@dp.callback_query_handler(lambda c: c.data == "menu_checks")
async def menu_checks(c: types.CallbackQuery):
    uid = c.from_user.id
    await clear_then_anchor(uid, tr(uid, "CHECKS_MENU_INTRO"), kb_checks(uid))
    await c.answer()


@dp.callback_query_handler(lambda c: c.data == "menu_settings")
async def menu_settings(c: types.CallbackQuery):
    uid = c.from_user.id
    await clear_then_anchor(uid, tr(uid, "SETTINGS_TITLE"), kb_settings(uid))
    await c.answer()


@dp.callback_query_handler(lambda c: c.data == "settings_language")
async def settings_language(c: types.CallbackQuery):
    uid = c.from_user.id
    await clear_then_anchor(uid, tr(uid, "LANGUAGE_PROMPT"), kb_language_settings(uid))
    await c.answer()


@dp.callback_query_handler(lambda c: c.data == "settings_back")
async def settings_back(c: types.CallbackQuery):
    uid = c.from_user.id
    await clear_then_anchor(uid, tr(uid, "SETTINGS_TITLE"), kb_settings(uid))
    await c.answer()


@dp.callback_query_handler(lambda c: c.data.startswith("settings_lang:"))
async def settings_lang_change(c: types.CallbackQuery):
    uid = c.from_user.id
    code = c.data.split(":", 1)[1]
    if code not in LANG_CODES:
        await c.answer(tr(uid, "INVALID_COMMAND"), show_alert=True)
        return
    set_user_lang(uid, code, confirmed=True)
    await c.answer()
    await clear_then_anchor(uid, tr(uid, "LANGUAGE_SELECTED", language=LANG_LABELS[code]), kb_settings(uid))
    await anchor_show_root(uid)


@dp.callback_query_handler(lambda c: c.data == "check_stats")
async def check_stats(c: types.CallbackQuery):
    uid = c.from_user.id
    if not active_project["name"]:
        return await c.answer("‚ùó –ù–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–≥–æ –ø—Ä–æ–µ–∫—Ç–∞", show_alert=True)
    proj = active_project["name"]
    recs = user_project_receipts(uid, proj)
    cnt = len(recs)
    total = round(sum(float(r.get("sum") or 0.0) for r in recs), 2)
    paid_recs = [r for r in recs if r.get("paid") is True]
    unpaid_recs = [r for r in recs if r.get("paid") is False]
    pending_recs = [r for r in recs if r.get("paid") is None]
    paid_sum = round(sum(float(r.get("sum") or 0.0) for r in paid_recs), 2)
    unpaid_sum = round(sum(float(r.get("sum") or 0.0) for r in unpaid_recs), 2)
    pending_sum = round(sum(float(r.get("sum") or 0.0) for r in pending_recs), 2)
    summary_lines = [
        "üìä <b>–õ–∏—á–Ω–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ —á–µ–∫–∞–º</b>",
        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ",
        f"üìÇ –ü—Ä–æ–µ–∫—Ç: <b>{h(proj)}</b>",
        f"üßæ –í—Å–µ–≥–æ —á–µ–∫–æ–≤: <b>{cnt}</b>",
        f"üí∞ –°—É–º–º–∞ —á–µ–∫–æ–≤: <b>{fmt_money(total)} –≥—Ä–Ω</b>",
        f"üí∏ –û–ø–ª–∞—á–µ–Ω–æ —Ñ–∏—Ä–º–æ–π: <b>{fmt_money(paid_sum)} –≥—Ä–Ω</b> ({len(paid_recs)} —à—Ç.)",
        f"‚è≥ –û–∂–∏–¥–∞–µ—Ç –æ–ø–ª–∞—Ç—ã: <b>{fmt_money(unpaid_sum)} –≥—Ä–Ω</b> ({len(unpaid_recs)} —à—Ç.)",
    ]
    if pending_recs:
        summary_lines.append(f"‚ùî –°—Ç–∞—Ç—É—Å –Ω–µ —É–∫–∞–∑–∞–Ω: <b>{fmt_money(pending_sum)} –≥—Ä–Ω</b> ({len(pending_recs)} —à—Ç.)")
    if cnt == 0:
        summary_lines.append("")
        summary_lines.append("–î–æ–±–∞–≤—å—Ç–µ –ø–µ—Ä–≤—ã–π —á–µ–∫ —á–µ—Ä–µ–∑ –∫–Ω–æ–ø–∫—É ¬´üì∑ –î–æ–±–∞–≤–∏—Ç—å —á–µ–∫¬ª, –∏ –∑–¥–µ—Å—å –ø–æ—è–≤–∏—Ç—Å—è —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω–∞—è —Ç–∞–±–ª–∏—Ü–∞ —Å –¥–µ—Ç–∞–ª—è–º–∏.")
        await clear_then_anchor(uid, "\n".join(summary_lines), kb_checks(uid))
        await c.answer()
        return
    summary_lines.append("")
    summary_lines.append("–ü–æ–ª–Ω–∞—è —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–∞ –≤—Å–µ—Ö —á–µ–∫–æ–≤ –ø—Ä–∏–≤–µ–¥–µ–Ω–∞ –Ω–∏–∂–µ –≤ –ø–æ—Ä—è–¥–∫–µ –æ—Ç –Ω–æ–≤—ã—Ö –∫ —Å—Ç–∞—Ä—ã–º.")
    await clear_then_anchor(uid, "\n".join(summary_lines), kb_checks(uid))

    sorted_recs = sorted(
        recs,
        key=lambda r: (
            r.get("date") or "",
            r.get("time") or "",
            r.get("receipt_no") or "",
        ),
        reverse=True,
    )
    chat_id = c.message.chat.id
    chunk_size = 12
    total_recs = len(sorted_recs)
    for start in range(0, total_recs, chunk_size):
        chunk = sorted_recs[start:start + chunk_size]
        lines: List[str] = [
            "üóÇ <b>–î–µ—Ç–∞–ª–∏–∑–∞—Ü–∏—è —á–µ–∫–æ–≤</b>",
            f"–°—Ç—Ä–æ–∫–∏ {start + 1}‚Äì{start + len(chunk)} –∏–∑ {total_recs}",
            "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ",
        ]
        for idx, receipt in enumerate(chunk, start=start + 1):
            lines.append(format_receipt_stat_entry(idx, receipt))
            lines.append("")
        message_text = "\n".join(line for line in lines if line is not None).strip()
        msg = await bot.send_message(chat_id, message_text, disable_web_page_preview=True)
        flow_track(uid, msg)
    await c.answer()


@dp.callback_query_handler(lambda c: c.data == "check_list")
async def check_list(c: types.CallbackQuery):
    uid = c.from_user.id
    if not active_project["name"]:
        return await c.answer("‚ùó –ù–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–≥–æ –ø—Ä–æ–µ–∫—Ç–∞", show_alert=True)
    proj = active_project["name"]
    recs = user_project_receipts(uid, proj)
    if not recs:
        await c.answer("–£ –≤–∞—Å –µ—â—ë –Ω–µ—Ç —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—ã—Ö —á–µ–∫–æ–≤. –î–æ–±–∞–≤—å—Ç–µ –ø–µ—Ä–≤—ã–π —á–µ—Ä–µ–∑ –∫–Ω–æ–ø–∫—É ¬´üì∑ –î–æ–±–∞–≤–∏—Ç—å —á–µ–∫¬ª.", show_alert=True); return
    total = len(recs)
    header = (
        "üìÅ <b>–í—Å–µ –∑–∞–≥—Ä—É–∂–µ–Ω–Ω—ã–µ —á–µ–∫–∏</b>\n"
        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
        f"üìÇ –ü—Ä–æ–µ–∫—Ç: <b>{h(proj)}</b>\n"
        f"üßæ –í—Å–µ–≥–æ —á–µ–∫–æ–≤: <b>{total}</b>\n\n"
        "–ü—Ä–æ—Å–º–∞—Ç—Ä–∏–≤–∞–π—Ç–µ –∫–∞—Ä—Ç–æ—á–∫–∏ –Ω–∏–∂–µ. –î–ª—è —á–µ–∫–æ–≤ –±–µ–∑ —Å—Ç–∞—Ç—É—Å–∞ –æ–ø–ª–∞—Ç—ã –ø–æ—è–≤—è—Ç—Å—è –∫–Ω–æ–ø–∫–∏, —á—Ç–æ–±—ã —É–∫–∞–∑–∞—Ç—å ¬´–§–∏—Ä–º–∞ –æ–ø–ª–∞—Ç–∏–ª–∞¬ª –∏–ª–∏ ¬´–§–∏—Ä–º–∞ –Ω–µ –æ–ø–ª–∞—Ç–∏–ª–∞¬ª."
    )
    await clear_then_anchor(uid, header, kb_checks(uid))
    chat_id = c.message.chat.id
    for idx, r in enumerate(recs, start=1):
        token = r.get("receipt_no") or r.get("file") or ""
        rows: List[List[InlineKeyboardButton]] = []
        if r.get("paid") is None and token:
            rows.append([
                InlineKeyboardButton("‚úÖ –§–∏—Ä–º–∞ –æ–ø–ª–∞—Ç–∏–ª–∞", callback_data=f"userpaid_yes:{proj}:{token}"),
                InlineKeyboardButton("‚ùå –§–∏—Ä–º–∞ –Ω–µ –æ–ø–ª–∞—Ç–∏–ª–∞", callback_data=f"userpaid_no:{proj}:{token}")
            ])
        rows.append([InlineKeyboardButton("‚ùå –ó–∞–∫—Ä—ã—Ç—å", callback_data="broadcast_close")])
        kb: Optional[InlineKeyboardMarkup] = None
        if rows:
            kb = InlineKeyboardMarkup()
            for row in rows:
                kb.row(*row)
        prefix = f"üßæ –ß–µ–∫ {idx} –∏–∑ {total}"
        try:
            msg = await send_receipt_card(chat_id, proj, uid, r, kb=kb, prefix=prefix)
        except Exception as exc:
            print(f"[check_list] failed to send receipt card: {exc}")
            fallback = (
                f"{prefix}\n"
                f"üÜî –ù–æ–º–µ—Ä: <b>{h(r.get('receipt_no', '‚Äî'))}</b>\n"
                f"üí∞ {fmt_money(float(r.get('sum') or 0.0))} –≥—Ä–Ω\n"
                f"üîñ {receipt_status_text(r.get('paid'))}"
            )
            msg = await bot.send_message(chat_id, fallback, reply_markup=kb)
        flow_track(uid, msg)
    await c.answer()


@dp.callback_query_handler(lambda c: c.data == "check_history")
async def check_history(c: types.CallbackQuery):
    uid = c.from_user.id
    if not active_project["name"]:
        return await c.answer("‚ùó –ù–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–≥–æ –ø—Ä–æ–µ–∫—Ç–∞", show_alert=True)
    proj = active_project["name"]
    recs = user_project_receipts(uid, proj)
    if not recs:
        await clear_then_anchor(
            uid,
            f"üóÇ –ò—Å—Ç–æ—Ä–∏—è —á–µ–∫–æ–≤ –ø–æ–∫–∞ –ø—É—Å—Ç–∞.\nüìÇ –ü—Ä–æ–µ–∫—Ç: <b>{h(proj)}</b>\n\n–î–æ–±–∞–≤—å—Ç–µ –ø–µ—Ä–≤—ã–π —á–µ–∫ —á–µ—Ä–µ–∑ –∫–Ω–æ–ø–∫—É ¬´üì∑ –î–æ–±–∞–≤–∏—Ç—å —á–µ–∫¬ª, –∏ –∑–¥–µ—Å—å –ø–æ—è–≤–∏—Ç—Å—è –ø–æ–ª–Ω—ã–π –∂—É—Ä–Ω–∞–ª –æ–ø–µ—Ä–∞—Ü–∏–π.",
            kb_checks(uid)
        )
        return await c.answer()
    sorted_recs = sorted(
        recs,
        key=lambda r: (
            r.get("date") or "",
            r.get("time") or "",
            r.get("receipt_no") or ""
        )
    )
    display_recs = sorted_recs[-30:]
    lines = [
        "üóÇ <b>–ò—Å—Ç–æ—Ä–∏—è —á–µ–∫–æ–≤ –∏ –æ–ø–ª–∞—Ç</b>",
        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ",
        f"üìÇ –ü—Ä–æ–µ–∫—Ç: <b>{h(proj)}</b>",
        f"üóÇ –ó–∞–ø–∏—Å–µ–π –≤ –ø–æ–¥–±–æ—Ä–∫–µ: <b>{len(display_recs)}</b>",
        "",
        "–ü–æ—Å–ª–µ–¥–Ω–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω—ã –Ω–∏–∂–µ –≤ —Ö—Ä–æ–Ω–æ–ª–æ–≥–∏—á–µ—Å–∫–æ–º –ø–æ—Ä—è–¥–∫–µ. –ó–Ω–∞—á–∫–∏ —Å–ø—Ä–∞–≤–∞ –ø–æ–¥—Å–∫–∞–∑—ã–≤–∞—é—Ç —Ç–µ–∫—É—â–∏–π —Å—Ç–∞—Ç—É—Å –≤—ã–ø–ª–∞—Ç.",
        "",
    ]
    for r in display_recs:
        try:
            amount = float(r.get("sum", 0.0))
        except (TypeError, ValueError):
            amount = 0.0
        base = f"‚Ä¢ {h(r.get('receipt_no', '‚Äî'))} ‚Äî {fmt_money(amount)} –≥—Ä–Ω ‚Äî {receipt_status_text(r.get('paid'))}"
        extra = ""
        payout = r.get("payout") if isinstance(r.get("payout"), dict) else None
        if payout and payout.get("status"):
            status = payout.get("status")
            code = payout.get("code") or payout.get("request_id")
            code_disp = h(code) if code else "‚Äî"
            if status == "pending":
                ts = format_datetime_short(payout.get("assigned_at") or payout.get("updated_at"))
                extra = f" ‚è≥ {code_disp}{f' ‚Äî {ts}' if ts else ''}"
            elif status == "approved":
                ts = format_datetime_short(payout.get("updated_at"))
                extra = f" üí∂ {code_disp}{f' ‚Äî {ts}' if ts else ''}"
            elif status == "confirmed":
                ts = format_datetime_short(payout.get("confirmed_at"))
                extra = f" üí∏ {code_disp}{f' ‚Äî {ts}' if ts else ''}"
            elif status == "closed":
                ts = format_datetime_short(payout.get("updated_at"))
                extra = f" üì≠ {code_disp}{f' ‚Äî {ts}' if ts else ''}"
        elif r.get("paid") is True:
            ts = format_datetime_short(r.get("paid_at"))
            code = r.get("paid_request_code")
            if code:
                extra = f" üí∏ {h(code)}{f' ‚Äî {ts}' if ts else ''}"
            elif ts:
                extra = f" üí∏ {ts}"
        elif isinstance(r.get("payout_history"), list) and r["payout_history"]:
            last_event = r["payout_history"][-1]
            if isinstance(last_event, dict) and last_event.get("status") == "closed":
                code = last_event.get("code") or last_event.get("request_id")
                ts = format_datetime_short(last_event.get("timestamp"))
                extra = f" üì≠ {h(code) if code else '–ó–∞–ø—Ä–æ—Å'}{f' ‚Äî {ts}' if ts else ''}"
        lines.append(base + extra)
    await clear_then_anchor(uid, "\n".join(lines), kb_checks(uid))
    await c.answer()


@dp.callback_query_handler(lambda c: c.data.startswith("userpaid_"))
async def userpaid_set(c: types.CallbackQuery):
    uid = c.from_user.id
    try:
        action, proj, token = c.data.split(":", 2)
    except:
        return await c.answer("–û—à–∏–±–∫–∞")
    prof = load_user(uid) or {}
    recs = prof.get("receipts", {}).get(proj, [])
    changed = False
    for r in recs:
        rid = r.get("receipt_no") or ""
        fname = r.get("file") or ""
        if token and token not in (rid, fname):
            continue
        payout_status = (r.get("payout") or {}).get("status") if isinstance(r.get("payout"), dict) else None
        if payout_status in ("pending", "approved"):
            return await c.answer("–ó–∞–ø—Ä–æ—Å –ø–æ —ç—Ç–æ–º—É —á–µ–∫—É —É–∂–µ –≤ –æ–±—Ä–∞–±–æ—Ç–∫–µ.", show_alert=True)
        new_value = True if action.endswith("yes") else False
        r["paid"] = new_value
        now_iso = datetime.now().isoformat()
        if new_value:
            r["paid_at"] = now_iso
        else:
            r.pop("paid_at", None)
        r.pop("paid_request_id", None)
        r.pop("paid_request_code", None)
        if isinstance(r.get("payout_history"), list):
            r["payout_history"].append({
                "status": "manual_paid" if new_value else "manual_unpaid",
                "timestamp": now_iso,
                "project": proj,
                "amount": float(r.get("sum") or 0.0)
            })
        r["payout"] = None if r.get("payout") else None
        changed = True
        break
    if changed:
        prof.setdefault("receipts", {})[proj] = recs
        save_user(prof)
        close_kb = InlineKeyboardMarkup().add(InlineKeyboardButton("‚ùå –ó–∞–∫—Ä—ã—Ç—å", callback_data="broadcast_close"))
        caption_body = format_receipt_caption(r)
        prefix = extract_receipt_prefix(c.message)
        new_caption = f"{prefix}\n{caption_body}" if prefix else caption_body
        if c.message:
            try:
                await bot.edit_message_caption(
                    c.message.chat.id,
                    c.message.message_id,
                    caption=new_caption,
                    reply_markup=close_kb
                )
            except Exception:
                try:
                    await bot.edit_message_text(
                        new_caption,
                        c.message.chat.id,
                        c.message.message_id,
                        reply_markup=close_kb,
                        disable_web_page_preview=True
                    )
                except Exception:
                    pass
        await update_all_anchors()
        await c.answer("–°—Ç–∞—Ç—É—Å –æ–±–Ω–æ–≤–ª—ë–Ω")
    else:
        await c.answer("–ù–µ –Ω–∞–π–¥–µ–Ω —á–µ–∫ –∏–ª–∏ —Å—Ç–∞—Ç—É—Å —É–∂–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω", show_alert=True)


@dp.callback_query_handler(lambda c: c.data == "check_add")
async def check_add(c: types.CallbackQuery, state: FSMContext):
    uid = c.from_user.id
    if not active_project["name"]:
        return await c.answer("‚ùó –ù–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–≥–æ –ø—Ä–æ–µ–∫—Ç–∞", show_alert=True)
    await flow_clear(uid)
    tip = await bot.send_message(
        c.message.chat.id,
        (
            "üì∏ <b>–®–∞–≥ 1 –∏–∑ 4.</b>\n"
            "–ü—Ä–∏—à–ª–∏—Ç–µ –æ–¥–∏–Ω —á—ë—Ç–∫–∏–π —Å–Ω–∏–º–æ–∫ —á–µ–∫–∞. –ü–æ—Å–ª–µ –∑–∞–≥—Ä—É–∑–∫–∏ –º—ã –ø–æ–ø—Ä–æ—Å–∏–º —É–∫–∞–∑–∞—Ç—å —Å—É–º–º—É, –æ–ø–∏—Å–∞–Ω–∏–µ –∏ —Å—Ç–∞—Ç—É—Å –æ–ø–ª–∞—Ç—ã.\n\n"
            "–ï—Å–ª–∏ –ø–µ—Ä–µ–¥—É–º–∞–ª–∏ ‚Äî –Ω–∞–∂–º–∏—Ç–µ ¬´–û—Ç–º–µ–Ω–∏—Ç—å¬ª."
        ),
        reply_markup=kb_receipt_cancel()
    )
    flow_track(uid, tip)
    await state.update_data(tmp_img=None, amount=None, photo_set=False, replace_photo=False, desc="", paid=None)
    await remember_step_prompt(state, tip)
    await ReceiptFSM.waiting_photo.set()
    await c.answer()


@dp.message_handler(commands=["cancel"], state="*")
async def cancel_any(m: types.Message, state: FSMContext):
    uid = m.from_user.id
    current_state = await state.get_state()
    if current_state and current_state.startswith(ProfileEditFSM.__name__):
        runtime = profile_runtime(uid)
        remove_keyboard = bool(runtime.pop("profile_reply_keyboard", False))
        await profile_abort(uid, state, remove_keyboard=remove_keyboard)
        try:
            await bot.delete_message(m.chat.id, m.message_id)
        except Exception:
            pass
        return
    if current_state and current_state.startswith(ReceiptFSM.__name__):
        await remove_preview_message(state)
        await clear_edit_prompt(state)
        await clear_step_prompt(state)
    await state.finish()
    try:
        await bot.delete_message(m.chat.id, m.message_id)
    except Exception:
        pass
    await flow_clear(uid)
    if current_state and current_state.startswith(PhotoFSM.__name__):
        text = (
            "üö´ <b>–ó–∞–≥—Ä—É–∑–∫–∞ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–π –ø—Ä–µ—Ä–≤–∞–Ω–∞.</b>\n"
            "–í—ã –≤—Å–µ–≥–¥–∞ –º–æ–∂–µ—Ç–µ –≤–µ—Ä–Ω—É—Ç—å—Å—è –≤ —Ä–∞–∑–¥–µ–ª ¬´üñº –§–æ—Ç–æ—Ö—Ä–æ–Ω–æ–ª–æ–≥–∏—è¬ª, —á—Ç–æ–±—ã –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å." 
        )
        await anchor_show_text(uid, text, kb_photos(uid))
    else:
        text = (
            "‚ùå <b>–î–µ–π—Å—Ç–≤–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ.</b>\n"
            "–ß—Ç–æ–±—ã –≤–æ–∑–æ–±–Ω–æ–≤–∏—Ç—å —Ä–∞–±–æ—Ç—É —Å —á–µ–∫–∞–º–∏, –æ—Ç–∫—Ä–æ–π—Ç–µ —Ä–∞–∑–¥–µ–ª ¬´üßæ –ß–µ–∫–∏¬ª –∑–∞–Ω–æ–≤–æ."
        )
        await anchor_show_text(uid, text, kb_checks(uid))


@dp.callback_query_handler(lambda c: c.data == "cancel_receipt", state="*")
async def cancel_receipt_btn(c: types.CallbackQuery, state: FSMContext):
    uid = c.from_user.id
    await remove_preview_message(state)
    await clear_edit_prompt(state)
    await clear_step_prompt(state)
    await state.finish(); await flow_clear(uid)
    await anchor_show_text(uid, tr(uid, "CHECKS_SECTION_TITLE"), kb_checks(uid))
    await c.answer("–û—Ç–º–µ–Ω–µ–Ω–æ.")


@dp.message_handler(content_types=ContentType.PHOTO, state=ReceiptFSM.waiting_photo)
async def rcp_photo(m: types.Message, state: FSMContext):
    uid = m.from_user.id
    data = await state.get_data()
    replacing = bool(data.get("replace_photo"))
    already = bool(data.get("photo_set"))
    editing = data.get("editing")

    if already and not replacing:
        warn = await bot.send_message(
            m.chat.id,
            "‚ö†Ô∏è –î–ª—è –æ–¥–Ω–æ–≥–æ —á–µ–∫–∞ –º–æ–∂–Ω–æ –ø—Ä–∏–∫—Ä–µ–ø–∏—Ç—å —Ç–æ–ª—å–∫–æ –æ–¥–∏–Ω —Å–Ω–∏–º–æ–∫. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ ¬´üñº –ó–∞–º–µ–Ω–∏—Ç—å —Ñ–æ—Ç–æ¬ª –∏–ª–∏ –∫–æ–º–∞–Ω–¥—É /cancel, —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ."
        )
        flow_track(uid, warn)
        try: await bot.delete_message(m.chat.id, m.message_id)
        except: pass
        return

    await clear_step_prompt(state)
    tmp = f"tmp_{uid}.jpg"
    await m.photo[-1].download(destination_file=tmp)
    try: await bot.delete_message(m.chat.id, m.message_id)
    except: pass

    await state.update_data(tmp_img=tmp, photo_set=True, replace_photo=False)
    if editing == "photo":
        await state.update_data(editing=None)
        await send_receipt_preview(uid, m.chat.id, state)
        await ReceiptFSM.preview.set()
        return

    if data.get("amount") is None:
        ask = await bot.send_message(
            m.chat.id,
            "üí∞ <b>–®–∞–≥ 2 –∏–∑ 4.</b> –£–∫–∞–∂–∏—Ç–µ —Å—É–º–º—É —á–µ–∫–∞ –≤ –≥—Ä–∏–≤–Ω–∞—Ö (–ø—Ä–∏–º–µ—Ä: 123.45). –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ç–æ—á–∫—É –≤ –∫–∞—á–µ—Å—Ç–≤–µ —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª—è –∫–æ–ø–µ–µ–∫.",
            reply_markup=kb_receipt_cancel(),
        )
        flow_track(uid, ask)
        await remember_step_prompt(state, ask)
        await ReceiptFSM.waiting_amount.set()
    else:
        tip = await bot.send_message(
            m.chat.id,
            "üìù –•–æ—Ç–∏—Ç–µ –¥–æ–±–∞–≤–∏—Ç—å –æ–ø–∏—Å–∞–Ω–∏–µ –∫ —á–µ–∫—É? –û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ç–µ–∫—Å—Ç –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ ¬´–ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å¬ª.",
            reply_markup=kb_desc_prompt(),
        )
        flow_track(uid, tip)
        await remember_step_prompt(state, tip)
        await ReceiptFSM.waiting_description.set()


@dp.message_handler(lambda m: m.content_type != ContentType.PHOTO, state=ReceiptFSM.waiting_photo, content_types=ContentType.ANY)
async def rcp_photo_reject(m: types.Message, state: FSMContext):
    try:
        await bot.delete_message(m.chat.id, m.message_id)
    except Exception:
        pass


@dp.message_handler(state=ReceiptFSM.waiting_amount, content_types=ContentType.TEXT)
async def rcp_amount(m: types.Message, state: FSMContext):
    uid = m.from_user.id
    txt = (m.text or "").strip().replace(",", ".")
    try: await bot.delete_message(m.chat.id, m.message_id)
    except: pass
    try:
        val = float(txt)
    except Exception:
        warn = await bot.send_message(
            m.chat.id,
            "‚ùó –ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å —Å—É–º–º—É. –í–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ –≤ —Ñ–æ—Ä–º–∞—Ç–µ 123.45 ‚Äî —Ç–æ—á–∫–∞ –æ—Ç–¥–µ–ª—è–µ—Ç –≥—Ä–∏–≤–Ω—ã –æ—Ç –∫–æ–ø–µ–µ–∫."
        )
        flow_track(uid, warn); return

    data = await state.get_data()
    editing = data.get("editing")
    tmp = data.get("tmp_img")
    if not tmp:
        warn = await bot.send_message(
            m.chat.id,
            "‚ö†Ô∏è –°–Ω–∞—á–∞–ª–∞ –∑–∞–≥—Ä—É–∑–∏—Ç–µ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏—é —á–µ–∫–∞ ‚Äî –±–µ–∑ –Ω–µ—ë –º—ã –Ω–µ —Å–º–æ–∂–µ–º —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –∑–∞–ø–∏—Å—å."
        )
        flow_track(uid, warn); return
    await state.update_data(amount=val)
    await clear_step_prompt(state)
    if editing == "amount":
        await state.update_data(editing=None)
        await send_receipt_preview(uid, m.chat.id, state)
        await ReceiptFSM.preview.set()
        return
    tip = await bot.send_message(
        m.chat.id,
        "üìù <b>–®–∞–≥ 3 –∏–∑ 4.</b> –î–æ–±–∞–≤—å—Ç–µ –∫—Ä–∞—Ç–∫–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ (–Ω–∞–ø—Ä–∏–º–µ—Ä, —Ü–µ–ª—å –ø–æ–∫—É–ø–∫–∏) –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ ¬´–ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å¬ª.",
        reply_markup=kb_desc_prompt(),
    )
    flow_track(uid, tip)
    await remember_step_prompt(state, tip)
    await ReceiptFSM.waiting_description.set()


@dp.callback_query_handler(lambda c: c.data == "desc_skip", state=ReceiptFSM.waiting_description)
async def desc_skip(c: types.CallbackQuery, state: FSMContext):
    await clear_step_prompt(state)
    await state.update_data(desc="")
    kb = kb_choose_paid(ask_later=True, flow_cancel=True)
    msg = await bot.send_message(
        c.message.chat.id,
        "üîñ <b>–®–∞–≥ 4 –∏–∑ 4.</b> –£–∫–∞–∂–∏—Ç–µ —Å—Ç–∞—Ç—É—Å –æ–ø–ª–∞—Ç—ã –¥–ª—è —ç—Ç–æ–≥–æ —á–µ–∫–∞.",
        reply_markup=kb
    )
    flow_track(c.from_user.id, msg)
    await remember_step_prompt(state, msg)
    await ReceiptFSM.waiting_paid_choice.set()
    await c.answer()


@dp.message_handler(state=ReceiptFSM.waiting_description, content_types=ContentType.TEXT)
async def rcp_desc(m: types.Message, state: FSMContext):
    uid = m.from_user.id
    desc = (m.text or "").strip()
    try: await bot.delete_message(m.chat.id, m.message_id)
    except: pass
    data = await state.get_data()
    editing = data.get("editing")
    await state.update_data(desc=desc)
    await clear_step_prompt(state)
    if editing == "desc":
        await state.update_data(editing=None)
        await send_receipt_preview(uid, m.chat.id, state)
        await ReceiptFSM.preview.set()
        return
    kb = kb_choose_paid(ask_later=True, flow_cancel=True)
    msg = await bot.send_message(
        m.chat.id,
        "üîñ <b>–®–∞–≥ 4 –∏–∑ 4.</b> –í—ã–±–µ—Ä–∏—Ç–µ —Å—Ç–∞—Ç—É—Å –æ–ø–ª–∞—Ç—ã –¥–ª—è —ç—Ç–æ–≥–æ —á–µ–∫–∞.",
        reply_markup=kb
    )
    flow_track(uid, msg)
    await remember_step_prompt(state, msg)
    await ReceiptFSM.waiting_paid_choice.set()


@dp.callback_query_handler(lambda c: c.data == "edit_cancel", state=[ReceiptFSM.waiting_amount, ReceiptFSM.waiting_description, ReceiptFSM.waiting_photo])
async def edit_cancel_action(c: types.CallbackQuery, state: FSMContext):
    uid = c.from_user.id
    await clear_edit_prompt(state)
    await state.update_data(editing=None, replace_photo=False)
    await send_receipt_preview(uid, c.message.chat.id, state)
    await ReceiptFSM.preview.set()
    await c.answer("–û—Ç–º–µ–Ω–µ–Ω–æ")


@dp.callback_query_handler(lambda c: c.data in ("paid_yes","paid_no","paid_later"), state=ReceiptFSM.waiting_paid_choice)
async def paid_choice(c: types.CallbackQuery, state: FSMContext):
    uid = c.from_user.id
    data = await state.get_data()
    paid = None
    if c.data == "paid_yes": paid = True
    elif c.data == "paid_no": paid = False
    await clear_step_prompt(state)
    await state.update_data(paid=paid)
    await send_receipt_preview(uid, c.message.chat.id, state)
    await ReceiptFSM.preview.set()
    await c.answer()


@dp.callback_query_handler(lambda c: c.data in ("edit_amount", "edit_photo", "edit_desc", "edit_paid", "save_receipt", "cancel_receipt"), state=ReceiptFSM.preview)
async def rcp_preview_actions(c: types.CallbackQuery, state: FSMContext):
    uid = c.from_user.id
    data = await state.get_data()

    if c.data == "edit_amount":
        await clear_edit_prompt(state)
        await state.update_data(editing="amount")
        msg = await bot.send_message(
            c.message.chat.id,
            "‚úèÔ∏è –£–∫–∞–∂–∏—Ç–µ –Ω–æ–≤—É—é —Å—É–º–º—É –¥–ª—è —á–µ–∫–∞ (–ø—Ä–∏–º–µ—Ä: 123.45).",
            reply_markup=kb_edit_cancel()
        )
        flow_track(uid, msg)
        await state.update_data(edit_prompt=(c.message.chat.id, msg.message_id))
        await ReceiptFSM.waiting_amount.set()
        return await c.answer()

    if c.data == "edit_photo":
        await clear_edit_prompt(state)
        await state.update_data(replace_photo=True, photo_set=False, editing="photo")
        msg = await bot.send_message(
            c.message.chat.id,
            "üñº –ü—Ä–∏—à–ª–∏—Ç–µ –æ–±–Ω–æ–≤–ª—ë–Ω–Ω–æ–µ —Ñ–æ—Ç–æ —á–µ–∫–∞.",
            reply_markup=kb_edit_cancel()
        )
        flow_track(uid, msg)
        await state.update_data(edit_prompt=(c.message.chat.id, msg.message_id))
        await ReceiptFSM.waiting_photo.set()
        return await c.answer()

    if c.data == "edit_desc":
        await clear_edit_prompt(state)
        await state.update_data(editing="desc")
        msg = await bot.send_message(
            c.message.chat.id,
            "üìù –í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è —ç—Ç–æ–≥–æ —á–µ–∫–∞.",
            reply_markup=kb_edit_cancel()
        )
        flow_track(uid, msg)
        await state.update_data(edit_prompt=(c.message.chat.id, msg.message_id))
        await ReceiptFSM.waiting_description.set()
        return await c.answer()

    if c.data == "edit_paid":
        await clear_edit_prompt(state)
        kb = kb_choose_paid(ask_later=True, allow_cancel=True)
        msg = await bot.send_message(
            c.message.chat.id,
            "üîñ –û–±–Ω–æ–≤–∏—Ç–µ —Å—Ç–∞—Ç—É—Å –æ–ø–ª–∞—Ç—ã –¥–ª—è —á–µ–∫–∞ —Å –ø–æ–º–æ—â—å—é –∫–Ω–æ–ø–æ–∫ –Ω–∏–∂–µ.",
            reply_markup=kb
        )
        flow_track(uid, msg)
        await remember_step_prompt(state, msg)
        await ReceiptFSM.waiting_paid_choice.set()
        return await c.answer()

    if c.data == "cancel_receipt":
        await remove_preview_message(state)
        await clear_edit_prompt(state)
        await flow_clear(uid); await state.finish()
        await anchor_show_text(uid, tr(uid, "CHECKS_SECTION_TITLE"), kb_checks(uid))
        return await c.answer("–û—Ç–º–µ–Ω–µ–Ω–æ.")

    if c.data == "save_receipt":
        proj = active_project["name"]
        if not proj:
            await c.answer("‚ùó –ù–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–≥–æ –ø—Ä–æ–µ–∫—Ç–∞", show_alert=True); return
        if not data.get("tmp_img") or data.get("amount") is None:
            await c.answer("‚ö†Ô∏è –ù–µ —Ö–≤–∞—Ç–∞–µ—Ç –¥–∞–Ω–Ω—ã—Ö (—Ñ–æ—Ç–æ/—Å—É–º–º–∞).", show_alert=True); return
        fname, path, now, rid = save_receipt(proj, uid, float(data["amount"]), data.get("tmp_img"), data.get("desc",""), data.get("paid"))
        await remove_preview_message(state)
        await clear_edit_prompt(state)
        await clear_step_prompt(state)
        await flow_clear(uid)
        await state.finish()
        status_txt = receipt_status_text(data.get('paid'))
        desc_value = data.get('desc')
        desc_text = h(desc_value) if desc_value else "‚Äî"
        caption = (
            "‚úÖ –ß–µ–∫ —Å–æ—Ö—Ä–∞–Ω—ë–Ω!\n"
            "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
            f"üìÇ –ü—Ä–æ–µ–∫—Ç: <b>{h(proj)}</b>\n"
            f"üÜî –ù–æ–º–µ—Ä: <b>{h(rid)}</b>\n"
            f"üìÖ –î–∞—Ç–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è: {now.strftime('%Y-%m-%d %H:%M')}\n"
            f"üí∞ –°—É–º–º–∞: {fmt_money(float(data['amount']))} –≥—Ä–Ω\n"
            f"üìù –û–ø–∏—Å–∞–Ω–∏–µ: {desc_text}\n"
            f"üîñ –°—Ç–∞—Ç—É—Å: {status_txt}\n"
            f"üìÑ –§–∞–π–ª: {h(fname)}\n\n"
            "–ö–∞—Ä—Ç–æ—á–∫–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ –≤ —Ä–∞–∑–¥–µ–ª–µ ¬´üìÅ –ú–æ–∏ —á–µ–∫–∏¬ª. –ù–∞–∂–º–∏—Ç–µ ¬´–ó–∞–∫—Ä—ã—Ç—å¬ª, –∫–æ–≥–¥–∞ –æ–∑–Ω–∞–∫–æ–º–∏—Ç–µ—Å—å."
        )
        await bot.send_photo(c.message.chat.id, InputFile(path), caption=caption, reply_markup=kb_saved_receipt())
        await anchor_show_text(uid, tr(uid, "CHECKS_SECTION_TITLE"), kb_checks(uid))
        return await c.answer("–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ.")


# ========================== PHOTO TIMELINE ==========================
@dp.callback_query_handler(lambda c: c.data == "menu_photos")
async def menu_photos(c: types.CallbackQuery):
    uid = c.from_user.id
    if not active_project["name"]:
        return await c.answer("‚ùó –ù–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–≥–æ –ø—Ä–æ–µ–∫—Ç–∞", show_alert=True)
    info = load_project_info(active_project["name"])
    text = (
        "üñº <b>–§–æ—Ç–æ—Ö—Ä–æ–Ω–æ–ª–æ–≥–∏—è –æ–±—ä–µ–∫—Ç–∞</b>\n"
        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
        f"üìÇ –ü—Ä–æ–µ–∫—Ç: <b>{h(info.get('name', '‚Äî'))}</b>\n"
        f"üÜî –ö–æ–¥ –æ–±—ä–µ–∫—Ç–∞: {h(info.get('code') or '‚Äî')}\n\n"
        "–ó–¥–µ—Å—å —Ö—Ä–∞–Ω–∏—Ç—Å—è –≤–∏–∑—É–∞–ª—å–Ω–∞—è –∏—Å—Ç–æ—Ä–∏—è —Ä–∞–±–æ—Ç: –∑–∞–≥—Ä—É–∂–∞–π—Ç–µ –Ω–æ–≤—ã–µ —Ñ–æ—Ç–æ –∏–ª–∏ –ø—Ä–æ—Å–º–∞—Ç—Ä–∏–≤–∞–π—Ç–µ –∞—Ä—Ö–∏–≤–Ω—ã–µ —Å–Ω–∏–º–∫–∏.\n"
        "–í –∞—Ä—Ö–∏–≤–µ –º–æ–∂–Ω–æ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –æ—Ä–∏–≥–∏–Ω–∞–ª —Ñ–∞–π–ª–∞ –∏ —É–¥–∞–ª–∏—Ç—å —Å–≤–æ–∏ —Å–Ω–∏–º–∫–∏ –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏."
    )
    await clear_then_anchor(uid, text, kb_photos(uid))
    await c.answer()


@dp.callback_query_handler(lambda c: c.data == "photo_upload")
async def photo_upload(c: types.CallbackQuery, state: FSMContext):
    uid = c.from_user.id
    if not active_project["name"]:
        return await c.answer("‚ùó –ù–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–≥–æ –ø—Ä–æ–µ–∫—Ç–∞", show_alert=True)
    project = active_project["name"]
    info = load_project_info(project)
    await flow_clear(uid)
    await state.finish()
    await state.update_data(photo_project=project, uploaded=[], photo_session_message=None)
    await _photo_refresh_session_message(c.message.chat.id, uid, state, info, [])
    await PhotoFSM.collecting.set()
    await c.answer()


def _detect_extension(name: str, fallback: str = ".jpg") -> str:
    ext = (os.path.splitext(name)[1] or "").lower()
    if not ext:
        return fallback
    return ext


def _should_send_as_photo(ext: str) -> bool:
    return ext.lower() in {".jpg", ".jpeg", ".png", ".webp"}


@dp.message_handler(state=PhotoFSM.collecting, content_types=[ContentType.PHOTO, ContentType.DOCUMENT])
async def photo_collect_media(m: types.Message, state: FSMContext):
    uid = m.from_user.id
    data = await state.get_data()
    project = data.get("photo_project")
    if not project:
        await state.finish()
        return
    info = load_project_info(project)
    prof = load_user(uid) or {"fullname": f"User{uid}", "bsu": "‚Äî"}
    now = datetime.now()

    if m.content_type == ContentType.PHOTO:
        original_name = f"photo_{now.strftime('%Y%m%d_%H%M%S')}.jpg"
        ext = ".jpg"
        file_obj = m.photo[-1]
    else:
        doc = m.document
        original_name = doc.file_name or f"file_{now.strftime('%Y%m%d_%H%M%S')}"
        ext = _detect_extension(original_name, fallback=".jpg")
        if ext.lower() not in ALLOWED_IMAGE_EXTENSIONS:
            warn = await bot.send_message(
                m.chat.id,
                "‚ö†Ô∏è –ú–æ–∂–Ω–æ –∑–∞–≥—Ä—É–∂–∞—Ç—å —Ç–æ–ª—å–∫–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è (JPG, PNG, WEBP, BMP, TIF, HEIC).",
                reply_markup=InlineKeyboardMarkup().add(InlineKeyboardButton("‚ùå –ó–∞–∫—Ä—ã—Ç—å", callback_data="broadcast_close"))
            )
            flow_track(uid, warn)
            try:
                await bot.delete_message(m.chat.id, m.message_id)
            except Exception:
                pass
            return
        file_obj = doc

    base_name = os.path.splitext(original_name)[0]
    safe_original = _sanitize_filename(base_name) or f"photo_{now.strftime('%Y%m%d_%H%M%S')}"
    safe_user = _sanitize_filename(prof.get("fullname") or f"User{uid}")
    project_code = info.get("code") or project
    prefix = f"{project_code}_{safe_original}_UID{uid}"
    if safe_user:
        prefix += f"_{safe_user}"
    filename = f"{prefix}{ext.lower()}"
    target_dir = proj_photos_dir(project)
    os.makedirs(target_dir, exist_ok=True)
    counter = 1
    while os.path.exists(os.path.join(target_dir, filename)):
        filename = f"{prefix}_{counter}{ext.lower()}"
        counter += 1
    dst_path = os.path.join(target_dir, filename)

    try:
        if m.content_type == ContentType.PHOTO:
            await file_obj.download(destination_file=dst_path)
        else:
            await file_obj.download(destination_file=dst_path)
        try:
            await bot.delete_message(m.chat.id, m.message_id)
        except Exception:
            pass
    except Exception as exc:
        warn = await bot.send_message(
            m.chat.id,
            "‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ñ–∞–π–ª. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑ –∏–ª–∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –¥—Ä—É–≥–æ–π —Ñ–æ—Ä–º–∞—Ç.",
            reply_markup=InlineKeyboardMarkup().add(InlineKeyboardButton("‚ùå –ó–∞–∫—Ä—ã—Ç—å", callback_data="broadcast_close"))
        )
        flow_track(uid, warn)
        return

    metadata = extract_image_metadata(dst_path)
    entry = {
        "id": generate_photo_id(),
        "file": filename,
        "original": original_name,
        "uploaded_at": now.isoformat(),
        "uploader_id": uid,
        "uploader_name": prof.get("fullname", "‚Äî"),
        "uploader_bsu": prof.get("bsu", "‚Äî"),
        "meta": metadata,
    }
    photos = load_project_photos(project)
    photos.append(entry)
    save_project_photos(project, photos)

    uploaded = list(data.get("uploaded") or [])
    uploaded.append(entry)
    await state.update_data(uploaded=uploaded)
    await _photo_refresh_session_message(m.chat.id, uid, state, info, uploaded, entry)
    await update_all_anchors()


@dp.message_handler(state=PhotoFSM.collecting, content_types=ContentType.TEXT)
async def photo_collect_text(m: types.Message, state: FSMContext):
    uid = m.from_user.id
    data = await state.get_data()
    uploaded = data.get("uploaded") or []
    try:
        await bot.delete_message(m.chat.id, m.message_id)
    except Exception:
        pass
    hint = await bot.send_message(
        m.chat.id,
        "‚ÑπÔ∏è –û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏—é –∏–ª–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –¥–æ–∫—É–º–µ–Ω—Ç–æ–º. –ö–æ–≥–¥–∞ –∑–∞–∫–æ–Ω—á–∏—Ç–µ, –Ω–∞–∂–º–∏—Ç–µ ¬´‚úÖ –ó–∞–≤–µ—Ä—à–∏—Ç—å –∑–∞–≥—Ä—É–∑–∫—É¬ª.",
        reply_markup=kb_photo_session_controls(bool(uploaded))
    )
    flow_track(uid, hint)


@dp.callback_query_handler(lambda c: c.data == "photo_session_preview", state=PhotoFSM.collecting)
async def photo_session_preview(c: types.CallbackQuery, state: FSMContext):
    uid = c.from_user.id
    data = await state.get_data()
    uploaded = data.get("uploaded") or []
    if not uploaded:
        return await c.answer("–ü–æ–∫–∞ –Ω–µ—Ç –∑–∞–≥—Ä—É–∂–µ–Ω–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤", show_alert=True)
    project = data.get("photo_project")
    if not project:
        return await c.answer("–ü—Ä–æ–µ–∫—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω", show_alert=True)
    await c.answer("–û—Ç–ø—Ä–∞–≤–ª—è—é —Ñ–∞–π–ª—ã‚Ä¶")
    header = await bot.send_message(
        c.message.chat.id,
        f"üóÇ <b>–ó–∞–≥—Ä—É–∂–µ–Ω–Ω—ã–µ –≤ —ç—Ç–æ–π —Å–µ—Å—Å–∏–∏</b>\n–í—Å–µ–≥–æ —Ñ–∞–π–ª–æ–≤: <b>{len(uploaded)}</b>.",
        reply_markup=InlineKeyboardMarkup().add(InlineKeyboardButton("‚ùå –ó–∞–∫—Ä—ã—Ç—å", callback_data="broadcast_close"))
    )
    flow_track(uid, header)
    base_dir = proj_photos_dir(project)
    for entry in uploaded:
        stored = entry.get("file") or ""
        original = entry.get("original") or stored
        if not stored:
            warn = await bot.send_message(
                c.message.chat.id,
                f"‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Ñ–∞–π–ª –¥–ª—è {h(original)}.",
                reply_markup=InlineKeyboardMarkup().add(InlineKeyboardButton("‚ùå –ó–∞–∫—Ä—ã—Ç—å", callback_data="broadcast_close"))
            )
            flow_track(uid, warn)
            continue
        path = os.path.join(base_dir, stored)
        if not os.path.exists(path):
            warn = await bot.send_message(
                c.message.chat.id,
                f"‚ö†Ô∏è –§–∞–π–ª {h(stored)} –Ω–µ –Ω–∞–π–¥–µ–Ω –Ω–∞ –¥–∏—Å–∫–µ.",
                reply_markup=InlineKeyboardMarkup().add(InlineKeyboardButton("‚ùå –ó–∞–∫—Ä—ã—Ç—å", callback_data="broadcast_close"))
            )
            flow_track(uid, warn)
            continue
        caption = f"üìÅ {h(original)}"
        kb = InlineKeyboardMarkup().add(InlineKeyboardButton("‚ùå –ó–∞–∫—Ä—ã—Ç—å", callback_data="broadcast_close"))
        try:
            ext = os.path.splitext(stored)[1].lower()
            file_input = InputFile(path)
            if _should_send_as_photo(ext):
                msg = await bot.send_photo(c.message.chat.id, file_input, caption=caption, reply_markup=kb)
            else:
                msg = await bot.send_document(c.message.chat.id, file_input, caption=caption, reply_markup=kb)
            flow_track(uid, msg)
        except Exception:
            warn = await bot.send_message(
                c.message.chat.id,
                f"‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å {h(original)}.",
                reply_markup=InlineKeyboardMarkup().add(InlineKeyboardButton("‚ùå –ó–∞–∫—Ä—ã—Ç—å", callback_data="broadcast_close"))
            )
            flow_track(uid, warn)


@dp.callback_query_handler(lambda c: c.data == "photo_finish", state=PhotoFSM.collecting)
async def photo_finish(c: types.CallbackQuery, state: FSMContext):
    uid = c.from_user.id
    data = await state.get_data()
    uploaded = data.get("uploaded") or []
    await state.finish()
    summary = (
        "üñº <b>–§–æ—Ç–æ—Å–µ—Å—Å–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞</b>\n"
        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
        f"–î–æ–±–∞–≤–ª–µ–Ω–æ —Ñ–∞–π–ª–æ–≤: <b>{len(uploaded)}</b>.\n"
        "–ê—Ä—Ö–∏–≤ –º–æ–∂–Ω–æ –æ—Ç–∫—Ä—ã—Ç—å —á–µ—Ä–µ–∑ ¬´üñº –ü—Ä–æ—Å–º–æ—Ç—Ä–µ—Ç—å —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏ –æ–±—ä–µ–∫—Ç–∞¬ª.\n"
        "–ü—Ä–∏ –ø—Ä–æ—Å–º–æ—Ç—Ä–µ –≤—ã –º–æ–∂–µ—Ç–µ —É–¥–∞–ª–∏—Ç—å —Å–≤–æ–∏ —Å–Ω–∏–º–∫–∏ –∏–ª–∏ –∑–∞–ø—Ä–æ—Å–∏—Ç—å –æ—Ä–∏–≥–∏–Ω–∞–ª—ã –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏."
    )
    await clear_then_anchor(uid, summary, kb_photos(uid))
    await c.answer("–ì–æ—Ç–æ–≤–æ")


@dp.callback_query_handler(lambda c: c.data == "photo_cancel", state=PhotoFSM.collecting)
async def photo_cancel(c: types.CallbackQuery, state: FSMContext):
    uid = c.from_user.id
    data = await state.get_data()
    uploaded = len(data.get("uploaded") or [])
    await state.finish()
    note = (
        "üö´ <b>–ó–∞–≥—Ä—É–∑–∫–∞ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞</b>\n"
        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
        "–ù–æ–≤—ã–µ —Ñ–∞–π–ª—ã –±–æ–ª—å—à–µ –Ω–µ –ø—Ä–∏–Ω–∏–º–∞—é—Ç—Å—è."
    )
    if uploaded:
        note += f"\n–£–∂–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ: <b>{uploaded}</b>."
    await clear_then_anchor(uid, note, kb_photos(uid))
    await c.answer("–û—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ")


@dp.callback_query_handler(lambda c: c.data == "photo_view")
async def photo_view(c: types.CallbackQuery):
    uid = c.from_user.id
    if not active_project["name"]:
        return await c.answer("‚ùó –ù–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–≥–æ –ø—Ä–æ–µ–∫—Ç–∞", show_alert=True)
    project = active_project["name"]
    info = load_project_info(project)
    photos = load_project_photos(project)
    if not photos:
        text = (
            "üñº <b>–§–æ—Ç–æ—Ö—Ä–æ–Ω–æ–ª–æ–≥–∏—è</b>\n"
            "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
            "–î–ª—è —ç—Ç–æ–≥–æ –ø—Ä–æ–µ–∫—Ç–∞ –µ—â—ë –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω–æ –Ω–∏ –æ–¥–Ω–æ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
        )
        await clear_then_anchor(uid, text, kb_photos(uid))
        await c.answer()
        return

    header = (
        "üñº <b>–ê—Ä—Ö–∏–≤ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–π</b>\n"
        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
        f"üìÇ –ü—Ä–æ–µ–∫—Ç: <b>{h(info.get('name', '‚Äî'))}</b> ({h(info.get('code') or '‚Äî')})\n"
        f"üì∏ –í—Å–µ–≥–æ —Å–Ω–∏–º–∫–æ–≤: <b>{len(photos)}</b>."
    )
    await clear_then_anchor(uid, header, kb_photos(uid))

    for entry in photos:
        stored = entry.get("file") or ""
        path = os.path.join(proj_photos_dir(project), stored) if stored else ""
        file_exists = bool(stored and os.path.exists(path))
        caption = format_photo_caption(info, entry)
        kb = photo_entry_keyboard(project, entry, uid, file_exists=file_exists)
        if file_exists:
            ext = os.path.splitext(stored)[1].lower()
            try:
                if _should_send_as_photo(ext):
                    msg = await bot.send_photo(c.message.chat.id, InputFile(path), caption=caption, reply_markup=kb)
                else:
                    msg = await bot.send_document(c.message.chat.id, InputFile(path), caption=caption, reply_markup=kb)
                flow_track(uid, msg)
                continue
            except Exception:
                file_exists = False
                kb = photo_entry_keyboard(project, entry, uid, file_exists=False)
        fallback_text = caption + "\n\n‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–æ–±—Ä–∞–∑–∏—Ç—å —Ñ–∞–π–ª –≤ Telegram, –Ω–æ –∑–∞–ø–∏—Å—å –æ—Å—Ç–∞—ë—Ç—Å—è –≤ –∞—Ä—Ö–∏–≤–µ."
        warn = await bot.send_message(c.message.chat.id, fallback_text, reply_markup=kb)
        flow_track(uid, warn)
    footer = (
        "üìÅ <b>–ü—Ä–æ—Å–º–æ—Ç—Ä –∞—Ä—Ö–∏–≤–∞ –∑–∞–≤–µ—Ä—à—ë–Ω</b>\n"
        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
        "–í—ã–±–µ—Ä–∏—Ç–µ –¥–∞–ª—å–Ω–µ–π—à–µ–µ –¥–µ–π—Å—Ç–≤–∏–µ —Å –ø–æ–º–æ—â—å—é –∫–Ω–æ–ø–æ–∫ –Ω–∏–∂–µ."
    )
    tail = await bot.send_message(c.message.chat.id, footer, reply_markup=kb_photo_view_actions())
    flow_track(uid, tail)
    await c.answer()


@dp.callback_query_handler(lambda c: c.data in {"photo_view_close", "photo_view_root", "photo_view_menu"})
async def photo_view_controls(c: types.CallbackQuery):
    uid = c.from_user.id
    action = c.data
    if action == "photo_view_menu":
        await menu_photos(c)
        return
    if action == "photo_view_root":
        await c.answer("–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é –æ—Ç–∫—Ä—ã—Ç–æ")
        await flow_clear(uid)
        await anchor_show_root(uid)
    else:
        await c.answer("–ü—Ä–æ—Å–º–æ—Ç—Ä –∑–∞–∫—Ä—ã—Ç")
        await flow_clear(uid)


@dp.callback_query_handler(lambda c: c.data.startswith("photo_original:"))
async def photo_send_original(c: types.CallbackQuery):
    uid = c.from_user.id
    parts = c.data.split(":", 2)
    if len(parts) != 3:
        return await c.answer("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –∑–∞–ø—Ä–æ—Å", show_alert=True)
    _, token, entry_id = parts
    project = project_from_token(token)
    if not project:
        return await c.answer("–ü—Ä–æ–µ–∫—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω", show_alert=True)
    _, entry, _ = find_photo_entry(project, entry_id)
    if not entry:
        return await c.answer("–§–æ—Ç–æ–≥—Ä–∞—Ñ–∏—è —É–∂–µ —É–¥–∞–ª–µ–Ω–∞.", show_alert=True)
    file_name = entry.get("file")
    if not file_name:
        return await c.answer("–û—Ä–∏–≥–∏–Ω–∞–ª –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç", show_alert=True)
    path = os.path.join(proj_photos_dir(project), file_name)
    if not os.path.exists(path):
        return await c.answer("–§–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω", show_alert=True)
    original_name = entry.get("original") or os.path.basename(path)
    try:
        msg = await bot.send_document(
            c.message.chat.id,
            InputFile(path, filename=original_name),
            caption=f"üì§ –û—Ä–∏–≥–∏–Ω–∞–ª: {h(original_name)}",
            reply_markup=InlineKeyboardMarkup().add(InlineKeyboardButton("‚ùå –ó–∞–∫—Ä—ã—Ç—å", callback_data="broadcast_close"))
        )
        flow_track(uid, msg)
        await c.answer("–û—Ä–∏–≥–∏–Ω–∞–ª –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω")
    except Exception:
        await c.answer("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Ñ–∞–π–ª", show_alert=True)


@dp.callback_query_handler(lambda c: c.data.startswith("photo_delete:"))
async def photo_delete(c: types.CallbackQuery):
    uid = c.from_user.id
    parts = c.data.split(":", 2)
    if len(parts) != 3:
        return await c.answer("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –∑–∞–ø—Ä–æ—Å", show_alert=True)
    _, token, entry_id = parts
    project = project_from_token(token)
    if not project:
        return await c.answer("–ü—Ä–æ–µ–∫—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω", show_alert=True)
    index, entry, photos = find_photo_entry(project, entry_id)
    if entry is None or index < 0:
        return await c.answer("–§–æ—Ç–æ–≥—Ä–∞—Ñ–∏—è —É–∂–µ —É–¥–∞–ª–µ–Ω–∞", show_alert=True)
    uploader_id = entry.get("uploader_id")
    if uid not in admins and uid != uploader_id:
        return await c.answer("–£–¥–∞–ª–µ–Ω–∏–µ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ", show_alert=True)

    file_name = entry.get("file")
    if file_name:
        path = os.path.join(proj_photos_dir(project), file_name)
        if os.path.exists(path):
            try:
                os.remove(path)
            except Exception:
                pass

    photos.pop(index)
    save_project_photos(project, photos)

    try:
        await bot.delete_message(c.message.chat.id, c.message.message_id)
    except Exception:
        pass

    await c.answer("–§–æ—Ç–æ–≥—Ä–∞—Ñ–∏—è —É–¥–∞–ª–µ–Ω–∞")
    await update_all_anchors()

    if uploader_id and uploader_id != uid:
        uploader_profile = load_user(uploader_id) or {}
        notify_chat = (
            users_runtime.get(uploader_id, {}).get("tg", {}).get("chat_id")
            or uploader_profile.get("tg", {}).get("chat_id")
        )
        if notify_chat:
            actor_profile = load_user(uid) or {}
            actor_name = actor_profile.get("fullname") or actor_profile.get("tg", {}).get("first_name") or f"ID {uid}"
            info = load_project_info(project)
            note = (
                "üóë <b>–§–æ—Ç–æ —É–¥–∞–ª–µ–Ω–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º</b>\n"
                "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
                f"üìÇ –ü—Ä–æ–µ–∫—Ç: <b>{h(info.get('name', '‚Äî'))}</b> ({h(info.get('code') or '‚Äî')})\n"
                f"üìõ –û—Ä–∏–≥–∏–Ω–∞–ª: {h(entry.get('original') or entry.get('file') or '‚Äî')}\n"
                f"–£–¥–∞–ª–∏–ª: {h(actor_name)} (ID {uid})"
            )
            kb = InlineKeyboardMarkup().add(InlineKeyboardButton("‚ùå –ó–∞–∫—Ä—ã—Ç—å", callback_data="broadcast_close"))
            try:
                msg = await bot.send_message(notify_chat, note, reply_markup=kb)
                flow_track(uploader_id, msg)
            except Exception:
                pass


# ========================== DOCUMENTS ==========================
@dp.callback_query_handler(lambda c: c.data == "menu_docs")
async def menu_docs(c: types.CallbackQuery):
    uid = c.from_user.id
    if not active_project["name"]:
        return await c.answer("‚ùó –ù–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–≥–æ –ø—Ä–æ–µ–∫—Ç–∞", show_alert=True)
    proj = active_project["name"]
    folder = proj_pdf_dir(proj)
    pdfs = [f for f in os.listdir(folder) if f.lower().endswith(".pdf")] if os.path.exists(folder) else []
    if not pdfs:
        await clear_then_anchor(
            uid,
            f"üìë –î–æ–∫—É–º–µ–Ω—Ç—ã –ø—Ä–æ–µ–∫—Ç–∞ <b>{h(proj)}</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n–ü–æ–∫–∞ –Ω–µ—Ç –∑–∞–≥—Ä—É–∂–µ–Ω–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤. –û–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É, –µ—Å–ª–∏ –æ–∂–∏–¥–∞–µ—Ç–µ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—é.",
            kb=InlineKeyboardMarkup().add(InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞ –≥–ª–∞–≤–Ω—É—é", callback_data="back_root"))
        )
        return await c.answer()
    await clear_then_anchor(
        uid,
        f"üìë –î–æ–∫—É–º–µ–Ω—Ç—ã –ø—Ä–æ–µ–∫—Ç–∞ <b>{h(proj)}</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n–î–æ—Å—Ç—É–ø–Ω–æ —Ñ–∞–π–ª–æ–≤: <b>{len(pdfs)}</b>. –û—Ç–∫—Ä–æ–π—Ç–µ –Ω—É–∂–Ω—ã–π –¥–æ–∫—É–º–µ–Ω—Ç –∏–∑ —Å–ø–∏—Å–∫–∞ –Ω–∏–∂–µ.",
        kb=InlineKeyboardMarkup().add(InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞ –≥–ª–∞–≤–Ω—É—é", callback_data="back_root"))
    )
    for f in pdfs[:10]:
        p = os.path.join(folder, f)
        if os.path.exists(p):
            msg = await bot.send_document(c.message.chat.id, InputFile(p), caption=h(f))
            flow_track(uid, msg)
    await c.answer()


# ========================== FINANCE (USER) ==========================
def user_has_approved_not_confirmed(uid: int) -> bool:
    prof = load_user(uid) or {}
    for ref in iter_user_payout_refs(prof):
        obj = finance_load_request(ref.get("id"), ref.get("project"))
        if obj and obj.get("status") == "approved" and obj.get("user_id") == uid:
            return True
    return False


@dp.callback_query_handler(lambda c: c.data == "menu_finance")
async def finance_menu(c: types.CallbackQuery):
    uid = c.from_user.id
    if not active_project["name"]:
        return await c.answer("‚ùó –ù–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–≥–æ –ø—Ä–æ–µ–∫—Ç–∞", show_alert=True)
    proj = active_project["name"]
    stats = user_project_stats(uid, proj)
    lines = [
        "üíµ <b>–§–∏–Ω–∞–Ω—Å–æ–≤—ã–π —Ä–∞–∑–¥–µ–ª</b>",
        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ",
        f"üìÇ –ü—Ä–æ–µ–∫—Ç: <b>{h(proj)}</b>",
        f"üßæ –ó–∞–≥—Ä—É–∂–µ–Ω–æ —á–µ–∫–æ–≤: <b>{stats['count']}</b>",
        f"üí∞ –û–±—â–∞—è —Å—É–º–º–∞: <b>{fmt_money(stats['total'])} –≥—Ä–Ω</b>",
        f"‚úÖ –û–ø–ª–∞—á–µ–Ω–æ —Ñ–∏—Ä–º–æ–π: <b>{fmt_money(stats['paid'])} –≥—Ä–Ω</b>",
        f"‚ùå –û–∂–∏–¥–∞–µ—Ç –æ–ø–ª–∞—Ç—ã: <b>{fmt_money(stats['unpaid'])} –≥—Ä–Ω</b>"
    ]
    if stats["pending"]:
        lines.append(f"‚è≥ –£–∂–µ –≤ –∑–∞–ø—Ä–æ—Å–∞—Ö: <b>{fmt_money(stats['pending'])} –≥—Ä–Ω</b>")
    if stats["unspecified"]:
        lines.append(f"‚ùî –ë–µ–∑ —Å—Ç–∞—Ç—É—Å–∞ –æ–ø–ª–∞—Ç—ã: <b>{fmt_money(stats['unspecified'])} –≥—Ä–Ω</b>")
    alerts: List[str] = []
    active_req = finance_active_request_for_user(uid, proj)
    if active_req:
        status = active_req.get("status")
        status_human = {"pending": "–æ–∂–∏–¥–∞–µ—Ç –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è", "approved": "–æ–¥–æ–±—Ä–µ–Ω–∞"}.get(status, status or "–≤ –æ–±—Ä–∞–±–æ—Ç–∫–µ")
        code = active_req.get("code", active_req.get("id"))
        alerts.append(f"üì® –ê–∫—Ç–∏–≤–Ω—ã–π –∑–∞–ø—Ä–æ—Å: <b>{h(code)}</b> ‚Äî {h(status_human)}")
    if user_has_approved_not_confirmed(uid):
        alerts.insert(0, "‚ö†Ô∏è –ï—Å—Ç—å –æ–¥–æ–±—Ä–µ–Ω–Ω—ã–µ –≤—ã–ø–ª–∞—Ç—ã. –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ –ø–æ–ª—É—á–µ–Ω–∏–µ –¥–µ–Ω–µ–≥ —á–µ—Ä–µ–∑ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–π –ø—É–Ω–∫—Ç –º–µ–Ω—é.")
    if alerts:
        lines.append("")
        lines.extend(alerts)
    lines.append("")
    lines.append("–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ –Ω–∏–∂–µ, —á—Ç–æ–±—ã –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å –¥–µ—Ç–∞–ª–∏ —á–µ–∫–æ–≤, –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –∑–∞–ø—Ä–æ—Å –Ω–∞ –≤—ã–ø–ª–∞—Ç—É –∏–ª–∏ –ø–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å –ø–æ–ª—É—á–µ–Ω–∏–µ —Å—Ä–µ–¥—Å—Ç–≤.")
    text = "\n".join(lines)
    await clear_then_anchor(uid, text, kb_finance_root(user_has_pending_confirm=user_has_approved_not_confirmed(uid)))
    await c.answer()


@dp.callback_query_handler(lambda c: c.data == "fin_unpaid_list")
async def finance_unpaid_list(c: types.CallbackQuery):
    uid = c.from_user.id
    proj = active_project["name"]
    if not proj: return await c.answer("‚ùó –ù–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–≥–æ –ø—Ä–æ–µ–∫—Ç–∞", show_alert=True)
    recs = user_project_receipts(uid, proj)
    unpaid: List[dict] = []
    pending: List[dict] = []
    for r in recs:
        if r.get("paid") is False:
            payout_status = (r.get("payout") or {}).get("status") if isinstance(r.get("payout"), dict) else None
            if payout_status in ("pending", "approved"):
                pending.append(r)
            else:
                unpaid.append(r)
    if not unpaid and not pending:
        return await c.answer("–ù–µ–æ–ø–ª–∞—á–µ–Ω–Ω—ã—Ö —á–µ–∫–æ–≤ –Ω–µ—Ç üéâ", show_alert=True)
    lines = [
        "‚è≥ <b>–ù–µ–æ–ø–ª–∞—á–µ–Ω–Ω—ã–µ —á–µ–∫–∏ –∏ –∑–∞–ø—Ä–æ—Å—ã</b>",
        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ",
        f"üìÇ –ü—Ä–æ–µ–∫—Ç: <b>{h(proj)}</b>",
        ""
    ]
    if unpaid:
        lines.append(f"‚ùå –ì–æ—Ç–æ–≤—ã –∫ –∑–∞–ø—Ä–æ—Å—É ({len(unpaid)} —à—Ç.):")
        total_unpaid = 0.0
        for r in unpaid:
            try:
                amount = float(r.get("sum") or 0.0)
            except (TypeError, ValueError):
                amount = 0.0
            total_unpaid += amount
            moment = f"{h(r.get('date','‚Äî'))} {h(r.get('time',''))}".strip()
            desc = r.get('desc')
            desc_text = h(desc) if desc else "‚Äî"
            rid = h(r.get('receipt_no', '‚Äî'))
            lines.append(f"‚Ä¢ {moment} ‚Äî {fmt_money(amount)} –≥—Ä–Ω ‚Äî {desc_text} ‚Äî #{rid}")
        lines.append(f"–ò—Ç–æ–≥–æ –∫ –∑–∞–ø—Ä–æ—Å—É: <b>{fmt_money(total_unpaid)} –≥—Ä–Ω</b>")
        lines.append("")
    if pending:
        lines.append(f"‚è≥ –£–∂–µ –≤ –∑–∞–ø—Ä–æ—Å–∞—Ö ({len(pending)} —à—Ç.):")
        total_pending = 0.0
        for r in pending:
            try:
                amount = float(r.get("sum") or 0.0)
            except (TypeError, ValueError):
                amount = 0.0
            total_pending += amount
            moment = f"{h(r.get('date','‚Äî'))} {h(r.get('time',''))}".strip()
            code = ((r.get("payout") or {}).get("code") or (r.get("payout") or {}).get("request_id")) if isinstance(r.get("payout"), dict) else None
            lines.append(f"‚Ä¢ {moment} ‚Äî {fmt_money(amount)} –≥—Ä–Ω ‚Äî –∑–∞–ø—Ä–æ—Å {h(code) if code else '‚Äî'}")
        lines.append(f"–í—Å–µ–≥–æ –≤ –∑–∞–ø—Ä–æ—Å–∞—Ö: <b>{fmt_money(total_pending)} –≥—Ä–Ω</b>")
    lines.append("")
    lines.append("–ü–æ–¥–∞–π—Ç–µ –Ω–æ–≤—ã–π –∑–∞–ø—Ä–æ—Å –Ω–∞ –≤—ã–ø–ª–∞—Ç—É, —á—Ç–æ–±—ã –∑–∞–∫—Ä—ã—Ç—å —á–µ–∫–∏ –∏–∑ —Ä–∞–∑–¥–µ–ª–∞ ¬´–ì–æ—Ç–æ–≤—ã –∫ –∑–∞–ø—Ä–æ—Å—É¬ª.")
    await clear_then_anchor(uid, "\n".join(lines), kb_finance_root(user_has_pending_confirm=user_has_approved_not_confirmed(uid)))
    await c.answer()


@dp.callback_query_handler(lambda c: c.data == "fin_request_payout")
async def finance_request_payout(c: types.CallbackQuery):
    uid = c.from_user.id
    proj = active_project["name"]
    if not proj: return await c.answer("‚ùó –ù–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–≥–æ –ø—Ä–æ–µ–∫—Ç–∞", show_alert=True)
    existing = finance_active_request_for_user(uid, proj)
    if existing:
        code = existing.get("code", existing.get("id"))
        status = existing.get("status")
        status_human = {"pending": "–æ–∂–∏–¥–∞–µ—Ç –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è", "approved": "–æ–¥–æ–±—Ä–µ–Ω–∞"}.get(status, status or "–≤ –æ–±—Ä–∞–±–æ—Ç–∫–µ")
        await clear_then_anchor(
            uid,
            (
                "üì® <b>–ó–∞–ø—Ä–æ—Å —É–∂–µ –≤ –æ–±—Ä–∞–±–æ—Ç–∫–µ</b>\n"
                f"–ö–æ–¥: <b>{h(code)}</b>\n"
                f"–¢–µ–∫—É—â–∏–π —Å—Ç–∞—Ç—É—Å: {h(status_human)}.\n\n"
                "–î–æ–∂–¥–∏—Ç–µ—Å—å –æ—Ç–≤–µ—Ç–∞ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞ –∏–ª–∏ –ø–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ –ø–æ–ª—É—á–µ–Ω–∏–µ —Å—Ä–µ–¥—Å—Ç–≤ –≤ —Ä–∞–∑–¥–µ–ª–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–π."
            ),
            kb_finance_root(user_has_pending_confirm=user_has_approved_not_confirmed(uid))
        )
        return await c.answer("–ï—Å—Ç—å –∞–∫—Ç–∏–≤–Ω—ã–π –∑–∞–ø—Ä–æ—Å –Ω–∞ –≤—ã–ø–ª–∞—Ç—É.", show_alert=True)
    recs = user_project_receipts(uid, proj)
    eligible: List[dict] = []
    locked: List[dict] = []
    for r in recs:
        if r.get("paid") is False:
            payout_status = (r.get("payout") or {}).get("status") if isinstance(r.get("payout"), dict) else None
            if payout_status in ("pending", "approved"):
                locked.append(r)
            else:
                eligible.append(r)
    if not eligible:
        if locked:
            message_text = (
                "–í—Å–µ –Ω–µ–æ–ø–ª–∞—á–µ–Ω–Ω—ã–µ —á–µ–∫–∏ —É–∂–µ –¥–æ–±–∞–≤–ª–µ–Ω—ã –≤ –¥–µ–π—Å—Ç–≤—É—é—â–∏–µ –∑–∞–ø—Ä–æ—Å—ã.\n"
                "–û–∂–∏–¥–∞–π—Ç–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞ –∏–ª–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ –≤—ã–ø–ª–∞—Ç–µ."
            )
        else:
            message_text = (
                "–§–∏—Ä–º–∞ –∑–∞–∫—Ä—ã–ª–∞ –≤—Å–µ –≤–∞—à–∏ —á–µ–∫–∏ ‚Äî –Ω–µ–æ–ø–ª–∞—á–µ–Ω–Ω—ã—Ö —Å—É–º–º –Ω–µ –æ—Å—Ç–∞–ª–æ—Å—å.\n"
                "–î–æ–±–∞–≤—å—Ç–µ –Ω–æ–≤—ã–µ —á–µ–∫–∏, —á—Ç–æ–±—ã —Å—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞—Ç—å —Å–ª–µ–¥—É—é—â–∏–π –∑–∞–ø—Ä–æ—Å."
            )
        await clear_then_anchor(
            uid,
            message_text,
            kb_finance_root(user_has_pending_confirm=user_has_approved_not_confirmed(uid))
        )
        return await c.answer("–ù–µ—Ç —á–µ–∫–æ–≤ –¥–ª—è –∑–∞–ø—Ä–æ—Å–∞.", show_alert=True)
    req = finance_new_request(uid, proj, eligible)
    req_id = req["id"]
    req_code = req.get("code", req_id)
    total = float(req.get("sum") or 0.0)
    proj_info = load_project_info(proj)
    project_code_txt = h(proj_info.get('code') or '‚Äî')
    await c.answer("–ó–∞–ø—Ä–æ—Å –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")

    prof = load_user(uid) or {}
    fullname = h(prof.get('fullname', '‚Äî'))
    bsu_code = h(prof.get('bsu', '‚Äî'))
    phone = h(prof.get('phone', '‚Äî'))
    username_raw = (prof.get('tg', {}) or {}).get('username')
    username_display = h(f"@{username_raw}" if username_raw else "‚Äî")
    receipts_line_parts = [h(r.get('receipt_no', '‚Äî')) for r in eligible[:10]]
    files_line = ", ".join(receipts_line_parts)
    if len(eligible) > 10:
        files_line += "‚Ä¶"
    region_txt = h(proj_info.get('region') or '‚Äî')
    location_txt = h(proj_info.get('location', '‚Äî'))
    req_code_disp = h(req_code)
    req_id_disp = h(req_id)
    text = (
        "üì¢ <b>–ù–æ–≤—ã–π –∑–∞–ø—Ä–æ—Å –Ω–∞ –≤—ã–ø–ª–∞—Ç—É</b>\n"
        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
        f"–ö–æ–¥ –≤—ã–ø–ª–∞—Ç—ã: <b>{req_code_disp}</b>\n"
        f"–§–∞–π–ª: <code>{req_id_disp}</code>\n"
        f"üë§ {fullname} (ID {uid}, {bsu_code})\n"
        f"üì± {phone}\n"
        f"üÜî {username_display}\n"
        f"üìÇ –ü—Ä–æ–µ–∫—Ç: {h(proj)}\n"
        f"üÜî –ö–æ–¥ –æ–±—ä–µ–∫—Ç–∞: {project_code_txt}\n"
        f"üåç –û–±–ª–∞—Å—Ç—å: {region_txt}\n"
        f"üìç –õ–æ–∫–∞—Ü–∏—è: {location_txt}\n"
        f"‚ùå –ù–µ–æ–ø–ª–∞—á–µ–Ω–Ω—ã—Ö —á–µ–∫–æ–≤: {len(eligible)} —à—Ç.\n"
        f"üí∞ –°—É–º–º–∞ –∫ –≤—ã–ø–ª–∞—Ç–µ: <b>{fmt_money(total)} –≥—Ä–Ω</b>\n"
        f"üßæ –ù–æ–º–µ—Ä–∞ —á–µ–∫–æ–≤: {files_line}\n\n"
        "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫–∏ –Ω–∏–∂–µ, —á—Ç–æ–±—ã –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –∫–∞—Ä—Ç–æ—á–∫–∏ –∏ –ø–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ."
    )
    akb = InlineKeyboardMarkup()
    akb.add(InlineKeyboardButton("üëÄ –ü–æ—Å–º–æ—Ç—Ä–µ—Ç—å —á–µ–∫–∏", callback_data=f"adm_req_view_checks:{req_id}"))
    akb.add(InlineKeyboardButton("‚úÖ –í—ã–ø–ª–∞—Ç–∏—Ç—å", callback_data=f"adm_req_paid:{req_id}"))
    akb.add(InlineKeyboardButton("‚ùå –ó–∞–∫—Ä—ã—Ç—å", callback_data=f"adm_req_close:{req_id}"))
    for ad in list(admins):
        chat_id = users_runtime.get(ad, {}).get("tg", {}).get("chat_id") or (load_user(ad) or {}).get("tg", {}).get("chat_id")
        if chat_id:
            try: await bot.send_message(chat_id, text, reply_markup=akb)
            except Exception: pass

    await clear_then_anchor(
        uid,
        (
            "üì® <b>–ó–∞–ø—Ä–æ—Å –Ω–∞ –≤—ã–ø–ª–∞—Ç—É –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω</b>\n"
            f"–ö–æ–¥: <b>{req_code_disp}</b>\n"
            f"–ü—Ä–æ–µ–∫—Ç: {h(proj)} (–∫–æ–¥ {project_code_txt})\n"
            f"–ß–µ–∫–æ–≤ –≤ –∑–∞–ø—Ä–æ—Å–µ: {len(eligible)} —à—Ç.\n"
            f"–°—É–º–º–∞: <b>{fmt_money(total)} –≥—Ä–Ω</b>\n\n"
            "–ú—ã —Å–æ–æ–±—â–∏–º, –∫–æ–≥–¥–∞ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä –æ–¥–æ–±—Ä–∏—Ç –≤—ã–ø–ª–∞—Ç—É –∏–ª–∏ –∑–∞–ø—Ä–æ—Å–∏—Ç —É—Ç–æ—á–Ω–µ–Ω–∏—è."
        ),
        kb_finance_root(user_has_pending_confirm=user_has_approved_not_confirmed(uid))
    )


@dp.callback_query_handler(lambda c: c.data == "fin_history")
async def fin_history(c: types.CallbackQuery):
    uid = c.from_user.id
    prof = load_user(uid) or {}
    requests: List[dict] = []
    for ref in iter_user_payout_refs(prof):
        req = finance_load_request(ref.get("id"), ref.get("project"))
        if req and req.get("user_id") == uid:
            requests.append(req)
    if not requests:
        await clear_then_anchor(
            uid,
            "üìö –ò—Å—Ç–æ—Ä–∏—è –≤—ã–ø–ª–∞—Ç –ø–æ–∫–∞ –ø—É—Å—Ç–∞.\n–û—Ç–ø—Ä–∞–≤—å—Ç–µ –∑–∞–ø—Ä–æ—Å –Ω–∞ –≤—ã–ø–ª–∞—Ç—É, –∏ –∑–¥–µ—Å—å –ø–æ—è–≤—è—Ç—Å—è –≤—Å–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥—ë–Ω–Ω—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏.",
            kb_finance_root(user_has_pending_confirm=user_has_approved_not_confirmed(uid))
        )
        return await c.answer()
    requests.sort(key=lambda x: x.get("created_at", ""), reverse=True)
    status_map = {"pending": "–í –æ–∂–∏–¥–∞–Ω–∏–∏", "approved": "–û–¥–æ–±—Ä–µ–Ω–æ", "confirmed": "–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–æ", "closed": "–ó–∞–∫—Ä—ã—Ç–æ"}
    lines = [
        "üìö <b>–ò—Å—Ç–æ—Ä–∏—è –≤—ã–ø–ª–∞—Ç</b>",
        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ",
        f"–ó–∞–ø–∏—Å–µ–π –Ω–∞–π–¥–µ–Ω–æ: <b>{len(requests)}</b>",
        "–ù–∞–∂–º–∏—Ç–µ –Ω–∞ –Ω—É–∂–Ω—ã–π –∫–æ–¥, —á—Ç–æ–±—ã –æ—Ç–∫—Ä—ã—Ç—å –¥–µ—Ç–∞–ª–∏ –∏ –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å –ø—Ä–∏–≤—è–∑–∞–Ω–Ω—ã–µ —á–µ–∫–∏.",
        ""
    ]
    kb = InlineKeyboardMarkup()
    for req in requests[:20]:
        code = req.get("code", req["id"])
        status_txt = status_map.get(req.get("status"), req.get("status", "‚Äî"))
        amount = fmt_money(float(req.get("sum") or 0.0))
        lines.append(f"‚Ä¢ {h(code)} ‚Äî {amount} –≥—Ä–Ω ‚Äî {h(status_txt)}")
        kb.add(InlineKeyboardButton(f"{code} ‚Ä¢ {status_txt}", callback_data=f"fin_hist_open:{req['id']}"))
    kb.add(InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="menu_finance"))
    await clear_then_anchor(uid, "\n".join(lines), kb)
    await c.answer()


@dp.callback_query_handler(lambda c: c.data.startswith("fin_hist_open:"))
async def fin_hist_open(c: types.CallbackQuery):
    uid = c.from_user.id
    req_id = c.data.split(":", 1)[1]
    obj = finance_load_request(req_id)
    if not obj or obj.get("user_id") != uid:
        return await c.answer("–ó–∞–ø–∏—Å—å –Ω–µ –Ω–∞–π–¥–µ–Ω–∞", show_alert=True)
    code = obj.get("code", req_id)
    proj_info = load_project_info(obj.get("project")) if obj.get("project") else {}
    project_code_txt = h(proj_info.get("code") or "‚Äî")
    status_map = {"pending": "–í –æ–∂–∏–¥–∞–Ω–∏–∏", "approved": "–û–¥–æ–±—Ä–µ–Ω–æ", "confirmed": "–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–æ", "closed": "–ó–∞–∫—Ä—ã—Ç–æ"}
    status_disp = status_map.get(obj.get("status"), obj.get("status", "‚Äî"))
    lines = [
        f"üíµ <b>–í—ã–ø–ª–∞—Ç–∞ {h(code)}</b>",
        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ",
        f"–°—Ç–∞—Ç—É—Å: <b>{h(status_disp)}</b>",
        f"–°—É–º–º–∞: <b>{fmt_money(float(obj.get('sum') or 0.0))} –≥—Ä–Ω</b>",
        f"–ü—Ä–æ–µ–∫—Ç: {h(obj.get('project', '‚Äî'))}",
        f"–°–≤—è–∑–∞–Ω–Ω—ã—Ö —á–µ–∫–æ–≤: {len(obj.get('files', []))}",
        ""
    ]
    def fmt_ts(value: Optional[str]) -> str:
        if not value:
            return "‚Äî"
        return format_datetime_short(value) or "‚Äî"
    lines.extend([
        f"üìÖ –°–æ–∑–¥–∞–Ω–æ: {fmt_ts(obj.get('created_at'))}",
        f"‚úÖ –û–¥–æ–±—Ä–µ–Ω–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º: {fmt_ts(obj.get('approved_at'))}",
        f"üí∏ –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º: {fmt_ts(obj.get('confirmed_at'))}"
    ])
    lines.append("")
    lines.append("–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫–∏ –Ω–∏–∂–µ, —á—Ç–æ–±—ã –ø—Ä–æ—Å–º–æ—Ç—Ä–µ—Ç—å –ø—Ä–∏–≤—è–∑–∞–Ω–Ω—ã–µ —á–µ–∫–∏ –∏–ª–∏ –≤–µ—Ä–Ω—É—Ç—å—Å—è –∫ —Å–ø–∏—Å–∫—É.")
    kb = InlineKeyboardMarkup()
    if obj.get("files"):
        kb.add(InlineKeyboardButton("üßæ –ü–æ—Å–º–æ—Ç—Ä–µ—Ç—å —á–µ–∫–∏", callback_data=f"fin_hist_view:{req_id}"))
    kb.add(InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="fin_history"))
    await clear_then_anchor(uid, "\n".join(lines), kb)
    await c.answer()


@dp.callback_query_handler(lambda c: c.data.startswith("fin_hist_view:"))
async def fin_hist_view(c: types.CallbackQuery):
    uid = c.from_user.id
    req_id = c.data.split(":", 1)[1]
    obj = finance_load_request(req_id)
    if not obj or obj.get("user_id") != uid:
        return await c.answer("–ó–∞–ø–∏—Å—å –Ω–µ –Ω–∞–π–¥–µ–Ω–∞", show_alert=True)
    files = obj.get("files", [])
    code = obj.get("code", req_id)
    recs = user_project_receipts(uid, obj.get("project"))
    by_file = {r.get("file"): r for r in recs}
    proj_info = load_project_info(obj.get("project")) if obj.get("project") else {}
    project_code_txt = h(proj_info.get("code") or "‚Äî")
    lines = [
        f"üßæ <b>–ß–µ–∫–∏ –≤—ã–ø–ª–∞—Ç—ã {h(code)}</b>",
        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ",
        f"–ü—Ä–æ–µ–∫—Ç: {h(obj.get('project','‚Äî'))} (–∫–æ–¥ {project_code_txt})",
        f"–í—Å–µ–≥–æ —Ñ–∞–π–ª–æ–≤: <b>{len(files)}</b>",
        ""
    ]
    for fname in files:
        r = by_file.get(fname)
        if r:
            amount = fmt_money(float(r.get("sum") or 0.0))
            desc = h(r.get("desc")) if r.get("desc") else "‚Äî"
            lines.append(f"‚Ä¢ #{h(r.get('receipt_no','‚Äî'))} ‚Äî {amount} –≥—Ä–Ω ‚Äî {desc}")
        else:
            lines.append(f"‚Ä¢ {h(fname)}")
    kb = InlineKeyboardMarkup().add(InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data=f"fin_hist_open:{req_id}"))
    await clear_then_anchor(uid, "\n".join(lines), kb)
    chat_id = c.message.chat.id
    for fname in files[:5]:
        r = by_file.get(fname)
        if r:
            msg = await send_receipt_card(chat_id, obj.get("project"), uid, r, include_project=False)
            flow_track(uid, msg)
    await c.answer()


@dp.callback_query_handler(lambda c: c.data == "fin_confirm_list")
async def fin_confirm_list(c: types.CallbackQuery):
    uid = c.from_user.id
    prof = load_user(uid) or {}
    to_confirm = []
    for ref in iter_user_payout_refs(prof):
        obj = finance_load_request(ref.get("id"), ref.get("project"))
        if obj and obj.get("status") == "approved" and obj.get("user_id") == uid:
            to_confirm.append(obj)
    if not to_confirm:
        return await c.answer("–ù–µ—Ç –≤—ã–ø–ª–∞—Ç, –æ–∂–∏–¥–∞—é—â–∏—Ö –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è.")
    kb = InlineKeyboardMarkup()
    text_lines = [
        "‚úÖ <b>–û–¥–æ–±—Ä–µ–Ω–Ω—ã–µ –≤—ã–ø–ª–∞—Ç—ã</b>",
        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ",
        "–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ –ø–æ–ª—É—á–µ–Ω–∏–µ —Å—Ä–µ–¥—Å—Ç–≤ –ø–æ –∫–∞–∂–¥–æ–π –∑–∞–ø–∏—Å–∏, —á—Ç–æ–±—ã –æ–±–Ω–æ–≤–∏—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É.",
        ""
    ]
    for o in to_confirm[:20]:
        code = o.get("code", o['id'])
        amount = float(o.get('sum') or 0.0)
        project_name_raw = o.get('project')
        if project_name_raw:
            proj_info = load_project_info(project_name_raw)
            project_name_disp = h(project_name_raw)
            project_code_txt = h(proj_info.get('code') or '‚Äî')
        else:
            project_name_disp = '‚Äî'
            project_code_txt = '‚Äî'
        text_lines.append(f"‚Ä¢ {h(code)} ‚Äî {fmt_money(amount)} –≥—Ä–Ω ‚Äî {project_name_disp} (–∫–æ–¥ {project_code_txt})")
        kb.add(InlineKeyboardButton(f"–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å {code}", callback_data=f"user_confirm_payout:{o['id']}"))
    kb.add(InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="menu_finance"))
    await clear_then_anchor(uid, "\n".join(text_lines), kb)
    await c.answer()


@dp.callback_query_handler(lambda c: c.data.startswith("user_confirm_payout:"))
async def user_confirm_payout(c: types.CallbackQuery):
    uid = c.from_user.id
    req_id = c.data.split(":",1)[1]
    prof = load_user(uid) or {}
    project_hint = None
    payout_entries = list(iter_user_payout_refs(prof))
    for ref in payout_entries:
        if ref.get("id") == req_id:
            project_hint = ref.get("project")
            break
    obj = finance_load_request(req_id, project_hint)
    if not obj or obj.get("user_id") != uid or obj.get("status") != "approved":
        return await c.answer("–ó–∞–ø—Ä–æ—Å –Ω–µ –Ω–∞–π–¥–µ–Ω/–Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã–π —Å—Ç–∞—Ç—É—Å.", show_alert=True)
    now_iso = datetime.now().isoformat()
    obj["status"] = "confirmed"
    obj["confirmed_at"] = now_iso
    finance_update_items_status(obj, "confirmed", now_iso)
    finance_append_history(obj, "confirmed", {"by": uid})
    finance_save_request(obj)
    update_receipts_for_request(uid, obj.get("project"), obj.get("files", []), "confirmed", obj)
    fin_state_clear(obj.get("project", ""), uid)
    code = obj.get("code", obj["id"])
    proj_info = load_project_info(obj.get("project")) if obj.get("project") else {}
    amount = float(obj.get('sum') or 0.0)
    if c.message:
        await delete_if_not_anchor(uid, c.message.chat.id, c.message.message_id)
    # —É–≤–µ–¥–æ–º–∏–º –∞–¥–º–∏–Ω–∞(–æ–≤)
    code_disp = h(code)
    project_disp = h(obj.get('project', '‚Äî'))
    proj_info = load_project_info(obj.get('project')) if obj.get('project') else {}
    project_code_txt = h(proj_info.get('code') or '‚Äî') if proj_info else '‚Äî'
    project_code_txt = h(proj_info.get('code') or '‚Äî') if proj_info else '‚Äî'
    fullname = h(prof.get('fullname', '‚Äî'))
    bsu_code = h(prof.get('bsu', '‚Äî'))
    phone = h(prof.get('phone', '‚Äî'))
    admin_note = (
        "üí∏ <b>–í—ã–ø–ª–∞—Ç–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞</b>\n"
        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
        f"–ö–æ–¥: <b>{code_disp}</b>\n"
        f"–ü—Ä–æ–µ–∫—Ç: {project_disp} (–∫–æ–¥ {project_code_txt})\n"
        f"–°—É–º–º–∞: <b>{fmt_money(amount)} –≥—Ä–Ω</b>\n"
        f"–ü–æ–ª—É—á–∞—Ç–µ–ª—å: {fullname} (ID {uid}, {bsu_code})\n"
        f"–¢–µ–ª–µ—Ñ–æ–Ω: {phone}\n"
        f"–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–æ: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
    )
    admin_kb = InlineKeyboardMarkup().add(InlineKeyboardButton("‚ùå –ó–∞–∫—Ä—ã—Ç—å", callback_data="admin_notice_close"))
    for ad in list(admins):
        chat_id = users_runtime.get(ad, {}).get("tg", {}).get("chat_id") or (load_user(ad) or {}).get("tg", {}).get("chat_id")
        if chat_id:
            try:
                await bot.send_message(chat_id, admin_note, reply_markup=admin_kb)
            except Exception:
                pass
    prof = load_user(uid) or {}
    remaining = []
    for ref in iter_user_payout_refs(prof):
        other = finance_load_request(ref.get("id"), ref.get("project"))
        if other and other.get("status") == "approved" and other.get("user_id") == uid:
            remaining.append(other)
    if remaining:
        kb = InlineKeyboardMarkup()
        text_lines = [
            "‚úÖ <b>–û–¥–æ–±—Ä–µ–Ω–Ω—ã–µ –≤—ã–ø–ª–∞—Ç—ã</b>",
            "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ",
            "–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ –ø–æ–ª—É—á–µ–Ω–∏–µ —Å—Ä–µ–¥—Å—Ç–≤ –ø–æ –∫–∞–∂–¥–æ–π –∑–∞–ø–∏—Å–∏, —á—Ç–æ–±—ã –∑–∞–∫—Ä—ã—Ç—å –∑–∞–ø—Ä–æ—Å.",
            ""
        ]
        for o in remaining[:20]:
            oc = o.get("code", o["id"])
            amt = float(o.get("sum") or 0.0)
            text_lines.append(f"‚Ä¢ {h(oc)} ‚Äî {fmt_money(amt)} –≥—Ä–Ω ‚Äî {h(o.get('project','‚Äî'))}")
            kb.add(InlineKeyboardButton(f"–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å {oc}", callback_data=f"user_confirm_payout:{o['id']}"))
        kb.add(InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="menu_finance"))
        await anchor_show_text(uid, "\n".join(text_lines), kb)
    else:
        await anchor_show_text(
            uid,
            (
                "‚úÖ <b>–í—ã–ø–ª–∞—Ç–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞</b>\n"
                f"–ö–æ–¥: <b>{code_disp}</b>\n"
                f"–°—É–º–º–∞: <b>{fmt_money(amount)} –≥—Ä–Ω</b>\n\n"
                "–°–ø–∞—Å–∏–±–æ! –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∞, –∏ –∑–∞–ø—Ä–æ—Å –ø–µ—Ä–µ–Ω–µ—Å—ë–Ω –≤ –∏—Å—Ç–æ—Ä–∏—é –≤—ã–ø–ª–∞—Ç."
            ),
            kb_finance_root(user_has_pending_confirm=user_has_approved_not_confirmed(uid))
        )
    await c.answer("–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–æ")


# ========================== ADMIN: FINANCE ==========================
@dp.callback_query_handler(lambda c: c.data == "adm_finance")
async def adm_finance(c: types.CallbackQuery):
    uid = c.from_user.id
    if uid not in admins: return await c.answer("‚õî", show_alert=True)
    kb = InlineKeyboardMarkup()
    kb.add(InlineKeyboardButton("üì¨ –ó–∞–ø—Ä–æ—Å—ã (–æ–∂–∏–¥–∞—é—Ç)", callback_data="adm_requests"))
    kb.add(InlineKeyboardButton("üìö –ò—Å—Ç–æ—Ä–∏—è –≤—ã–ø–ª–∞—Ç", callback_data="adm_history"))
    kb.add(InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="menu_admin"))
    await clear_then_anchor(
        uid,
        "üíµ <b>–§–∏–Ω–∞–Ω—Å–æ–≤—ã–π –º–æ–¥—É–ª—å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞</b>\n–í—ã–±–µ—Ä–∏—Ç–µ —Ä–∞–∑–¥–µ–ª –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –∑–∞–ø—Ä–æ—Å–æ–≤ –∏–ª–∏ –∏—Å—Ç–æ—Ä–∏–∏ –≤—ã–ø–ª–∞—Ç.",
        kb
    )
    await c.answer()


@dp.callback_query_handler(lambda c: c.data == "adm_requests")
async def adm_requests(c: types.CallbackQuery):
    uid = c.from_user.id
    if uid not in admins: return await c.answer("‚õî", show_alert=True)
    lst = finance_list("pending")
    if not lst:
        await clear_then_anchor(
            uid,
            "üíµ <b>–ó–∞–ø—Ä–æ—Å–æ–≤ –Ω–∞ –≤—ã–ø–ª–∞—Ç—É –Ω–µ—Ç</b>\n–í—Å–µ –æ–±—Ä–∞—â–µ–Ω–∏—è —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–æ–≤ –æ–±—Ä–∞–±–æ—Ç–∞–Ω—ã.",
            kb_admin_root()
        ); return await c.answer()
    kb = InlineKeyboardMarkup()
    for r in lst[:20]:
        code = r.get("code", r['id'])
        amount = float(r.get('sum') or 0.0)
        kb.add(InlineKeyboardButton(f"{code} ‚Ä¢ {fmt_money(amount)} –≥—Ä–Ω ‚Ä¢ u{r['user_id']}", callback_data=f"adm_req_open:{r['id']}"))
    kb.add(InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="adm_finance"))
    await clear_then_anchor(
        uid,
        "üì¨ <b>–ó–∞–ø—Ä–æ—Å—ã –Ω–∞ –≤—ã–ø–ª–∞—Ç—É</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n–í—ã–±–µ—Ä–∏—Ç–µ –æ–±—Ä–∞—â–µ–Ω–∏–µ, —á—Ç–æ–±—ã –∏–∑—É—á–∏—Ç—å –¥–µ—Ç–∞–ª–∏ –∏ –ø—Ä–∏–Ω—è—Ç—å —Ä–µ—à–µ–Ω–∏–µ.",
        kb
    )
    await c.answer()


@dp.callback_query_handler(lambda c: c.data == "adm_history")
async def adm_history(c: types.CallbackQuery):
    uid = c.from_user.id
    if uid not in admins: return await c.answer("‚õî", show_alert=True)
    lst = [x for x in finance_list() if x.get("status") in ("approved","confirmed","closed")]
    if not lst:
        await clear_then_anchor(
            uid,
            "üìö –ò—Å—Ç–æ—Ä–∏—è –≤—ã–ø–ª–∞—Ç –ø—É—Å—Ç–∞.\n–ó–¥–µ—Å—å –ø–æ—è–≤—è—Ç—Å—è –≤—Å–µ –æ–¥–æ–±—Ä–µ–Ω–Ω—ã–µ –∏ –∑–∞–∫—Ä—ã—Ç—ã–µ –æ–±—Ä–∞—â–µ–Ω–∏—è.",
            kb_admin_root()
        ); return await c.answer()
    kb = InlineKeyboardMarkup()
    status_map = {"approved": "–û–¥–æ–±—Ä–µ–Ω–æ", "confirmed": "–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–æ", "closed": "–ó–∞–∫—Ä—ã—Ç–æ"}
    for o in lst[:30]:
        code = o.get("code", o['id'])
        status_txt = status_map.get(o.get("status"), o.get("status"))
        amount = float(o.get('sum') or 0.0)
        kb.add(InlineKeyboardButton(f"{code} ‚Ä¢ {fmt_money(amount)} –≥—Ä–Ω ‚Ä¢ {status_txt}", callback_data=f"adm_hist_open:{o['id']}"))
    kb.add(InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="adm_finance"))
    await clear_then_anchor(
        uid,
        "üìö <b>–ò—Å—Ç–æ—Ä–∏—è –≤—ã–ø–ª–∞—Ç</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n–í—ã–±–µ—Ä–∏—Ç–µ –∑–∞–ø–∏—Å—å, —á—Ç–æ–±—ã –ø—Ä–æ—Å–º–æ—Ç—Ä–µ—Ç—å –ø–æ–¥—Ä–æ–±–Ω–æ—Å—Ç–∏ –∏ —Å–≤—è–∑–∞–Ω–Ω—ã–µ —á–µ–∫–∏.",
        kb
    )
    await c.answer()


@dp.callback_query_handler(lambda c: c.data.startswith("adm_hist_open:"))
async def adm_hist_open(c: types.CallbackQuery):
    uid = c.from_user.id
    if uid not in admins: return await c.answer("‚õî", show_alert=True)
    req_id = c.data.split(":", 1)[1]
    obj = finance_load_request(req_id)
    if not obj:
        return await c.answer("–ó–∞–ø—Ä–æ—Å –Ω–µ –Ω–∞–π–¥–µ–Ω", show_alert=True)
    prof = load_user(obj.get("user_id")) or {}
    code = obj.get("code", req_id)

    def fmt_ts(value: Optional[str]) -> str:
        if not value:
            return "‚Äî"
        try:
            return datetime.fromisoformat(value).strftime("%Y-%m-%d %H:%M")
        except Exception:
            return value

    status_map = {"pending": "–í –æ–∂–∏–¥–∞–Ω–∏–∏", "approved": "–û–¥–æ–±—Ä–µ–Ω–æ", "confirmed": "–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–æ", "closed": "–ó–∞–∫—Ä—ã—Ç–æ"}
    status_disp = status_map.get(obj.get('status'), obj.get('status'))
    project_disp = h(obj.get('project', '‚Äî'))
    code_disp = h(code)
    fullname = h(prof.get('fullname', '‚Äî'))
    bsu_code = h(prof.get('bsu', '‚Äî'))
    phone = h(prof.get('phone', '‚Äî'))
    username_raw = (prof.get('tg', {}) or {}).get('username')
    username_display = h(f"@{username_raw}" if username_raw else "‚Äî")
    text = (
        f"üíµ <b>–í—ã–ø–ª–∞—Ç–∞ {code_disp}</b>\n\n"
        f"–°—Ç–∞—Ç—É—Å: {h(status_disp)}\n"
        f"–°—É–º–º–∞: <b>{fmt_money(float(obj.get('sum') or 0.0))} –≥—Ä–Ω</b>\n"
        f"–ü—Ä–æ–µ–∫—Ç: {project_disp} (–∫–æ–¥ {project_code_txt})\n"
        f"–ß–µ–∫–æ–≤: {len(obj.get('files', []))}\n\n"
        f"üë§ {fullname} (ID {obj.get('user_id')}, {bsu_code})\n"
        f"üì± {phone}\n"
        f"üÜî {username_display}\n\n"
        f"–°–æ–∑–¥–∞–Ω–æ: {fmt_ts(obj.get('created_at'))}\n"
        f"–û–¥–æ–±—Ä–µ–Ω–æ: {fmt_ts(obj.get('approved_at'))}\n"
        f"–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–æ: {fmt_ts(obj.get('confirmed_at'))}"
    )
    kb = InlineKeyboardMarkup()
    if obj.get("files"):
        kb.add(InlineKeyboardButton("üßæ –ü–æ—Å–º–æ—Ç—Ä–µ—Ç—å —á–µ–∫–∏", callback_data=f"adm_hist_view_checks:{req_id}"))
    kb.add(InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="adm_history"))
    await clear_then_anchor(uid, text, kb)
    await c.answer()


@dp.callback_query_handler(lambda c: c.data.startswith("adm_hist_view_checks:"))
async def adm_hist_view_checks(c: types.CallbackQuery):
    uid = c.from_user.id
    if uid not in admins: return await c.answer("‚õî", show_alert=True)
    req_id = c.data.split(":", 1)[1]
    obj = finance_load_request(req_id)
    if not obj:
        return await c.answer("–ó–∞–ø—Ä–æ—Å –Ω–µ –Ω–∞–π–¥–µ–Ω", show_alert=True)
    files = obj.get("files", [])
    code = obj.get("code", req_id)
    lines = [f"üßæ –ß–µ–∫–∏ –≤—ã–ø–ª–∞—Ç—ã <b>{h(code)}</b> ({len(files)})", ""]
    recs = user_project_receipts(obj.get("user_id"), obj.get("project"))
    by_file = {r.get("file"): r for r in recs}
    for fname in files:
        r = by_file.get(fname)
        if r:
            amount = float(r.get('sum') or 0.0)
            desc_text = h(r.get('desc')) if r.get('desc') else "‚Äî"
            lines.append(f"‚Ä¢ {h(r.get('receipt_no','‚Äî'))} ‚Äî {fmt_money(amount)} –≥—Ä–Ω ‚Äî {desc_text}")
        else:
            lines.append(f"‚Ä¢ {h(fname)}")
    kb = InlineKeyboardMarkup()
    kb.add(InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data=f"adm_hist_open:{req_id}"))
    await clear_then_anchor(uid, "\n".join(lines), kb)
    await admin_send_receipt_photos(uid, c.message.chat.id, obj.get("user_id"), obj.get("project"), files)
    await c.answer()


@dp.callback_query_handler(lambda c: c.data.startswith("adm_req_open:"))
async def adm_req_open(c: types.CallbackQuery):
    uid = c.from_user.id
    if uid not in admins: return await c.answer("‚õî", show_alert=True)
    req_id = c.data.split(":",1)[1]
    obj = finance_load_request(req_id)
    if not obj: return await c.answer("–ó–∞–ø—Ä–æ—Å –Ω–µ –Ω–∞–π–¥–µ–Ω", show_alert=True)
    prof = load_user(obj["user_id"]) or {}
    code = obj.get("code", obj["id"])
    proj_info = load_project_info(obj.get("project")) if obj.get("project") else {"region": "", "location": ""}
    fullname = h(prof.get('fullname', '‚Äî'))
    bsu_code = h(prof.get('bsu', '‚Äî'))
    phone = h(prof.get('phone', '‚Äî'))
    username_raw = (prof.get('tg', {}) or {}).get('username')
    username_display = h(f"@{username_raw}" if username_raw else "‚Äî")
    code_disp = h(code)
    file_disp = h(obj['id'])
    project_name = h(obj.get('project', '‚Äî'))
    project_code_txt = h(proj_info.get('code') or '‚Äî')
    region_txt = h(proj_info.get('region') or '‚Äî')
    location_txt = h(proj_info.get('location', '‚Äî'))
    text = (
        "üì¢ <b>–ó–∞–ø—Ä–æ—Å –Ω–∞ –≤—ã–ø–ª–∞—Ç—É</b>\n"
        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
        f"–ö–æ–¥ –≤—ã–ø–ª–∞—Ç—ã: <b>{code_disp}</b>\n"
        f"–§–∞–π–ª: <code>{file_disp}</code>\n"
        f"üë§ {fullname} (ID {obj['user_id']}, {bsu_code})\n"
        f"üì± {phone}\n"
        f"üÜî {username_display}\n"
        f"üìÇ –ü—Ä–æ–µ–∫—Ç: {project_name}\n"
        f"üÜî –ö–æ–¥ –æ–±—ä–µ–∫—Ç–∞: {project_code_txt}\n"
        f"üåç –û–±–ª–∞—Å—Ç—å: {region_txt}\n"
        f"üìç –õ–æ–∫–∞—Ü–∏—è: {location_txt}\n"
        f"‚ùå –ù–µ–æ–ø–ª–∞—á–µ–Ω–Ω—ã—Ö —á–µ–∫–æ–≤: {len(obj['files'])} —à—Ç.\n"
        f"üí∞ –ö –≤—ã–ø–ª–∞—Ç–µ: <b>{fmt_money(float(obj.get('sum') or 0.0))} –≥—Ä–Ω</b>\n\n"
        "–ü—Ä–æ—Å–º–æ—Ç—Ä–∏—Ç–µ –ø—Ä–∏–∫—Ä–µ–ø–ª—ë–Ω–Ω—ã–µ —á–µ–∫–∏ –ø–µ—Ä–µ–¥ –æ–¥–æ–±—Ä–µ–Ω–∏–µ–º –≤—ã–ø–ª–∞—Ç—ã."
    )
    akb = InlineKeyboardMarkup()
    akb.add(InlineKeyboardButton("üëÄ –ü–æ—Å–º–æ—Ç—Ä–µ—Ç—å —á–µ–∫–∏", callback_data=f"adm_req_view_checks:{req_id}"))
    akb.add(InlineKeyboardButton("‚úÖ –í—ã–ø–ª–∞—Ç–∏—Ç—å", callback_data=f"adm_req_paid:{req_id}"))
    akb.add(InlineKeyboardButton("‚ùå –ó–∞–∫—Ä—ã—Ç—å", callback_data=f"adm_req_close:{req_id}"))
    akb.add(InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="adm_requests"))
    await clear_then_anchor(uid, text, akb)
    await c.answer()


@dp.callback_query_handler(lambda c: c.data.startswith("adm_req_view_checks:"))
async def adm_req_view_checks(c: types.CallbackQuery):
    uid = c.from_user.id
    if uid not in admins: return await c.answer("‚õî", show_alert=True)
    req_id = c.data.split(":",1)[1]
    obj = finance_load_request(req_id)
    if not obj: return await c.answer("–ó–∞–ø—Ä–æ—Å –Ω–µ –Ω–∞–π–¥–µ–Ω", show_alert=True)
    # –≤—ã—Ç–∞—â–∏–º —á–µ–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ –ø—Ä–æ–µ–∫—Ç—É —Å —É–∫–∞–∑–∞–Ω–Ω—ã–º–∏ —Ñ–∞–π–ª–∞–º–∏
    recs = user_project_receipts(obj["user_id"], obj["project"])
    by_file = {r["file"]: r for r in recs}
    code = obj.get("code", req_id)
    proj_info = load_project_info(obj.get("project")) if obj.get("project") else {}
    project_code_txt = h(proj_info.get("code") or "‚Äî")
    lines = [
        f"üßæ <b>–ß–µ–∫–∏ –≤—ã–ø–ª–∞—Ç—ã {h(code)}</b>",
        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ",
        f"–ü—Ä–æ–µ–∫—Ç: {h(obj.get('project','‚Äî'))} (–∫–æ–¥ {project_code_txt})",
        f"–í—Å–µ–≥–æ —á–µ–∫–æ–≤: <b>{len(obj['files'])}</b>",
        ""
    ]
    for f in obj["files"]:
        r = by_file.get(f)
        if r:
            amount = float(r.get('sum') or 0.0)
            desc_text = h(r.get('desc')) if r.get('desc') else "‚Äî"
            lines.append(f"‚Ä¢ {h(r.get('receipt_no','‚Äî'))} ‚Äî {fmt_money(amount)} –≥—Ä–Ω ‚Äî {desc_text} ‚Äî {h(r.get('date','‚Äî'))} {h(r.get('time',''))}")
        else:
            lines.append(f"‚Ä¢ {h(f)}")
    kb = InlineKeyboardMarkup()
    kb.add(InlineKeyboardButton("‚úÖ –í—ã–ø–ª–∞—Ç–∏—Ç—å", callback_data=f"adm_req_paid:{req_id}"))
    kb.add(InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data=f"adm_req_open:{req_id}"))
    await clear_then_anchor(uid, "\n".join(lines), kb)
    await admin_send_receipt_photos(uid, c.message.chat.id, obj["user_id"], obj["project"], obj.get("files", []))
    await c.answer()


@dp.callback_query_handler(lambda c: c.data.startswith("adm_req_close:"))
async def adm_req_close(c: types.CallbackQuery):
    uid = c.from_user.id
    if uid not in admins: return await c.answer("‚õî", show_alert=True)
    req_id = c.data.split(":",1)[1]
    obj = finance_load_request(req_id)
    if not obj or obj.get("status") != "pending":
        return await c.answer("–ó–∞–ø—Ä–æ—Å –Ω–µ –Ω–∞–π–¥–µ–Ω/–æ–±—Ä–∞–±–æ—Ç–∞–Ω", show_alert=True)
    now_iso = datetime.now().isoformat()
    obj["status"] = "closed"
    obj["closed_at"] = now_iso
    finance_update_items_status(obj, "closed", now_iso)
    finance_append_history(obj, "closed", {"by": uid})
    finance_save_request(obj)
    update_receipts_for_request(obj.get("user_id"), obj.get("project"), obj.get("files", []), "closed", obj)
    fin_state_clear(obj.get("project", ""), obj.get("user_id"))
    code = obj.get("code", req_id)
    if c.message:
        await delete_if_not_anchor(uid, c.message.chat.id, c.message.message_id)
    user_id = obj.get("user_id")
    prof = load_user(user_id) or {}
    chat_id = users_runtime.get(user_id, {}).get("tg", {}).get("chat_id") or prof.get("tg", {}).get("chat_id")
    if chat_id:
        note = (
            "‚ÑπÔ∏è <b>–ó–∞–ø—Ä–æ—Å –Ω–∞ –≤—ã–ø–ª–∞—Ç—É –∑–∞–∫—Ä—ã—Ç</b>\n\n"
            f"–ö–æ–¥: <b>{h(code)}</b>\n"
            f"–ü—Ä–æ–µ–∫—Ç: {h(obj.get('project','‚Äî'))} (–∫–æ–¥ {project_code_txt})\n"
            "–ï—Å–ª–∏ –Ω—É–∂–Ω–∞ –ø–æ–º–æ—â—å ‚Äî –Ω–∞–ø–∏—à–∏—Ç–µ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É."
        )
        kb = InlineKeyboardMarkup().add(InlineKeyboardButton("‚ùå –ó–∞–∫—Ä—ã—Ç—å", callback_data="broadcast_close"))
        try:
            await bot.send_message(chat_id, note, reply_markup=kb)
        except Exception:
            pass
    await clear_then_anchor(uid, f"üóÇ –ó–∞–ø—Ä–æ—Å {code} –∑–∞–∫—Ä—ã—Ç –±–µ–∑ –≤—ã–ø–ª–∞—Ç.", kb_admin_root())
    await c.answer("–ó–∞–∫—Ä—ã—Ç–æ")


@dp.callback_query_handler(lambda c: c.data.startswith("adm_req_paid:"))
async def adm_req_paid(c: types.CallbackQuery):
    uid = c.from_user.id
    if uid not in admins: return await c.answer("‚õî", show_alert=True)
    req_id = c.data.split(":",1)[1]
    obj = finance_load_request(req_id)
    if not obj or obj.get("status") != "pending":
        return await c.answer("–ó–∞–ø—Ä–æ—Å –Ω–µ –Ω–∞–π–¥–µ–Ω/–æ–±—Ä–∞–±–æ—Ç–∞–Ω", show_alert=True)

    now_iso = datetime.now().isoformat()
    obj["status"] = "approved"
    obj["approved_by"] = uid
    obj["approved_at"] = now_iso
    finance_update_items_status(obj, "approved", now_iso)
    finance_append_history(obj, "approved", {"by": uid})
    finance_save_request(obj)
    update_receipts_for_request(obj.get("user_id"), obj.get("project"), obj.get("files", []), "approved", obj)
    fin_state_set(obj.get("project", ""), obj.get("user_id"), req_id, "approved")

    user_id = obj["user_id"]
    prof = load_user(user_id) or {}
    code = obj.get("code", obj["id"])
    proj_info = load_project_info(obj.get("project")) if obj.get("project") else {}
    if c.message:
        await delete_if_not_anchor(uid, c.message.chat.id, c.message.message_id)

    chat_id = users_runtime.get(user_id, {}).get("tg", {}).get("chat_id") or prof.get("tg", {}).get("chat_id")
    recs = user_project_receipts(user_id, obj["project"])
    by_file = {r["file"]: r for r in recs}
    lines = []
    for f in obj["files"]:
        r = by_file.get(f)
        if r:
            amount = float(r.get("sum") or 0.0)
            lines.append(f"‚Ä¢ {h(r.get('receipt_no','‚Äî'))} ‚Äî {fmt_money(amount)} –≥—Ä–Ω")
        else:
            lines.append(f"‚Ä¢ {h(f)}")
    details = "\n".join(lines) if lines else "‚Äî"
    code_disp = h(code)
    project_disp = h(obj.get('project', '‚Äî'))
    project_code_txt = h(proj_info.get("code") or "‚Äî")
    user_text = (
        "üíµ <b>–í—ã–ø–ª–∞—Ç–∞ —Å–æ–≥–ª–∞—Å–æ–≤–∞–Ω–∞</b>\n\n"
        f"–ö–æ–¥: <b>{code_disp}</b>\n"
        f"–ü—Ä–æ–µ–∫—Ç: {project_disp} (–∫–æ–¥ {project_code_txt})\n"
        f"üí∞ –ö –≤—ã–¥–∞—á–µ: <b>{fmt_money(float(obj.get('sum') or 0.0))} –≥—Ä–Ω</b>\n"
        "–í–∞–º –¥–æ–ª–∂–Ω—ã –ø–µ—Ä–µ–¥–∞—Ç—å —É–∫–∞–∑–∞–Ω–Ω—É—é —Å—É–º–º—É. –ö–∞–∫ —Ç–æ–ª—å–∫–æ –ø–æ–ª—É—á–∏—Ç–µ –¥–µ–Ω—å–≥–∏, –ø–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ —ç—Ç–æ –≤–Ω–∏–∑—É.\n\n"
        "–ß–µ–∫–∏ –≤ –≤—ã–ø–ª–∞—Ç–µ:\n"
        f"{details}"
    )
    kb = InlineKeyboardMarkup()
    kb.add(InlineKeyboardButton("‚úÖ –î–µ–Ω—å–≥–∏ –ø–æ–ª—É—á–µ–Ω—ã", callback_data=f"user_confirm_payout:{obj['id']}"))
    kb.add(InlineKeyboardButton("‚ùå –ó–∞–∫—Ä—ã—Ç—å", callback_data="broadcast_close"))
    if chat_id:
        try:
            await bot.send_message(chat_id, user_text, reply_markup=kb)
        except Exception:
            pass

    await clear_then_anchor(uid, f"üí∏ –í—ã–ø–ª–∞—Ç–∞ {code_disp} –ø–æ –æ–±—ä–µ–∫—Ç—É {project_disp} (–∫–æ–¥ {project_code_txt}) –æ–¥–æ–±—Ä–µ–Ω–∞. –û–∂–∏–¥–∞–µ–º –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.", kb_admin_root())
    await c.answer("–í—ã–ø–ª–∞—Ç–∞ –æ–¥–æ–±—Ä–µ–Ω–∞")


# ========================== SOS ==========================
@dp.callback_query_handler(lambda c: c.data == "menu_sos")
async def sos_start(c: types.CallbackQuery, state: FSMContext):
    uid = c.from_user.id
    await state.finish()
    await flow_clear(uid)
    text = ("‚ö†Ô∏è –í—ã –Ω–∞–∂–∞–ª–∏ –∫–Ω–æ–ø–∫—É <b>SOS</b>.\n\n"
            "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ, —á—Ç–æ –Ω–∞–∂–∞—Ç–∏–µ –Ω–µ —Å–ª—É—á–∞–π–Ω–æ:")
    kb = InlineKeyboardMarkup()
    kb.add(InlineKeyboardButton("‚úÖ –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å", callback_data="sos_confirm"))
    kb.add(InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∏—Ç—å", callback_data="sos_cancel"))
    msg = await bot.send_message(c.message.chat.id, text, reply_markup=kb)
    flow_track(uid, msg)
    await c.answer()


@dp.callback_query_handler(lambda c: c.data == "sos_cancel")
async def sos_cancel(c: types.CallbackQuery, state: FSMContext):
    uid = c.from_user.id
    await state.finish(); await flow_clear(uid); await anchor_show_root(uid)
    await c.answer("–û—Ç–º–µ–Ω–µ–Ω–æ.")


@dp.callback_query_handler(lambda c: c.data == "sos_confirm")
async def sos_confirm(c: types.CallbackQuery, state: FSMContext):
    uid = c.from_user.id
    await flow_clear(uid)
    kb = ReplyKeyboardMarkup(resize_keyboard=True, one_time_keyboard=True)
    kb.row(
        KeyboardButton("üìç –û—Ç–ø—Ä–∞–≤–∏—Ç—å –º–µ—Å—Ç–æ–ø–æ–ª–æ–∂–µ–Ω–∏–µ", request_location=True),
        KeyboardButton("‚ùå –û—Ç–º–µ–Ω–∏—Ç—å")
    )
    msg = await bot.send_message(
        c.message.chat.id,
        "üìç –û—Ç–ø—Ä–∞–≤—å—Ç–µ –≤–∞—à—É –≥–µ–æ–ª–æ–∫–∞—Ü–∏—é –∫–Ω–æ–ø–∫–æ–π –Ω–∏–∂–µ –∏–ª–∏ –æ—Ç–º–µ–Ω–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ.",
        reply_markup=kb
    )
    flow_track(uid, msg)
    await SosFSM.waiting_location.set()
    await c.answer()


@dp.message_handler(state=SosFSM.waiting_location, content_types=ContentType.TEXT)
async def sos_location_text(m: types.Message, state: FSMContext):
    uid = m.from_user.id
    text = (m.text or "").strip()
    normalized = text.replace("‚ùå", "").replace("üìç", "").strip().lower()
    if normalized in {"–æ—Ç–º–µ–Ω–∏—Ç—å", "cancel"} or normalized in NP_CANCEL_WORDS:
        try:
            await bot.delete_message(m.chat.id, m.message_id)
        except Exception:
            pass
        try:
            remove = await bot.send_message(m.chat.id, "‚å®Ô∏è", reply_markup=ReplyKeyboardRemove())
            await bot.delete_message(remove.chat.id, remove.message_id)
        except Exception:
            pass
        await flow_clear(uid)
        await state.finish()
        await anchor_show_root(uid)
        return
    try:
        await bot.delete_message(m.chat.id, m.message_id)
    except Exception:
        pass
    warn = await bot.send_message(
        m.chat.id,
        "üìç –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫—É –æ—Ç–ø—Ä–∞–≤–∫–∏ –≥–µ–æ–ø–æ–∑–∏—Ü–∏–∏ –∏–ª–∏ ¬´‚ùå –û—Ç–º–µ–Ω–∏—Ç—å¬ª, —á—Ç–æ–±—ã –≤–µ—Ä–Ω—É—Ç—å—Å—è –≤ –º–µ–Ω—é."
    )
    flow_track(uid, warn)


@dp.message_handler(content_types=ContentType.LOCATION, state=SosFSM.waiting_location)
async def sos_location(m: types.Message, state: FSMContext):
    uid = m.from_user.id
    lat, lon = m.location.latitude, m.location.longitude
    prof = load_user(uid) or {"user_id": uid}

    try: await bot.delete_message(m.chat.id, m.message_id)
    except: pass

    try:
        placeholder = await bot.send_message(m.chat.id, "‚å®Ô∏è", reply_markup=ReplyKeyboardRemove())
        await bot.delete_message(m.chat.id, placeholder.message_id)
    except Exception:
        pass

    sender_kb = InlineKeyboardMarkup().add(
        InlineKeyboardButton("‚ùå –ó–∞–∫—Ä—ã—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ", callback_data="sos_sender_close")
    )
    sender_msg = await bot.send_message(
        m.chat.id,
        "üÜò SOS –≤–∫–ª—é—á—ë–Ω. –°–∏–≥–Ω–∞–ª –ø—Ä–∏–Ω—è—Ç.",
        reply_markup=sender_kb
    )
    users_runtime.setdefault(uid, {})["sos_sender_msg"] = sender_msg.message_id

    sos_text = (f"üö® <b>SOS —Å–∏–≥–Ω–∞–ª!</b>\n\n"
                f"üë§ –ò–º—è: {prof.get('fullname','‚Äî')} ({prof.get('bsu','‚Äî')})\n"
                f"üì± –¢–µ–ª–µ—Ñ–æ–Ω: {prof.get('phone','‚Äî')}\n"
                f"üÜî Telegram: @{(prof.get('tg',{}) or {}).get('username','‚Äî')}\n"
                f"üïí –í—Ä–µ–º—è –≤—ã–∑–æ–≤–∞: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n"
                f"‚ùó –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∑–∞–ø—Ä–æ—Å–∏–ª –ø–æ–º–æ—â—å. –ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –Ω–∏–∂–µ.")
    close_kb = InlineKeyboardMarkup().add(InlineKeyboardButton("‚ùå –ó–∞–∫—Ä—ã—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ", callback_data="sos_close"))

    def get_chat_id_for_user(u_id: int) -> Optional[int]:
        ch = users_runtime.get(u_id, {}).get("tg", {}).get("chat_id")
        if ch: return ch
        up = load_user(u_id)
        return (up.get("tg", {}).get("chat_id")) if up else None

    for f in os.listdir(USERS_PATH):
        if not f.endswith(".json"): continue
        try:
            udata = json.load(open(os.path.join(USERS_PATH, f), "r", encoding="utf-8"))
        except:
            continue
        rec_uid = int(udata.get("user_id", 0))
        if rec_uid == uid:  # –æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—é –Ω–µ —à–ª—ë–º
            continue
        chat_id = get_chat_id_for_user(rec_uid)
        if not chat_id:
            continue
        try:
            msg_txt = await bot.send_message(chat_id, sos_text, reply_markup=close_kb)
            msg_loc = await bot.send_location(chat_id, latitude=lat, longitude=lon)
            users_runtime.setdefault(rec_uid, {})["last_sos_broadcast"] = (msg_txt.message_id, msg_loc.message_id)
        except Exception:
            pass

    await flow_clear(uid)
    await state.finish()
    await anchor_show_root(uid)


@dp.callback_query_handler(lambda c: c.data == "sos_close")
async def sos_close(c: types.CallbackQuery):
    uid = c.from_user.id
    try: await bot.delete_message(c.message.chat.id, c.message.message_id)
    except Exception: pass
    pair = users_runtime.get(uid, {}).get("last_sos_broadcast")
    if pair:
        _, loc_id = pair
        try: await bot.delete_message(c.message.chat.id, loc_id)
        except: pass
        users_runtime[uid]["last_sos_broadcast"] = None
    await c.answer("–°–æ–æ–±—â–µ–Ω–∏–µ –∑–∞–∫—Ä—ã—Ç–æ.")


@dp.callback_query_handler(lambda c: c.data == "sos_sender_close")
async def sos_sender_close(c: types.CallbackQuery):
    uid = c.from_user.id
    msg_id = users_runtime.get(uid, {}).pop("sos_sender_msg", None)
    if msg_id:
        try: await bot.delete_message(c.message.chat.id, msg_id)
        except: pass
    await c.answer("–£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –∑–∞–∫—Ä—ã—Ç–æ.")


# ========================== ADMIN: USERS & PROJECTS ==========================
def paginate(lst: List[str], page: int, per_page: int=10) -> Tuple[List[str], int]:
    total = max(1, (len(lst) + per_page - 1) // per_page)
    page = max(1, min(page, total))
    start = (page-1)*per_page
    return lst[start:start+per_page], total


@dp.callback_query_handler(lambda c: c.data == "menu_admin")
async def menu_admin(c: types.CallbackQuery):
    uid = c.from_user.id
    if uid not in admins:
        return await c.answer("‚õî –î–æ—Å—Ç—É–ø —Ç–æ–ª—å–∫–æ –¥–ª—è –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–≤", show_alert=True)
    await clear_then_anchor(
        uid,
        "üßë‚Äçüíº <b>–ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å</b>\n–í—ã–±–µ—Ä–∏—Ç–µ —Ä–∞–∑–¥–µ–ª –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º–∏, –ø—Ä–æ–µ–∫—Ç–∞–º–∏ –∏ —Ñ–∏–Ω–∞–Ω—Å–∞–º–∏.",
        kb_admin_root()
    )
    await c.answer()


@dp.callback_query_handler(lambda c: c.data == "adm_users")
async def adm_users(c: types.CallbackQuery, state: FSMContext):
    uid = c.from_user.id
    if uid not in admins: return await c.answer("‚õî", show_alert=True)
    await state.reset_state(with_data=False)
    await admin_edit_clear_prompt(uid)
    await flow_clear_warnings(uid)
    files = sorted([f for f in os.listdir(USERS_PATH) if f.endswith(".json")])
    page = 1
    slice_, total = paginate(files, page)
    kb = InlineKeyboardMarkup()
    for filename in slice_:
        try:
            target_uid = int(os.path.splitext(filename)[0])
        except ValueError:
            continue
        profile = load_user(target_uid) or {"user_id": target_uid}
        fullname = str(profile.get("fullname") or "‚Äî")
        code = str(profile.get("bsu") or "‚Äî")
        kb.add(
            InlineKeyboardButton(
                f"{fullname} ({code})",
                callback_data=f"adm_user_{target_uid}"
            )
        )
    if total > 1:
        kb.row(
            InlineKeyboardButton("‚èÆ", callback_data=f"adm_users_page_1"),
            InlineKeyboardButton(f"{page}/{total}", callback_data="noop"),
            InlineKeyboardButton("‚è≠", callback_data=f"adm_users_page_{total}")
        )
    kb.add(InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="menu_admin"))
    await clear_then_anchor(
        uid,
        "üë• <b>–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n–í—ã–±–µ—Ä–∏—Ç–µ —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–∞, —á—Ç–æ–±—ã –æ—Ç–∫—Ä—ã—Ç—å –∫–∞—Ä—Ç–æ—á–∫—É —Å –ø–æ–¥—Ä–æ–±–Ω–æ—Å—Ç—è–º–∏.",
        kb
    )
    await c.answer()


@dp.callback_query_handler(lambda c: c.data.startswith("adm_users_page_"))
async def adm_users_page(c: types.CallbackQuery, state: FSMContext):
    uid = c.from_user.id
    if uid not in admins: return await c.answer("‚õî", show_alert=True)
    await state.reset_state(with_data=False)
    await admin_edit_clear_prompt(uid)
    await flow_clear_warnings(uid)
    files = sorted([f for f in os.listdir(USERS_PATH) if f.endswith(".json")])
    try:
        page = int(c.data.split("_")[-1])
    except Exception:
        page = 1
    slice_, total = paginate(files, page)
    kb = InlineKeyboardMarkup()
    for filename in slice_:
        try:
            target_uid = int(os.path.splitext(filename)[0])
        except ValueError:
            continue
        profile = load_user(target_uid) or {"user_id": target_uid}
        fullname = str(profile.get("fullname") or "‚Äî")
        code = str(profile.get("bsu") or "‚Äî")
        kb.add(
            InlineKeyboardButton(
                f"{fullname} ({code})",
                callback_data=f"adm_user_{target_uid}"
            )
        )
    if total > 1:
        prev_page = max(1, page-1); next_page = min(total, page+1)
        kb.row(
            InlineKeyboardButton("‚èÆ", callback_data=f"adm_users_page_1"),
            InlineKeyboardButton(f"‚óÄ {prev_page}", callback_data=f"adm_users_page_{prev_page}"),
            InlineKeyboardButton(f"{page}/{total}", callback_data="noop"),
            InlineKeyboardButton(f"{next_page} ‚ñ∂", callback_data=f"adm_users_page_{next_page}"),
            InlineKeyboardButton("‚è≠", callback_data=f"adm_users_page_{total}")
        )
    kb.add(InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="menu_admin"))
    await clear_then_anchor(
        uid,
        "üë• <b>–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏</b>\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n–í—ã–±–µ—Ä–∏—Ç–µ —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–∞, —á—Ç–æ–±—ã –æ—Ç–∫—Ä—ã—Ç—å –∫–∞—Ä—Ç–æ—á–∫—É —Å –ø–æ–¥—Ä–æ–±–Ω–æ—Å—Ç—è–º–∏.",
        kb
    )
    await c.answer()


@dp.callback_query_handler(lambda c: c.data.startswith("adm_user_"))
async def adm_user_card(c: types.CallbackQuery, state: FSMContext):
    uid = c.from_user.id
    if uid not in admins: return await c.answer("‚õî", show_alert=True)
    target = int(c.data.split("adm_user_",1)[1])
    await state.reset_state(with_data=False)
    await state.update_data(target_uid=target, admin_user_show_photo=False, admin_user_edit_mode=False)
    await admin_edit_clear_prompt(uid)
    await flow_clear_warnings(uid)
    await admin_show_user(uid, target, state, show_photo=False, edit_mode=False)
    await c.answer()


async def admin_show_user(
    uid: int,
    target_uid: int,
    state: FSMContext,
    show_photo: Optional[bool] = None,
    edit_mode: Optional[bool] = None,
):
    data = await state.get_data()
    if show_photo is None:
        show_photo = bool(data.get("admin_user_show_photo"))
    if edit_mode is None:
        edit_mode = bool(data.get("admin_user_edit_mode"))
    await state.update_data(admin_user_show_photo=show_photo, admin_user_edit_mode=edit_mode)
    profile = load_user(target_uid) or {"user_id": target_uid}
    text = admin_user_card_text(uid, profile, edit_mode=edit_mode)
    kb = kb_admin_user(uid, profile, show_photo=show_photo, edit_mode=edit_mode)
    if show_photo and profile_has_photo(profile):
        await anchor_replace_with_photo(uid, user_profile_photo_path(target_uid), text, kb)
    else:
        chat = users_runtime.get(uid, {}).get("tg", {}).get("chat_id")
        if chat:
            await anchor_upsert(uid, chat, text, kb)


@dp.callback_query_handler(lambda c: c.data == "adm_user_photo_toggle")
async def adm_user_photo_toggle(c: types.CallbackQuery, state: FSMContext):
    uid = c.from_user.id
    if uid not in admins:
        return await c.answer("‚õî", show_alert=True)
    data = await state.get_data()
    target = data.get("target_uid")
    if not target:
        return await c.answer("–ö–æ—Ä–∏—Å—Ç—É–≤–∞—á –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–∏–π", show_alert=True)
    current = bool(data.get("admin_user_show_photo"))
    await admin_show_user(uid, target, state, show_photo=not current)
    await c.answer()


@dp.callback_query_handler(lambda c: c.data == "adm_user_edit")
async def adm_user_edit(c: types.CallbackQuery, state: FSMContext):
    uid = c.from_user.id
    if uid not in admins:
        return await c.answer("‚õî", show_alert=True)
    data = await state.get_data()
    target = data.get("target_uid")
    if not target:
        return await c.answer("–ö–æ—Ä–∏—Å—Ç—É–≤–∞—á –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–∏–π", show_alert=True)
    await state.reset_state(with_data=False)
    await admin_edit_clear_prompt(uid)
    await flow_clear_warnings(uid)
    await state.update_data(admin_user_edit_mode=True)
    await admin_show_user(uid, target, state, show_photo=False, edit_mode=True)
    await c.answer()


@dp.callback_query_handler(lambda c: c.data == "adm_user_edit_done", state="*")
async def adm_user_edit_done(c: types.CallbackQuery, state: FSMContext):
    uid = c.from_user.id
    if uid not in admins:
        return await c.answer("‚õî", show_alert=True)
    data = await state.get_data()
    target = data.get("target_uid")
    if not target:
        return await c.answer("–ö–æ—Ä–∏—Å—Ç—É–≤–∞—á –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–∏–π", show_alert=True)
    runtime = admin_edit_runtime(uid)
    runtime.pop("reply_keyboard", False)
    await admin_edit_clear_prompt(uid)
    await flow_clear_warnings(uid)
    await state.reset_state(with_data=False)
    await state.update_data(admin_user_edit_mode=False)
    await admin_show_user(uid, target, state, show_photo=False, edit_mode=False)
    await c.answer()


@dp.callback_query_handler(
    lambda c: c.data == "adm_edit_cancel",
    state=[
        AdminProfileEditFSM.waiting_last_name,
        AdminProfileEditFSM.waiting_first_name,
        AdminProfileEditFSM.waiting_middle_name,
        AdminProfileEditFSM.waiting_birthdate,
        AdminProfileEditFSM.waiting_region,
        AdminProfileEditFSM.region_confirm,
        AdminProfileEditFSM.waiting_phone,
        AdminProfileEditFSM.waiting_photo,
    ],
)
async def adm_edit_cancel(c: types.CallbackQuery, state: FSMContext):
    uid = c.from_user.id
    if uid not in admins:
        return await c.answer("‚õî", show_alert=True)
    data = await state.get_data()
    target = data.get("target_uid")
    runtime = admin_edit_runtime(uid)
    remove_keyboard = bool(runtime.pop("reply_keyboard", False))
    await admin_edit_clear_prompt(uid)
    await flow_clear_warnings(uid)
    await state.reset_state(with_data=False)
    if target:
        await admin_show_user(uid, target, state, show_photo=False, edit_mode=True)
    if remove_keyboard:
        await admin_edit_notify(uid, tr(uid, "PROFILE_CANCELLED"), remove_keyboard=True)
    else:
        await c.answer(tr(uid, "PROFILE_CANCELLED"))


@dp.callback_query_handler(lambda c: c.data == "adm_edit_last")
async def adm_edit_last_prompt(c: types.CallbackQuery, state: FSMContext):
    uid = c.from_user.id
    if uid not in admins:
        return await c.answer("‚õî", show_alert=True)
    if not (await state.get_data()).get("target_uid"):
        return await c.answer("–ö–æ—Ä–∏—Å—Ç—É–≤–∞—á –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–∏–π", show_alert=True)
    await state.reset_state(with_data=False)
    await AdminProfileEditFSM.waiting_last_name.set()
    await flow_clear_warnings(uid)
    await admin_edit_send_prompt(uid, tr(uid, "PROFILE_PROMPT_LAST_NAME"), reply_markup=kb_admin_edit_cancel(uid))
    await c.answer()


@dp.callback_query_handler(lambda c: c.data == "adm_edit_first")
async def adm_edit_first_prompt(c: types.CallbackQuery, state: FSMContext):
    uid = c.from_user.id
    if uid not in admins:
        return await c.answer("‚õî", show_alert=True)
    if not (await state.get_data()).get("target_uid"):
        return await c.answer("–ö–æ—Ä–∏—Å—Ç—É–≤–∞—á –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–∏–π", show_alert=True)
    await state.reset_state(with_data=False)
    await AdminProfileEditFSM.waiting_first_name.set()
    await flow_clear_warnings(uid)
    await admin_edit_send_prompt(uid, tr(uid, "PROFILE_PROMPT_FIRST_NAME"), reply_markup=kb_admin_edit_cancel(uid))
    await c.answer()


@dp.callback_query_handler(lambda c: c.data == "adm_edit_middle")
async def adm_edit_middle_prompt(c: types.CallbackQuery, state: FSMContext):
    uid = c.from_user.id
    if uid not in admins:
        return await c.answer("‚õî", show_alert=True)
    if not (await state.get_data()).get("target_uid"):
        return await c.answer("–ö–æ—Ä–∏—Å—Ç—É–≤–∞—á –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–∏–π", show_alert=True)
    await state.reset_state(with_data=False)
    await AdminProfileEditFSM.waiting_middle_name.set()
    await flow_clear_warnings(uid)
    await admin_edit_send_prompt(uid, tr(uid, "PROFILE_PROMPT_MIDDLE_NAME"), reply_markup=kb_admin_edit_cancel(uid))
    await c.answer()


@dp.callback_query_handler(lambda c: c.data == "adm_edit_birthdate")
async def adm_edit_birthdate_prompt(c: types.CallbackQuery, state: FSMContext):
    uid = c.from_user.id
    if uid not in admins:
        return await c.answer("‚õî", show_alert=True)
    if not (await state.get_data()).get("target_uid"):
        return await c.answer("–ö–æ—Ä–∏—Å—Ç—É–≤–∞—á –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–∏–π", show_alert=True)
    await state.reset_state(with_data=False)
    await AdminProfileEditFSM.waiting_birthdate.set()
    await flow_clear_warnings(uid)
    await admin_edit_send_prompt(uid, tr(uid, "PROFILE_PROMPT_BIRTHDATE"), reply_markup=kb_admin_edit_cancel(uid))
    await c.answer()


@dp.callback_query_handler(lambda c: c.data == "adm_edit_region")
async def adm_edit_region_prompt(c: types.CallbackQuery, state: FSMContext):
    uid = c.from_user.id
    if uid not in admins:
        return await c.answer("‚õî", show_alert=True)
    if not (await state.get_data()).get("target_uid"):
        return await c.answer("–ö–æ—Ä–∏—Å—Ç—É–≤–∞—á –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–∏–π", show_alert=True)
    await state.reset_state(with_data=False)
    await AdminProfileEditFSM.waiting_region.set()
    await flow_clear_warnings(uid)
    await admin_edit_send_prompt(uid, tr(uid, "PROFILE_PROMPT_REGION"), reply_markup=kb_admin_edit_region_prompt(uid))
    await c.answer()


@dp.callback_query_handler(lambda c: c.data == "adm_reg_open", state=AdminProfileEditFSM.waiting_region)
async def adm_edit_region_open(c: types.CallbackQuery, state: FSMContext):
    uid = c.from_user.id
    if uid not in admins:
        return await c.answer("‚õî", show_alert=True)
    await admin_edit_send_prompt(uid, tr(uid, "REGISTER_REGION_PICK"), reply_markup=kb_admin_edit_region_picker(uid))
    await c.answer()


@dp.callback_query_handler(lambda c: c.data.startswith("adm_reg_pick:"), state=AdminProfileEditFSM.waiting_region)
async def adm_edit_region_pick(c: types.CallbackQuery, state: FSMContext):
    uid = c.from_user.id
    if uid not in admins:
        return await c.answer("‚õî", show_alert=True)
    try:
        idx = int(c.data.split(":", 1)[1])
        region = UKRAINE_REGIONS[idx]
    except Exception:
        return await c.answer(tr(uid, "REGISTER_REGION_REMIND"), show_alert=True)
    await state.update_data(admin_region=region)
    await admin_edit_send_prompt(
        uid,
        tr(uid, "REGISTER_REGION_SELECTED", region=h(region)),
        reply_markup=kb_admin_edit_next(uid, "adm_reg_confirm"),
    )
    await AdminProfileEditFSM.region_confirm.set()
    await c.answer()


@dp.callback_query_handler(lambda c: c.data == "adm_reg_confirm", state=AdminProfileEditFSM.region_confirm)
async def adm_edit_region_confirm(c: types.CallbackQuery, state: FSMContext):
    uid = c.from_user.id
    if uid not in admins:
        return await c.answer("‚õî", show_alert=True)
    data = await state.get_data()
    target = data.get("target_uid")
    region = data.get("admin_region")
    if not target or not region:
        return await c.answer(tr(uid, "REGISTER_REGION_REMIND"), show_alert=True)
    profile = load_user(target)
    if not profile:
        profile = ensure_user(target, {})
    profile["region"] = region
    profile["updated_at"] = datetime.now(timezone.utc).isoformat()
    save_user(profile)
    await admin_edit_clear_prompt(uid)
    await flow_clear_warnings(uid)
    await state.reset_state(with_data=False)
    await admin_edit_notify(uid, tr(uid, "PROFILE_UPDATE_SUCCESS"))
    await admin_show_user(uid, target, state, show_photo=False, edit_mode=True)
    await c.answer()


@dp.message_handler(state=AdminProfileEditFSM.waiting_region, content_types=ContentType.TEXT)
async def adm_edit_region_text(m: types.Message, state: FSMContext):
    uid = m.from_user.id
    if uid not in admins:
        return
    await flow_delete_message(uid, m)
    warn = await bot.send_message(m.chat.id, tr(uid, "REGISTER_REGION_REMIND"), reply_markup=kb_admin_edit_region_prompt(uid))
    flow_track_warning(uid, warn)


@dp.callback_query_handler(lambda c: c.data == "adm_edit_phone")
async def adm_edit_phone_prompt(c: types.CallbackQuery, state: FSMContext):
    uid = c.from_user.id
    if uid not in admins:
        return await c.answer("‚õî", show_alert=True)
    if not (await state.get_data()).get("target_uid"):
        return await c.answer("–ö–æ—Ä–∏—Å—Ç—É–≤–∞—á –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–∏–π", show_alert=True)
    await state.reset_state(with_data=False)
    await AdminProfileEditFSM.waiting_phone.set()
    await flow_clear_warnings(uid)
    await admin_edit_send_prompt(uid, tr(uid, "PROFILE_PROMPT_PHONE"), reply_markup=kb_admin_edit_cancel(uid))
    await c.answer()


@dp.callback_query_handler(lambda c: c.data == "adm_edit_photo")
async def adm_edit_photo_prompt(c: types.CallbackQuery, state: FSMContext):
    uid = c.from_user.id
    if uid not in admins:
        return await c.answer("‚õî", show_alert=True)
    if not (await state.get_data()).get("target_uid"):
        return await c.answer("–ö–æ—Ä–∏—Å—Ç—É–≤–∞—á –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–∏–π", show_alert=True)
    await state.reset_state(with_data=False)
    await AdminProfileEditFSM.waiting_photo.set()
    await flow_clear_warnings(uid)
    await admin_edit_send_prompt(uid, tr(uid, "PROFILE_PROMPT_PHOTO"), reply_markup=kb_admin_edit_cancel(uid))
    await c.answer()


@dp.callback_query_handler(lambda c: c.data == "adm_edit_remove_photo")
async def adm_edit_remove_photo(c: types.CallbackQuery, state: FSMContext):
    uid = c.from_user.id
    if uid not in admins:
        return await c.answer("‚õî", show_alert=True)
    data = await state.get_data()
    target = data.get("target_uid")
    if not target:
        return await c.answer("–ö–æ—Ä–∏—Å—Ç—É–≤–∞—á –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–∏–π", show_alert=True)
    profile = load_user(target)
    if not profile:
        profile = ensure_user(target, {})
    remove_profile_photo(target)
    profile["photo"] = {}
    profile["updated_at"] = datetime.now(timezone.utc).isoformat()
    save_user(profile)
    await flow_clear_warnings(uid)
    await admin_edit_notify(uid, tr(uid, "PROFILE_PHOTO_REMOVED"))
    await admin_show_user(uid, target, state, show_photo=False, edit_mode=True)
    await c.answer()

@dp.message_handler(state=AdminProfileEditFSM.waiting_last_name, content_types=ContentType.TEXT)
async def adm_edit_last_input(m: types.Message, state: FSMContext):
    uid = m.from_user.id
    if uid not in admins:
        return
    raw = normalize_person_name(m.text)
    await flow_delete_message(uid, m)
    if not raw or not NAME_VALID_RE.match(raw):
        warn = await bot.send_message(m.chat.id, tr(uid, "REGISTER_LAST_NAME_WARN"))
        flow_track_warning(uid, warn)
        return
    data = await state.get_data()
    target = data.get("target_uid")
    if not target:
        warn = await bot.send_message(m.chat.id, "–ö–æ—Ä–∏—Å—Ç—É–≤–∞—á –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–∏–π")
        flow_track_warning(uid, warn)
        return
    profile = load_user(target)
    if not profile:
        profile = ensure_user(target, {})
    profile["last_name"] = beautify_name(raw)
    profile["fullname"] = compose_fullname(profile["last_name"], profile.get("first_name", ""), profile.get("middle_name"))
    profile["updated_at"] = datetime.now(timezone.utc).isoformat()
    save_user(profile)
    await admin_edit_clear_prompt(uid)
    await flow_clear_warnings(uid)
    await state.reset_state(with_data=False)
    await admin_edit_notify(uid, tr(uid, "PROFILE_UPDATE_SUCCESS"))
    await admin_show_user(uid, target, state, show_photo=False, edit_mode=True)


@dp.message_handler(state=AdminProfileEditFSM.waiting_first_name, content_types=ContentType.TEXT)
async def adm_edit_first_input(m: types.Message, state: FSMContext):
    uid = m.from_user.id
    if uid not in admins:
        return
    raw = normalize_person_name(m.text)
    await flow_delete_message(uid, m)
    if not raw or not NAME_VALID_RE.match(raw):
        warn = await bot.send_message(m.chat.id, tr(uid, "REGISTER_FIRST_NAME_WARN"))
        flow_track_warning(uid, warn)
        return
    data = await state.get_data()
    target = data.get("target_uid")
    if not target:
        warn = await bot.send_message(m.chat.id, "–ö–æ—Ä–∏—Å—Ç—É–≤–∞—á –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–∏–π")
        flow_track_warning(uid, warn)
        return
    profile = load_user(target)
    if not profile:
        profile = ensure_user(target, {})
    profile["first_name"] = beautify_name(raw)
    profile["fullname"] = compose_fullname(profile.get("last_name", ""), profile["first_name"], profile.get("middle_name"))
    profile["updated_at"] = datetime.now(timezone.utc).isoformat()
    save_user(profile)
    await admin_edit_clear_prompt(uid)
    await flow_clear_warnings(uid)
    await state.reset_state(with_data=False)
    await admin_edit_notify(uid, tr(uid, "PROFILE_UPDATE_SUCCESS"))
    await admin_show_user(uid, target, state, show_photo=False, edit_mode=True)


@dp.message_handler(state=AdminProfileEditFSM.waiting_middle_name, content_types=ContentType.TEXT)
async def adm_edit_middle_input(m: types.Message, state: FSMContext):
    uid = m.from_user.id
    if uid not in admins:
        return
    raw = normalize_person_name(m.text)
    await flow_delete_message(uid, m)
    if raw and raw.lower() in SKIP_KEYWORDS:
        cleaned = ""
    elif raw and NAME_VALID_RE.match(raw):
        cleaned = beautify_name(raw)
    else:
        warn = await bot.send_message(m.chat.id, tr(uid, "REGISTER_MIDDLE_NAME_WARN"))
        flow_track_warning(uid, warn)
        return
    data = await state.get_data()
    target = data.get("target_uid")
    if not target:
        warn = await bot.send_message(m.chat.id, "–ö–æ—Ä–∏—Å—Ç—É–≤–∞—á –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–∏–π")
        flow_track_warning(uid, warn)
        return
    profile = load_user(target)
    if not profile:
        profile = ensure_user(target, {})
    profile["middle_name"] = cleaned
    profile["fullname"] = compose_fullname(profile.get("last_name", ""), profile.get("first_name", ""), cleaned)
    profile["updated_at"] = datetime.now(timezone.utc).isoformat()
    save_user(profile)
    await admin_edit_clear_prompt(uid)
    await flow_clear_warnings(uid)
    await state.reset_state(with_data=False)
    await admin_edit_notify(uid, tr(uid, "PROFILE_UPDATE_SUCCESS"))
    await admin_show_user(uid, target, state, show_photo=False, edit_mode=True)


@dp.message_handler(state=AdminProfileEditFSM.waiting_birthdate, content_types=ContentType.TEXT)
async def adm_edit_birthdate_input(m: types.Message, state: FSMContext):
    uid = m.from_user.id
    if uid not in admins:
        return
    dt = parse_birthdate_text(m.text)
    await flow_delete_message(uid, m)
    if not dt:
        warn = await bot.send_message(m.chat.id, tr(uid, "REGISTER_BIRTHDATE_WARN"))
        flow_track_warning(uid, warn)
        return
    data = await state.get_data()
    target = data.get("target_uid")
    if not target:
        warn = await bot.send_message(m.chat.id, "–ö–æ—Ä–∏—Å—Ç—É–≤–∞—á –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–∏–π")
        flow_track_warning(uid, warn)
        return
    profile = load_user(target)
    if not profile:
        profile = ensure_user(target, {})
    profile["birthdate"] = dt.strftime("%Y-%m-%d")
    profile["updated_at"] = datetime.now(timezone.utc).isoformat()
    save_user(profile)
    await admin_edit_clear_prompt(uid)
    await flow_clear_warnings(uid)
    await state.reset_state(with_data=False)
    await admin_edit_notify(uid, tr(uid, "PROFILE_UPDATE_SUCCESS"))
    await admin_show_user(uid, target, state, show_photo=False, edit_mode=True)


@dp.message_handler(state=AdminProfileEditFSM.waiting_phone, content_types=ContentType.TEXT)
async def adm_edit_phone_input(m: types.Message, state: FSMContext):
    uid = m.from_user.id
    if uid not in admins:
        return
    phone = sanitize_phone_input(m.text)
    await flow_delete_message(uid, m)
    if not phone:
        warn = await bot.send_message(m.chat.id, tr(uid, "REGISTER_PHONE_TEXT_WARN"))
        flow_track_warning(uid, warn)
        return
    data = await state.get_data()
    target = data.get("target_uid")
    if not target:
        warn = await bot.send_message(m.chat.id, "–ö–æ—Ä–∏—Å—Ç—É–≤–∞—á –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–∏–π")
        flow_track_warning(uid, warn)
        return
    profile = load_user(target)
    if not profile:
        profile = ensure_user(target, {})
    profile["phone"] = phone
    profile.setdefault("tg", {})
    profile["updated_at"] = datetime.now(timezone.utc).isoformat()
    save_user(profile)
    runtime = admin_edit_runtime(uid)
    runtime.pop("reply_keyboard", None)
    await admin_edit_clear_prompt(uid)
    await flow_clear_warnings(uid)
    await state.reset_state(with_data=False)
    await admin_edit_notify(uid, tr(uid, "PROFILE_PHONE_SAVED"))
    await admin_show_user(uid, target, state, show_photo=False, edit_mode=True)


@dp.message_handler(state=AdminProfileEditFSM.waiting_phone, content_types=ContentType.CONTACT)
async def adm_edit_phone_contact(m: types.Message, state: FSMContext):
    uid = m.from_user.id
    if uid not in admins:
        return
    await flow_delete_message(uid, m)
    warn = await bot.send_message(m.chat.id, tr(uid, "REGISTER_PHONE_TEXT_WARN"))
    flow_track_warning(uid, warn)


@dp.message_handler(state=AdminProfileEditFSM.waiting_photo, content_types=ContentType.PHOTO)
async def adm_edit_photo_receive(m: types.Message, state: FSMContext):
    uid = m.from_user.id
    if uid not in admins:
        return
    data = await state.get_data()
    target = data.get("target_uid")
    if not target:
        await flow_delete_message(uid, m)
        warn = await bot.send_message(m.chat.id, "–ö–æ—Ä–∏—Å—Ç—É–≤–∞—á –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–∏–π")
        flow_track_warning(uid, warn)
        return
    photo = m.photo[-1] if m.photo else None
    if not photo:
        await flow_delete_message(uid, m)
        warn = await bot.send_message(m.chat.id, tr(uid, "REGISTER_PHOTO_WARN"))
        flow_track_warning(uid, warn)
        return
    try:
        meta = await store_profile_photo(target, photo)
    except Exception:
        await flow_delete_message(uid, m)
        warn = await bot.send_message(m.chat.id, tr(uid, "REGISTER_PHOTO_WARN"))
        flow_track_warning(uid, warn)
        return
    await flow_delete_message(uid, m)
    profile = load_user(target)
    if not profile:
        profile = ensure_user(target, {})
    profile["photo"] = meta or {"status": "uploaded", "updated_at": datetime.now(timezone.utc).isoformat()}
    profile["updated_at"] = datetime.now(timezone.utc).isoformat()
    save_user(profile)
    await admin_edit_clear_prompt(uid)
    await flow_clear_warnings(uid)
    await state.reset_state(with_data=False)
    await admin_edit_notify(uid, tr(uid, "PROFILE_PHOTO_UPDATED"))
    await admin_show_user(uid, target, state, show_photo=False, edit_mode=True)


@dp.message_handler(state=AdminProfileEditFSM.waiting_photo, content_types=ContentType.ANY)
async def adm_edit_photo_invalid(m: types.Message, state: FSMContext):
    uid = m.from_user.id
    if uid not in admins:
        return
    if m.photo:
        return
    await flow_delete_message(uid, m)
    warn = await bot.send_message(m.chat.id, tr(uid, "REGISTER_PHOTO_WARN"))
    flow_track_warning(uid, warn)


@dp.callback_query_handler(lambda c: c.data == "adm_user_finance")
async def adm_user_finance_view(c: types.CallbackQuery, state: FSMContext):
    uid = c.from_user.id
    if uid not in admins:
        return await c.answer("‚õî", show_alert=True)
    data = await state.get_data()
    target = data.get("target_uid")
    if not target:
        return await c.answer("–ö–æ—Ä–∏—Å—Ç—É–≤–∞—á –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–∏–π", show_alert=True)
    profile = load_user(target) or {"user_id": target}
    stats = admin_collect_user_stats(profile)
    pending = stats["pending_payouts"]
    closed = stats["confirmed_payouts"]
    fullname = h(profile.get("fullname", "‚Äî"))
    bsu = h(profile.get("bsu", "‚Äî"))
    lines = [
        "üíµ <b>–§—ñ–Ω–∞–Ω—Å–æ–≤–∏–π –æ–≥–ª—è–¥ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞</b>",
        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ",
        f"üë§ {fullname} (BSU {bsu})",
        f"üìÇ –ê–∫—Ç–∏–≤–Ω–∏—Ö –ø—Ä–æ—î–∫—Ç—ñ–≤ –∑ —á–µ–∫–∞–º–∏: <b>{len(stats['projects'])}</b>",
        f"üßæ –ß–µ–∫—ñ–≤ —É —Å–∏—Å—Ç–µ–º—ñ: <b>{stats['total_count']}</b>",
        f"üí∞ –ó–∞–≥–∞–ª—å–Ω–∞ —Å—É–º–∞: <b>{fmt_money(stats['total_sum'])} –≥—Ä–Ω</b>",
        f"‚úÖ –û–ø–ª–∞—á–µ–Ω–æ: <b>{fmt_money(stats['paid_sum'])} –≥—Ä–Ω</b>",
        f"‚è≥ –û—á—ñ–∫—É—î: <b>{fmt_money(stats['unpaid_sum'])} –≥—Ä–Ω</b>",
        "",
        f"üì¨ –ó–∞–ø–∏—Ç—ñ–≤ —É —Ä–æ–±–æ—Ç—ñ: <b>{len(pending)}</b>",
    ]
    if pending:
        for req in pending[:10]:
            code = req.get("code") or req.get("id")
            amount = fmt_money(float(req.get("sum") or 0.0))
            status = req.get("status", "‚Äî")
            lines.append(f"‚Ä¢ {h(code)} ‚Äî {amount} –≥—Ä–Ω ‚Äî {h(status)}")
    if closed:
        lines.append("")
        lines.append(f"üìó –ü—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω–æ/–∑–∞–∫—Ä–∏—Ç–æ: <b>{len(closed)}</b>")
        for req in closed[-5:]:
            code = req.get("code") or req.get("id")
            amount = fmt_money(float(req.get("sum") or 0.0))
            status = req.get("status", "‚Äî")
            lines.append(f"‚Ä¢ {h(code)} ‚Äî {amount} –≥—Ä–Ω ‚Äî {h(status)}")
    kb = InlineKeyboardMarkup()
    kb.add(InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data=f"adm_user_{target}"))
    await clear_then_anchor(uid, "\n".join(lines), kb)
    await c.answer()


# ======= Admin: per-project stats / receipts (reuse from previous version) =======
@dp.callback_query_handler(lambda c: c.data == "adm_stat_choose")
async def adm_stat_choose(c: types.CallbackQuery, state: FSMContext):
    uid = c.from_user.id
    target = (await state.get_data()).get("target_uid")
    projs = sorted(list((load_user(target) or {}).get("receipts", {}).keys()))
    kb = InlineKeyboardMarkup()
    for p in projs: kb.add(InlineKeyboardButton(p, callback_data=f"adm_stat_{p}"))
    kb.add(InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data=f"adm_user_{target}"))
    await clear_then_anchor(uid, "–í—ã–±–µ—Ä–∏—Ç–µ –ø—Ä–æ–µ–∫—Ç:", kb)
    await c.answer()


@dp.callback_query_handler(lambda c: c.data.startswith("adm_stat_"))
async def adm_stat_show(c: types.CallbackQuery, state: FSMContext):
    uid = c.from_user.id
    proj = c.data.split("adm_stat_",1)[1]
    target = (await state.get_data()).get("target_uid")
    recs = user_project_receipts(target, proj)
    cnt = len(recs); total = round(sum(float(r.get("sum", 0.0)) for r in recs), 2)
    paid_sum = round(sum(float(r.get("sum", 0.0)) for r in recs if r.get("paid") is True), 2)
    unpaid_sum = round(sum(float(r.get("sum", 0.0)) for r in recs if r.get("paid") is False), 2)
    text = (f"üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è <b>{target}</b>\n"
            f"üìÇ –ü—Ä–æ–µ–∫—Ç: <b>{h(proj)}</b>\n"
            f"‚Ä¢ –ß–µ–∫–æ–≤: <b>{cnt}</b>\n‚Ä¢ –í—Å–µ–≥–æ: <b>{fmt_money(total)} –≥—Ä–Ω</b>\n"
            f"‚Ä¢ ‚úÖ –û–ø–ª–∞—á–µ–Ω–æ: <b>{fmt_money(paid_sum)} –≥—Ä–Ω</b>\n"
            f"‚Ä¢ ‚ùå –ù–µ –æ–ø–ª–∞—á–µ–Ω–æ: <b>{fmt_money(unpaid_sum)} –≥—Ä–Ω</b>")
    kb = InlineKeyboardMarkup().add(InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="adm_stat_choose"))
    await clear_then_anchor(uid, text, kb)
    await c.answer()


@dp.callback_query_handler(lambda c: c.data == "adm_recs_choose")
async def adm_recs_choose(c: types.CallbackQuery, state: FSMContext):
    uid = c.from_user.id
    target = (await state.get_data()).get("target_uid")
    projs = sorted(list((load_user(target) or {}).get("receipts", {}).keys()))
    kb = InlineKeyboardMarkup()
    for p in projs: kb.add(InlineKeyboardButton(p, callback_data=f"adm_recs_{p}"))
    kb.add(InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="adm_user_"+str(target)))
    await clear_then_anchor(uid, "–í—ã–±–µ—Ä–∏—Ç–µ –ø—Ä–æ–µ–∫—Ç:", kb)
    await c.answer()


@dp.callback_query_handler(lambda c: c.data.startswith("adm_recs_"))
async def adm_recs_show(c: types.CallbackQuery, state: FSMContext):
    uid = c.from_user.id
    proj = c.data.split("adm_recs_",1)[1]
    target = (await state.get_data()).get("target_uid")
    recs = user_project_receipts(target, proj)
    if not recs:
        return await c.answer("–ß–µ–∫–æ–≤ –Ω–µ—Ç.", show_alert=True)
    lines = [f"üìÅ –ß–µ–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è <b>{target}</b>", f"üìÇ –ü—Ä–æ–µ–∫—Ç: <b>{h(proj)}</b>", ""]
    for r in recs[-30:]:
        status = "‚úÖ" if r.get("paid") is True else ("‚ùå" if r.get("paid") is False else "‚è≥")
        amount = float(r.get('sum') or 0.0)
        desc_text = h(r.get('desc')) if r.get('desc') else "‚Äî"
        lines.append(
            f"‚Ä¢ #{h(r.get('receipt_no',''))} ‚Äî {h(r.get('date','‚Äî'))} {h(r.get('time',''))} ‚Äî {fmt_money(amount)} –≥—Ä–Ω {status} ‚Äî {desc_text}"
        )
    kb = InlineKeyboardMarkup().add(InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="adm_recs_choose"))
    await clear_then_anchor(uid, "\n".join(lines), kb)
    # –ø–æ—Å–ª–µ–¥–Ω–∏–µ 10 —Ñ–æ—Ç–æ
    for r in recs[-10:]:
        msg = await send_receipt_card(c.message.chat.id, proj, target, r,
                                      kb=InlineKeyboardMarkup().add(InlineKeyboardButton("‚ùå –ó–∞–∫—Ä—ã—Ç—å", callback_data="broadcast_close")),
                                      include_project=False)
        flow_track(uid, msg)
    await c.answer()


# ========================== PROJECTS (ADMIN) ==========================
@dp.callback_query_handler(lambda c: c.data == "adm_projects", state="*")
async def adm_projects(c: types.CallbackQuery, state: FSMContext):
    uid = c.from_user.id
    if uid not in admins: return await c.answer("‚õî", show_alert=True)
    await clear_step_prompt(state)
    await state.finish()
    await clear_then_anchor(uid, "üìÇ <b>–ü—Ä–æ–µ–∫—Ç—ã</b>", kb_admin_projects())
    await c.answer()


@dp.callback_query_handler(lambda c: c.data == "proj_list")
async def proj_list_cb(c: types.CallbackQuery):
    uid = c.from_user.id
    projs = list_projects()
    if not projs:
        await clear_then_anchor(uid, "‚ùó –ü—Ä–æ–µ–∫—Ç–æ–≤ –Ω–µ—Ç.", kb_admin_projects()); return await c.answer()
    act = active_project["name"]
    lines = ["üìã <b>–°–ø–∏—Å–æ–∫ –ø—Ä–æ–µ–∫—Ç–æ–≤</b>", ""]
    for p in projs:
        info = load_project_info(p)
        flag = " (‚òÖ –∞–∫—Ç–∏–≤–Ω—ã–π)" if p == act else ""
        lines.append(
            f"‚Ä¢ <b>{h(p)}</b>{flag}\n"
            f"  üÜî {h(info.get('code') or '‚Äî')}\n"
            f"  üåç {h(info.get('region') or '‚Äî')}\n"
            f"  üìç {h(info.get('location') or '‚Äî')}\n"
            f"  üìÖ {h(info.get('start_date') or '?')} ‚Üí {h(info.get('end_date') or '?')}"
        )
    await clear_then_anchor(uid, "\n".join(lines), kb_admin_projects())
    await c.answer()


@dp.callback_query_handler(lambda c: c.data == "proj_create")
async def proj_create_begin(c: types.CallbackQuery):
    uid = c.from_user.id
    await clear_then_anchor(uid, "‚úèÔ∏è –í–≤–µ–¥–∏—Ç–µ <b>–Ω–∞–∑–≤–∞–Ω–∏–µ</b> –ø—Ä–æ–µ–∫—Ç–∞ –∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ–º.",
                            kb=InlineKeyboardMarkup().add(InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="adm_projects")))
    await ProjectCreateFSM.enter_name.set()
    await c.answer()


@dp.callback_query_handler(lambda c: c.data == "proj_create_cancel", state="*")
async def proj_create_cancel(c: types.CallbackQuery, state: FSMContext):
    uid = c.from_user.id
    await clear_step_prompt(state)
    await state.finish()
    await flow_clear(uid)
    await anchor_show_text(uid, "üìÇ <b>–ü—Ä–æ–µ–∫—Ç—ã</b>", kb_admin_projects())
    await c.answer("–û—Ç–º–µ–Ω–µ–Ω–æ")


@dp.message_handler(state=ProjectCreateFSM.enter_name, content_types=ContentType.TEXT)
async def proj_enter_loc(m: types.Message, state: FSMContext):
    uid = m.from_user.id
    name = (m.text or "").strip()
    try: await bot.delete_message(m.chat.id, m.message_id)
    except: pass
    if not name:
        warn = await bot.send_message(m.chat.id, "‚ùó –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ.")
        flow_track(uid, warn); return
    await clear_step_prompt(state)
    await state.update_data(name=name)
    msg = await bot.send_message(m.chat.id, "üåç –í—ã–±–µ—Ä–∏—Ç–µ –æ–±–ª–∞—Å—Ç—å –ø—Ä–æ–µ–∫—Ç–∞:", reply_markup=kb_region_select())
    flow_track(uid, msg)
    await remember_step_prompt(state, msg)
    await ProjectCreateFSM.enter_region.set()


@dp.callback_query_handler(lambda c: c.data.startswith("proj_region_"), state=ProjectCreateFSM.enter_region)
async def proj_select_region(c: types.CallbackQuery, state: FSMContext):
    uid = c.from_user.id
    try:
        idx = int(c.data.split("proj_region_", 1)[1])
    except Exception:
        return await c.answer("–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ–±–ª–∞—Å—Ç—å", show_alert=True)
    if idx < 0 or idx >= len(UKRAINE_REGIONS):
        return await c.answer("–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ–±–ª–∞—Å—Ç—å", show_alert=True)
    region = UKRAINE_REGIONS[idx]
    await clear_step_prompt(state)
    await state.update_data(region=region)
    msg = await bot.send_message(c.message.chat.id, "üìç –£–∫–∞–∂–∏—Ç–µ <b>–ª–æ–∫–∞—Ü–∏—é</b> (–≥–æ—Ä–æ–¥/–∞–¥—Ä–µ—Å).")
    flow_track(uid, msg)
    await remember_step_prompt(state, msg)
    await ProjectCreateFSM.enter_location.set()
    await c.answer(region)


@dp.message_handler(state=ProjectCreateFSM.enter_location, content_types=ContentType.TEXT)
async def proj_enter_desc(m: types.Message, state: FSMContext):
    uid = m.from_user.id
    loc = (m.text or "").strip()
    try: await bot.delete_message(m.chat.id, m.message_id)
    except: pass
    if not loc:
        warn = await bot.send_message(m.chat.id, "‚ùó –£–∫–∞–∂–∏—Ç–µ –ª–æ–∫–∞—Ü–∏—é.")
        flow_track(uid, warn); return
    await clear_step_prompt(state)
    await state.update_data(location=loc)
    msg = await bot.send_message(m.chat.id, "‚ÑπÔ∏è –ö—Ä–∞—Ç–∫–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ (–Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ). –ï—Å–ª–∏ –ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å ‚Äî –æ—Ç–ø—Ä–∞–≤—å—Ç–µ ¬´-¬ª.")
    flow_track(uid, msg)
    await remember_step_prompt(state, msg)
    await ProjectCreateFSM.enter_description.set()


@dp.message_handler(state=ProjectCreateFSM.enter_description, content_types=ContentType.TEXT)
async def proj_enter_start(m: types.Message, state: FSMContext):
    uid = m.from_user.id
    desc = None if (m.text or "").strip() == "-" else (m.text or "").strip()
    try: await bot.delete_message(m.chat.id, m.message_id)
    except: pass
    await clear_step_prompt(state)
    await state.update_data(description=desc)
    msg = await bot.send_message(m.chat.id, "üìÖ –í–≤–µ–¥–∏—Ç–µ <b>–¥–∞—Ç—É –Ω–∞—á–∞–ª–∞</b> (YYYY-MM-DD):")
    flow_track(uid, msg)
    await remember_step_prompt(state, msg)
    await ProjectCreateFSM.enter_start_date.set()


def _parse_date(text: str) -> Optional[str]:
    try: return datetime.strptime(text, "%Y-%m-%d").strftime("%Y-%m-%d")
    except Exception: return None


@dp.message_handler(state=ProjectCreateFSM.enter_start_date, content_types=ContentType.TEXT)
async def proj_enter_end(m: types.Message, state: FSMContext):
    uid = m.from_user.id
    sd = _parse_date((m.text or "").strip())
    try: await bot.delete_message(m.chat.id, m.message_id)
    except: pass
    if not sd:
        warn = await bot.send_message(m.chat.id, "‚ùó –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç. –ü—Ä–∏–º–µ—Ä: 2025-09-21")
        flow_track(uid, warn); return
    await clear_step_prompt(state)
    await state.update_data(start_date=sd)
    msg = await bot.send_message(m.chat.id, "üìÖ –í–≤–µ–¥–∏—Ç–µ <b>–¥–∞—Ç—É –æ–∫–æ–Ω—á–∞–Ω–∏—è</b> (YYYY-MM-DD):")
    flow_track(uid, msg)
    await remember_step_prompt(state, msg)
    await ProjectCreateFSM.enter_end_date.set()


@dp.message_handler(state=ProjectCreateFSM.enter_end_date, content_types=ContentType.TEXT)
async def proj_pdf_prompt(m: types.Message, state: FSMContext):
    uid = m.from_user.id
    ed = _parse_date((m.text or "").strip())
    try: await bot.delete_message(m.chat.id, m.message_id)
    except: pass
    if not ed:
        warn = await bot.send_message(m.chat.id, "‚ùó –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç. –ü—Ä–∏–º–µ—Ä: 2025-12-31")
        flow_track(uid, warn); return
    await clear_step_prompt(state)
    await state.update_data(end_date=ed)
    data = await state.get_data()
    ensure_project_structure(data["name"])
    tip = await bot.send_message(m.chat.id, "üìë –ó–∞–≥—Ä—É–∂–∞–π—Ç–µ PDF-—Ñ–∞–π–ª—ã –ø—Ä–æ–µ–∫—Ç–∞ (–º–æ–∂–Ω–æ –Ω–µ—Å–∫–æ–ª—å–∫–æ). –ö–æ–≥–¥–∞ –∑–∞–∫–æ–Ω—á–∏—Ç–µ ‚Äî –Ω–∞–∂–º–∏—Ç–µ ¬´‚úÖ –ó–∞–≤–µ—Ä—à–∏—Ç—å¬ª.")
    flow_track(uid, tip)
    await state.update_data(step_prompt=None)
    await anchor_show_text(uid, "–ó–∞–≥—Ä—É–∑–∫–∞ PDF: –ø—Ä–∏—à–ª–∏—Ç–µ –¥–æ–∫—É–º–µ–Ω—Ç(—ã), –∑–∞—Ç–µ–º ¬´‚úÖ –ó–∞–≤–µ—Ä—à–∏—Ç—å¬ª.", kb_pdf_upload())
    await ProjectCreateFSM.upload_pdf.set()


@dp.message_handler(content_types=ContentType.DOCUMENT, state=ProjectCreateFSM.upload_pdf)
async def proj_pdf_upload(m: types.Message, state: FSMContext):
    uid = m.from_user.id
    data = await state.get_data(); name = data["name"]
    if not (m.document and (m.document.mime_type and "pdf" in m.document.mime_type.lower() or m.document.file_name.lower().endswith(".pdf"))):
        warn = await bot.send_message(m.chat.id, "‚ö†Ô∏è –î–æ–ø—É—Å–∫–∞—é—Ç—Å—è —Ç–æ–ª—å–∫–æ PDF.")
        flow_track(uid, warn)
        try: await bot.delete_message(m.chat.id, m.message_id)
        except: pass
        return
    dst = os.path.join(proj_pdf_dir(name), m.document.file_name)
    os.makedirs(proj_pdf_dir(name), exist_ok=True)
    await m.document.download(destination_file=dst)
    info = load_project_info(name)
    arr = info.get("pdf", [])
    if m.document.file_name not in arr:
        arr.append(m.document.file_name); info["pdf"] = arr; save_project_info(name, info)
    ok = await bot.send_message(m.chat.id, f"‚úÖ PDF —Å–æ—Ö—Ä–∞–Ω—ë–Ω: {m.document.file_name}")
    flow_track(uid, ok)
    try: await bot.delete_message(m.chat.id, m.message_id)
    except: pass


@dp.callback_query_handler(lambda c: c.data in ("pdf_more", "pdf_finish"), state=ProjectCreateFSM.upload_pdf)
async def proj_pdf_buttons(c: types.CallbackQuery, state: FSMContext):
    uid = c.from_user.id
    if c.data == "pdf_more":
        await anchor_show_text(uid, "üìë –ü—Ä–∏—à–ª–∏—Ç–µ —Å–ª–µ–¥—É—é—â–∏–π PDF –∏–ª–∏ ¬´‚úÖ –ó–∞–≤–µ—Ä—à–∏—Ç—å¬ª.", kb_pdf_upload())
        return await c.answer("–ñ–¥—É —Ñ–∞–π–ª")
    data = await state.get_data(); name = data["name"]
    info = load_project_info(name)
    info.update({
        "location": data["location"],
        "description": data.get("description") or "",
        "region": data.get("region") or "",
        "start_date": data["start_date"],
        "end_date": data["end_date"],
        "active": True
    })
    save_project_info(name, info); set_active_project(name)
    await state.finish()
    await clear_then_anchor(uid, f"‚úÖ –ü—Ä–æ–µ–∫—Ç ¬´{h(name)}¬ª (–∫–æ–¥ {h(info.get('code') or '‚Äî')}) —Å–æ–∑–¥–∞–Ω –∏ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω.", kb_admin_projects())
    await c.answer("–ì–æ—Ç–æ–≤–æ")
    await update_all_anchors()
    text = (
        f"üèó <b>–°—Ç–∞—Ä—Ç –Ω–æ–≤–æ–≥–æ –ø—Ä–æ–µ–∫—Ç–∞!</b>\n\n"
        f"üìÇ <b>{h(name)}</b>\n"
        f"üÜî –ö–æ–¥ –æ–±—ä–µ–∫—Ç–∞: {h(info.get('code') or '‚Äî')}\n"
        f"üåç –û–±–ª–∞—Å—Ç—å: {h(info.get('region') or '‚Äî')}\n"
        f"üìç –õ–æ–∫–∞—Ü–∏—è: {h(info.get('location') or '‚Äî')}\n"
        f"üìÖ –°—Ä–æ–∫–∏: {h(info.get('start_date') or '‚Äî')} ‚Üí {h(info.get('end_date') or '‚Äî')}\n"
        f"‚ÑπÔ∏è {h(info.get('description') or '–î–æ–∫—É–º–µ–Ω—Ç—ã ‚Äî –≤ —Ä–∞–∑–¥–µ–ª–µ ¬´üìë –î–æ–∫—É–º–µ–Ω—Ç—ã¬ª')}\n\n"
        f"–î–æ–±–∞–≤–ª—è–π—Ç–µ —á–µ–∫–∏ —á–µ—Ä–µ–∑ ¬´üßæ –ß–µ–∫–∏¬ª ‚Üí ¬´üì∑ –î–æ–±–∞–≤–∏—Ç—å —á–µ–∫¬ª."
    )
    for f in os.listdir(USERS_PATH):
        if not f.endswith(".json"): continue
        try:
            udata = json.load(open(os.path.join(USERS_PATH, f), "r", encoding="utf-8"))
        except:
            continue
        chat_id = users_runtime.get(udata["user_id"], {}).get("tg", {}).get("chat_id") or udata.get("tg", {}).get("chat_id")
        if chat_id:
            try: await bot.send_message(chat_id, text, reply_markup=kb_broadcast_close())
            except Exception: pass


@dp.callback_query_handler(lambda c: c.data == "proj_activate")
async def proj_activate(c: types.CallbackQuery):
    uid = c.from_user.id
    projs = list_projects()
    if not projs:
        await clear_then_anchor(uid, "‚ùó –ù–µ—Ç –ø—Ä–æ–µ–∫—Ç–æ–≤.", kb_admin_projects()); return await c.answer()
    kb = InlineKeyboardMarkup()
    for p in projs: kb.add(InlineKeyboardButton(p, callback_data=f"proj_act_{p}"))
    kb.add(InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="adm_projects"))
    await clear_then_anchor(uid, "–í—ã–±–µ—Ä–∏—Ç–µ –ø—Ä–æ–µ–∫—Ç –¥–ª—è –∞–∫—Ç–∏–≤–∞—Ü–∏–∏:", kb)
    await c.answer()


@dp.callback_query_handler(lambda c: c.data.startswith("proj_act_"))
async def proj_activate_do(c: types.CallbackQuery):
    uid = c.from_user.id
    name = c.data.split("proj_act_",1)[1]
    ensure_project_structure(name)
    info = load_project_info(name); info["active"] = True; save_project_info(name, info)
    set_active_project(name)
    await clear_then_anchor(uid, f"‚úÖ –ê–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω –ø—Ä–æ–µ–∫—Ç: <b>{h(name)}</b> (–∫–æ–¥ {h(info.get('code') or '‚Äî')})", kb_admin_projects())
    await c.answer("–ê–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω")
    await update_all_anchors()


@dp.callback_query_handler(lambda c: c.data == "proj_finish")
async def proj_finish(c: types.CallbackQuery):
    uid = c.from_user.id
    projs = list_projects()
    if not projs:
        await clear_then_anchor(uid, "‚ùó –ù–µ—Ç –ø—Ä–æ–µ–∫—Ç–æ–≤.", kb_admin_projects()); return await c.answer()
    kb = InlineKeyboardMarkup()
    for p in projs: kb.add(InlineKeyboardButton(p, callback_data=f"proj_fin_{p}"))
    kb.add(InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="adm_projects"))
    await clear_then_anchor(uid, "–í—ã–±–µ—Ä–∏—Ç–µ –ø—Ä–æ–µ–∫—Ç –¥–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è:", kb)
    await c.answer()


@dp.callback_query_handler(lambda c: c.data.startswith("proj_fin_"))
async def proj_finish_do(c: types.CallbackQuery):
    uid = c.from_user.id
    name = c.data.split("proj_fin_",1)[1]
    info = load_project_info(name); info["active"] = False; save_project_info(name, info)
    if active_project["name"] == name: set_active_project(None)
    await clear_then_anchor(uid, f"‚úÖ –ü—Ä–æ–µ–∫—Ç ¬´{h(name)}¬ª (–∫–æ–¥ {h(info.get('code') or '‚Äî')}) –ø–æ–º–µ—á–µ–Ω –∫–∞–∫ –∑–∞–≤–µ—Ä—à—ë–Ω.", kb_admin_projects())
    await c.answer("–ó–∞–≤–µ—Ä—à—ë–Ω")
    await update_all_anchors()
    code = info.get("code") or "‚Äî"
    variants = [
        f"üéâ <b>–ü—Ä–æ–µ–∫—Ç ¬´{h(name)}¬ª (–∫–æ–¥ {h(code)}) –∑–∞–≤–µ—Ä—à—ë–Ω!</b>\n\n–°–ø–∞—Å–∏–±–æ –∑–∞ –æ—Ç–ª–∏—á–Ω—É—é —Ä–∞–±–æ—Ç—É.",
        f"‚úÖ <b>–û–±—ä–µ–∫—Ç ¬´{h(name)}¬ª (–∫–æ–¥ {h(code)}) –∑–∞–∫—Ä—ã—Ç.</b>\n\n–ë–ª–∞–≥–æ–¥–∞—Ä–∏–º –∫–∞–∂–¥–æ–≥–æ!",
        f"‚ú® <b>–ó–∞–≤–µ—Ä—à–∏–ª–∏ ¬´{h(name)}¬ª!</b>\n\n–ö–æ–¥ –æ–±—ä–µ–∫—Ç–∞: {h(code)}. –î–æ –≤—Å—Ç—Ä–µ—á–∏ –Ω–∞ –Ω–æ–≤—ã—Ö –ø—Ä–æ–µ–∫—Ç–∞—Ö."
    ]
    text = random.choice(variants)
    for f in os.listdir(USERS_PATH):
        if not f.endswith(".json"): continue
        try:
            udata = json.load(open(os.path.join(USERS_PATH, f), "r", encoding="utf-8"))
        except:
            continue
        chat_id = users_runtime.get(udata["user_id"], {}).get("tg", {}).get("chat_id") or udata.get("tg", {}).get("chat_id")
        if chat_id:
            try: await bot.send_message(chat_id, text, reply_markup=kb_broadcast_close())
            except Exception: pass


@dp.callback_query_handler(lambda c: c.data == "broadcast_close")
async def broadcast_close(c: types.CallbackQuery):
    try: await bot.delete_message(c.message.chat.id, c.message.message_id)
    except Exception: pass
    await c.answer("–°–æ–æ–±—â–µ–Ω–∏–µ –∑–∞–∫—Ä—ã—Ç–æ.")


@dp.callback_query_handler(lambda c: c.data == "close_saved_receipt")
async def close_saved_receipt_cb(c: types.CallbackQuery):
    try: await bot.delete_message(c.message.chat.id, c.message.message_id)
    except Exception: pass
    await c.answer("–°–æ–æ–±—â–µ–Ω–∏–µ –∑–∞–∫—Ä—ã—Ç–æ.")


@dp.callback_query_handler(lambda c: c.data == "admin_notice_close")
async def admin_notice_close(c: types.CallbackQuery):
    try: await bot.delete_message(c.message.chat.id, c.message.message_id)
    except Exception: pass
    await c.answer("–°–æ–æ–±—â–µ–Ω–∏–µ –∑–∞–∫—Ä—ã—Ç–æ.")


def _colorize_terminal(text: str, color: str) -> str:
    """Return text wrapped in ANSI color codes if the terminal supports it."""
    if not sys.stdout.isatty() or os.environ.get("NO_COLOR"):
        return text
    return f"\033[{color}m{text}\033[0m"


def print_startup_banner():
    """Print a vibrant startup banner for the SAARC Telegram bot."""
    launch_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    lines = [
        f"ü§ñ {BOT_NAME} v{BOT_VERSION}",
        f"üõ† Revision: {BOT_REVISION}",
        "üè¢ Company: SAARC",
        f"‚è± Launch time: {launch_time}",
        "üöÄ Telegram bot is warming up ‚Äî have a wonderful session!",
    ]
    width = max(len(line) for line in lines) + 4
    border = "‚ïê" * (width - 2)
    left = _colorize_terminal("‚ïë", "95")
    right = _colorize_terminal("‚ïë", "95")
    print(_colorize_terminal(f"‚ïî{border}‚ïó", "95"))
    for line in lines:
        padded = line.ljust(width - 4)
        print(f"{left} {_colorize_terminal(padded, '96')} {right}")
    print(_colorize_terminal(f"‚ïö{border}‚ïù", "95"))
    ready_line = f"{BOT_NAME} v{BOT_VERSION} | {BOT_REVISION} | ready for SAARC üöÄ"
    print(_colorize_terminal(ready_line, "92"))


async def on_startup(dispatcher):
    await alerts_bootstrap()
    await alerts_start_polling()


async def on_shutdown(dispatcher):
    global alerts_poll_task
    if alerts_poll_task:
        alerts_poll_task.cancel()
        try:
            await alerts_poll_task
        except asyncio.CancelledError:
            pass
        alerts_poll_task = None


# ========================== BOOT ==========================
if __name__ == "__main__":
    ensure_dirs()
    sync_state()
    print_startup_banner()
    executor.start_polling(dp, skip_updates=True, on_startup=on_startup, on_shutdown=on_shutdown)
